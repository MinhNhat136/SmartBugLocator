{
    "56012": {
        "summary": "Bug 56012 wrong import statement generation while using the extends attribute of the page directive",
        "code_segments": {
            "java\\org\\apache\\jasper\\tagplugins\\jstl\\core\\Set.java": [
                "    public void doTag(TagPluginContext ctxt) {\n        \n        //the flags to indicate whether the attributes have been specified\n        boolean hasValue = false, hasVar = false, hasScope = false, \n        hasTarget = false;\n        \n        //the scope name\n        String strScope;\n        //the id of the scope\n        int iScope;\n        \n        //initialize the flags\n        hasValue = ctxt.isAttributeSpecified(\"value\");\n        hasVar = ctxt.isAttributeSpecified(\"var\");\n        hasScope = ctxt.isAttributeSpecified(\"scope\");\n        hasTarget = ctxt.isAttributeSpecified(\"target\");\n        \n        //the temp variables name\n        String resultName = ctxt.getTemporaryVariableName();\n        String targetName = ctxt.getTemporaryVariableName();\n        String propertyName = ctxt.getTemporaryVariableName();\n        \n        //initialize the \"result\" which will be assigned to the var or target.property\n        ctxt.generateJavaSource(\"Object \" + resultName + \" = null;\");\n        if(hasValue){\n            ctxt.generateJavaSource(resultName + \" = \");\n            ctxt.generateAttribute(\"value\");\n            ctxt.generateJavaSource(\";\");\n        }else{\n            ctxt.dontUseTagPlugin();\n            return;\n        }\n        \n        //initialize the strScope\n        if(hasScope){\n            strScope = ctxt.getConstantAttribute(\"scope\");\n        }else{\n            strScope = \"page\";\n        }\n        \n        //get the iScope according to the strScope\n        iScope = Util.getScope(strScope);\n        \n        //if the attribute var has been specified then assign the result to the var;\n        if(hasVar){\n            String jspCtxt = null;\n            if (ctxt.isTagFile()) {\n                jspCtxt = \"this.getJspContext()\";\n            } else {\n                jspCtxt = \"_jspx_page_context\";\n            }\n            String strVar = ctxt.getConstantAttribute(\"var\");\n            ctxt.generateJavaSource(\"if(null != \" + resultName + \"){\");\n            ctxt.generateJavaSource(\"    \" + jspCtxt + \".setAttribute(\\\"\" + strVar + \"\\\",\" + resultName + \",\" + iScope + \");\");\n            ctxt.generateJavaSource(\"} else {\");\n            if(hasScope){\n                ctxt.generateJavaSource(\"    \" + jspCtxt + \".removeAttribute(\\\"\" + strVar + \"\\\",\" + iScope + \");\");\n            }else{\n                ctxt.generateJavaSource(\"    \" + jspCtxt + \".removeAttribute(\\\"\" + strVar + \"\\\");\");\n            }\n            ctxt.generateJavaSource(\"}\");\n            \n            //else assign the result to the target.property\n        }else if(hasTarget){\n            \n            //generate the temp variable name\n            String pdName = ctxt.getTemporaryVariableName();\n            String successFlagName = ctxt.getTemporaryVariableName();\n            String index = ctxt.getTemporaryVariableName();\n            String methodName = ctxt.getTemporaryVariableName();\n            \n            //initialize the property\n            ctxt.generateJavaSource(\"String \" + propertyName + \" = null;\");\n            ctxt.generateJavaSource(\"if(\");\n            ctxt.generateAttribute(\"property\");\n            ctxt.generateJavaSource(\" != null){\");\n            ctxt.generateJavaSource(\"    \" + propertyName + \" = (\");\n            ctxt.generateAttribute(\"property\");\n            ctxt.generateJavaSource(\").toString();\");\n            ctxt.generateJavaSource(\"}\");\n            \n            //initialize the target\n            ctxt.generateJavaSource(\"Object \" + targetName + \" = \");\n            ctxt.generateAttribute(\"target\");\n            ctxt.generateJavaSource(\";\");\n            \n            //the target is ok\n            ctxt.generateJavaSource(\"if(\" + targetName + \" != null){\");\n            \n            //if the target is a map, then put the result into the map with the key property\n            ctxt.generateJavaSource(\"    if(\" + targetName + \" instanceof java.util.Map){\");\n            ctxt.generateJavaSource(\"        if(null != \" + resultName + \"){\");\n            ctxt.generateJavaSource(\"            ((java.util.Map) \" + targetName + \").put(\" + propertyName + \",\" + resultName + \");\");\n            ctxt.generateJavaSource(\"        }else{\");\n            ctxt.generateJavaSource(\"            ((java.util.Map) \" + targetName + \").remove(\" + propertyName + \");\");\n            ctxt.generateJavaSource(\"        }\");\n            \n            //else assign the result to the target.property\n            ctxt.generateJavaSource(\"    }else{\");\n            ctxt.generateJavaSource(\"        try{\");\n            \n            //get all the property of the target\n            ctxt.generateJavaSource(\"            java.beans.PropertyDescriptor \" + pdName + \"[] = java.beans.Introspector.getBeanInfo(\" + targetName + \".getClass()).getPropertyDescriptors();\");\n            \n            //the success flag is to imply whether the assign is successful\n            ctxt.generateJavaSource(\"            boolean \" + successFlagName + \" = false;\");\n            \n            //find the right property\n            ctxt.generateJavaSource(\"            for(int \" + index + \"=0;\" + index + \"<\" + pdName + \".length;\" + index + \"++){\");\n            ctxt.generateJavaSource(\"                if(\" + pdName + \"[\" + index + \"].getName().equals(\" + propertyName + \")){\");\n            \n            //get the \"set\" method;\n            ctxt.generateJavaSource(\"                    java.lang.reflect.Method \" + methodName + \" = \" + pdName + \"[\" + index + \"].getWriteMethod();\");\n            ctxt.generateJavaSource(\"                    if(null == \" + methodName + \"){\");\n            ctxt.generateJavaSource(\"                        throw new JspException(\\\"No setter method in &lt;set&gt; for property \\\"+\" + propertyName + \");\");\n            ctxt.generateJavaSource(\"                    }\");\n            \n            //invoke the method through the reflection\n            ctxt.generateJavaSource(\"                    if(\" + resultName + \" != null){\");\n            ctxt.generateJavaSource(\"                        \" + methodName + \".invoke(\" + targetName + \", new Object[]{org.apache.el.lang.ELSupport.coerceToType(\" + resultName + \", \" + methodName + \".getParameterTypes()[0])});\");\n            ctxt.generateJavaSource(\"                    }else{\");\n            ctxt.generateJavaSource(\"                        \" + methodName + \".invoke(\" + targetName + \", new Object[]{null});\");\n            ctxt.generateJavaSource(\"                    }\");\n            ctxt.generateJavaSource(\"                    \" + successFlagName + \" = true;\");\n            ctxt.generateJavaSource(\"                }\");\n            ctxt.generateJavaSource(\"            }\");\n            ctxt.generateJavaSource(\"            if(!\" + successFlagName + \"){\");\n            ctxt.generateJavaSource(\"                throw new JspException(\\\"Invalid property in &lt;set&gt;:\\\"+\" + propertyName + \");\");\n            ctxt.generateJavaSource(\"            }\");\n            ctxt.generateJavaSource(\"        }\");\n            \n            //catch the el exception and throw it as a JspException\n            ctxt.generateJavaSource(\"        catch (IllegalAccessException ex) {\");\n            ctxt.generateJavaSource(\"            throw new JspException(ex);\");\n            ctxt.generateJavaSource(\"        } catch (java.beans.IntrospectionException ex) {\");\n            ctxt.generateJavaSource(\"            throw new JspException(ex);\");\n            ctxt.generateJavaSource(\"        } catch (java.lang.reflect.InvocationTargetException ex) {\");\n            ctxt.generateJavaSource(\"            if (ex.getCause() instanceof ThreadDeath) {\");\n            ctxt.generateJavaSource(\"                throw (ThreadDeath) ex.getCause();\");\n            ctxt.generateJavaSource(\"            }\");\n            ctxt.generateJavaSource(\"            if (ex.getCause() instanceof VirtualMachineError) {\");\n            ctxt.generateJavaSource(\"                throw (VirtualMachineError) ex.getCause();\");\n            ctxt.generateJavaSource(\"            }\");\n            ctxt.generateJavaSource(\"            throw new JspException(ex);\");\n            ctxt.generateJavaSource(\"        }\");\n            ctxt.generateJavaSource(\"    }\");\n            ctxt.generateJavaSource(\"}else{\");\n            ctxt.generateJavaSource(\"    throw new JspException();\");\n            ctxt.generateJavaSource(\"}\");\n        }\n    }"
            ],
            "test\\org\\apache\\catalina\\core\\TestStandardHostValve.java": [
                "    public void testErrorPageHandling() throws Exception {\n        // Set up a container\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        // Add the error page\n        Tomcat.addServlet(ctx, \"error\", new ErrorServlet());\n        ctx.addServletMapping(\"/error\", \"error\");\n\n        // Add the error handling page\n        Tomcat.addServlet(ctx, \"report\", new ReportServlet());\n        ctx.addServletMapping(\"/report/*\", \"report\");\n\n        // And the handling for 500 responses\n        ErrorPage errorPage500 = new ErrorPage();\n        errorPage500.setErrorCode(Response.SC_INTERNAL_SERVER_ERROR);\n        errorPage500.setLocation(\"/report/500\");\n        ctx.addErrorPage(errorPage500);\n\n        // And the default error handling\n        ErrorPage errorPageDefault = new ErrorPage();\n        errorPageDefault.setLocation(\"/report/default\");\n        ctx.addErrorPage(errorPageDefault);\n\n        tomcat.start();\n\n        doTestErrorPageHandling(500, \"/500\");\n        doTestErrorPageHandling(501, \"/default\");\n    }"
            ],
            "modules\\jdbc-pool\\src\\main\\java\\org\\apache\\tomcat\\jdbc\\pool\\interceptor\\StatementCache.java": [
                "    public void reset(ConnectionPool parent, PooledConnection con) {\n        super.reset(parent, con);\n        if (parent==null) {\n            cacheSize = null;\n            this.pcon = null;\n        } else {\n            cacheSize = cacheSizeMap.get(parent);\n            this.pcon = con;\n            if (!pcon.getAttributes().containsKey(STATEMENT_CACHE_ATTR)) {\n                ConcurrentHashMap<String,CachedStatement> cache = new ConcurrentHashMap<String, CachedStatement>();\n                pcon.getAttributes().put(STATEMENT_CACHE_ATTR,cache);\n            }\n        }\n    }\n\n    public void disconnected(ConnectionPool parent, PooledConnection con, boolean finalizing) {\n        @SuppressWarnings(\"unchecked\")\n        ConcurrentHashMap<String,CachedStatement> statements =\n            (ConcurrentHashMap<String,CachedStatement>)con.getAttributes().get(STATEMENT_CACHE_ATTR);\n\n        if (statements!=null) {\n            for (Map.Entry<String, CachedStatement> p : statements.entrySet()) {\n                closeStatement(p.getValue());\n            }\n            statements.clear();\n        }\n\n        super.disconnected(parent, con, finalizing);\n    }",
                "    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        boolean process = process(this.types, method, false);\n        if (process && args.length>0 && args[0] instanceof String) {\n            CachedStatement statement = isCached((String)args[0]);\n            if (statement!=null) {\n                //remove it from the cache since it is used\n                removeStatement(statement);\n                return statement.getActualProxy();\n            } else {\n                return super.invoke(proxy, method, args);\n            }\n        } else {\n            return super.invoke(proxy,method,args);\n        }\n    }\n\n    public boolean cacheStatement(CachedStatement proxy) {\n        @SuppressWarnings(\"unchecked\")\n        ConcurrentHashMap<String,CachedStatement> cache =\n            (ConcurrentHashMap<String,CachedStatement>)pcon.getAttributes().get(STATEMENT_CACHE_ATTR);\n        if (proxy.getSql()==null) {\n            return false;\n        } else if (cache.containsKey(proxy.getSql())) {\n            return false;\n        } else if (cacheSize.get()>=maxCacheSize) {\n            return false;\n        } else if (cacheSize.incrementAndGet()>maxCacheSize) {\n            cacheSize.decrementAndGet();\n            return false;\n        } else {\n            //cache the statement\n            cache.put(proxy.getSql(), proxy);\n            return true;\n        }\n    }",
                "    public boolean removeStatement(CachedStatement proxy) {\n        @SuppressWarnings(\"unchecked\")\n        ConcurrentHashMap<String,CachedStatement> cache =\n            (ConcurrentHashMap<String,CachedStatement>)pcon.getAttributes().get(STATEMENT_CACHE_ATTR);\n        if (cache.remove(proxy.getSql()) != null) {\n            cacheSize.decrementAndGet();\n            return true;\n        } else {\n            return false;\n        }\n    }"
            ],
            "modules\\jdbc-pool\\src\\main\\java\\org\\apache\\tomcat\\jdbc\\pool\\interceptor\\StatementFinalizer.java": [
                "    public Object createStatement(Object proxy, Method method, Object[] args, Object statement, long time) {\n        try {\n            if (statement instanceof Statement)\n                statements.add(new WeakReference<Statement>((Statement)statement));\n        }catch (ClassCastException x) {\n            //ignore this one\n        }\n        return statement;\n    }\n\n    public void closeInvoked() {\n        while (statements.size()>0) {\n            WeakReference<Statement> ws = statements.remove(0);\n            Statement st = ws.get();\n            if (st!=null) {\n                try {\n                    st.close();\n                } catch (Exception ignore) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Unable to closed statement upon connection close.\",ignore);\n                    }\n                }\n            }\n        }\n    }"
            ],
            "java\\org\\apache\\jasper\\tagplugins\\jstl\\core\\Catch.java": [
                "    public void doTag(TagPluginContext ctxt) {\n        \n        //flag for the existence of the var attribute\n        boolean hasVar = ctxt.isAttributeSpecified(\"var\");\n        \n        //temp name for exception and caught\n        String exceptionName = ctxt.getTemporaryVariableName();\n        String caughtName = ctxt.getTemporaryVariableName();\n        \n        //main part to generate code\n        ctxt.generateJavaSource(\"boolean \" + caughtName + \" = false;\");\n        ctxt.generateJavaSource(\"try{\");\n        ctxt.generateBody();\n        ctxt.generateJavaSource(\"}\");\n        \n        //do catch\n        ctxt.generateJavaSource(\"catch(Throwable \" + exceptionName + \"){\");\n        \n        //if the var specified, the exception object should \n        //be set to the attribute \"var\" defines in page scope \n        if(hasVar){\n            String strVar = ctxt.getConstantAttribute(\"var\");\n            ctxt.generateJavaSource(\"    pageContext.setAttribute(\\\"\" + strVar + \"\\\", \" \n                    + exceptionName + \", PageContext.PAGE_SCOPE);\");\n        }\n        \n        //whenever there's exception caught, \n        //the flag caught should be set true;\n        ctxt.generateJavaSource(\"    \" + caughtName + \" = true;\");\n        ctxt.generateJavaSource(\"}\");\n        \n        //do finally\n        ctxt.generateJavaSource(\"finally{\");\n        \n        //if var specified, the attribute it defines \n        //in page scope should be removed\n        if(hasVar){\n            String strVar = ctxt.getConstantAttribute(\"var\");\n            ctxt.generateJavaSource(\"    if(!\" + caughtName + \"){\");\n            ctxt.generateJavaSource(\"        pageContext.removeAttribute(\\\"\" + strVar + \"\\\", PageContext.PAGE_SCOPE);\");\n            ctxt.generateJavaSource(\"    }\");\n        }\n        \n        ctxt.generateJavaSource(\"}\");\n    }"
            ],
            "java\\org\\apache\\jasper\\tagplugins\\jstl\\core\\Remove.java": [
                "    public void doTag(TagPluginContext ctxt) {\n        \n        //scope flag\n        boolean hasScope = ctxt.isAttributeSpecified(\"scope\");\n        \n        //the value of the \"var\"\n        String strVar = ctxt.getConstantAttribute(\"var\");\n        \n        //remove attribute from certain scope.\n        //default scope is \"page\".\n        if(hasScope){\n            int iScope = Util.getScope(ctxt.getConstantAttribute(\"scope\"));\n            ctxt.generateJavaSource(\"pageContext.removeAttribute(\\\"\" + strVar + \"\\\",\" + iScope + \");\");\n        }else{\n            ctxt.generateJavaSource(\"pageContext.removeAttribute(\\\"\" + strVar + \"\\\");\");\n        }\n    }"
            ],
            "java\\org\\apache\\catalina\\core\\StandardHostValve.java": [
                "    private void status(Request request, Response response) {\n\n        int statusCode = response.getStatus();\n\n        // Handle a custom error page for this status code\n        Context context = request.getContext();\n        if (context == null)\n            return;\n\n        /* Only look for error pages when isError() is set.\n         * isError() is set when response.sendError() is invoked. This\n         * allows custom error pages without relying on default from\n         * web.xml.\n         */\n        if (!response.isError())\n            return;\n\n        ErrorPage errorPage = context.findErrorPage(statusCode);\n        if (errorPage == null) {\n            // Look for a default error page\n            errorPage = context.findErrorPage(0);\n        }\n        if (errorPage != null) {\n            response.setAppCommitted(false);\n            request.setAttribute(RequestDispatcher.ERROR_STATUS_CODE,\n                              Integer.valueOf(statusCode));\n\n            String message = response.getMessage();\n            if (message == null)\n                message = \"\";\n            request.setAttribute(RequestDispatcher.ERROR_MESSAGE, message);\n            request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                    errorPage.getLocation());\n            request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,\n                    DispatcherType.ERROR);\n\n\n            Wrapper wrapper = request.getWrapper();\n            if (wrapper != null)\n                request.setAttribute(RequestDispatcher.ERROR_SERVLET_NAME,\n                                  wrapper.getName());\n            request.setAttribute(RequestDispatcher.ERROR_REQUEST_URI,\n                                 request.getRequestURI());\n            if (custom(request, response, errorPage)) {\n                try {\n                    response.flushBuffer();\n                } catch (ClientAbortException e) {\n                    // Ignore\n                } catch (IOException e) {\n                    container.getLogger().warn(\"Exception Processing \" + errorPage, e);\n                }\n            }\n        }\n    }"
            ],
            "java\\org\\apache\\catalina\\ant\\JMXSetTask.java": [
                "    public void execute() throws BuildException {\n        super.execute();\n        if (bean == null || attribute == null || value == null) {\n            throw new BuildException\n                (\"Must specify 'bean', 'attribute' and 'value' attributes\");\n        }\n        log(\"Setting attribute \" + attribute +\n                            \" in bean \" + bean +\n                            \" to \" + value); \n        try {\n            execute(\"/jmxproxy/?set=\" + URLEncoder.encode(bean, getCharset()) \n                    + \"&att=\" + URLEncoder.encode(attribute, getCharset()) \n                    + \"&val=\" + URLEncoder.encode(value, getCharset()));\n        } catch (UnsupportedEncodingException e) {\n            throw new BuildException\n                (\"Invalid 'charset' attribute: \" + getCharset());\n        }\n    }"
            ],
            "java\\org\\apache\\catalina\\ant\\JMXGetTask.java": [
                "    public void execute() throws BuildException {\n        super.execute();\n        if (bean == null || attribute == null) {\n            throw new BuildException\n                (\"Must specify 'bean' and 'attribute' attributes\");\n        }\n        log(\"Getting attribute \" + attribute +\n                \" in bean \" + bean );\n        try {\n            execute(\"/jmxproxy/?get=\" + URLEncoder.encode(bean, getCharset()) \n                    + \"&att=\" + URLEncoder.encode(attribute, getCharset()));\n        } catch (UnsupportedEncodingException e) {\n            throw new BuildException\n                (\"Invalid 'charset' attribute: \" + getCharset());\n        }\n    }"
            ],
            "test\\org\\apache\\catalina\\ha\\session\\TestSerializablePrincipal.java": [
                "    public void testWriteReadPrincipal() {\n        // Get a temporary file to use for the serialization test\n        File file = null;\n        try {\n            file = File.createTempFile(\"ser\", null);\n            file.deleteOnExit();\n        } catch (IOException e) {\n            e.printStackTrace();\n            fail(\"ioe creating temporary file\");\n        }\n\n        // Create the Principal to serialize\n        List<String> roles = new ArrayList<String>();\n        roles.add(\"RoleA\");\n        roles.add(\"RoleB\");\n        TesterPrincipal tpOriginal = new TesterPrincipal(\"inner\");\n        GenericPrincipal gpOriginal =\n            new GenericPrincipal(\"usr\", \"pwd\", roles, tpOriginal);\n\n        // Do the serialization\n        try {\n            FileOutputStream fos = new FileOutputStream(file);\n            ObjectOutputStream oos = new ObjectOutputStream(fos);\n            SerializablePrincipal.writePrincipal(gpOriginal, oos);\n            oos.close();\n            fos.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            fail(\"fnfe creating object output stream\");\n        } catch (IOException e) {\n            e.printStackTrace();\n            fail(\"ioe serializing principal\");\n        }\n\n        // De-serialize the Principal\n        GenericPrincipal gpNew = null;\n        try {\n            FileInputStream fis = new FileInputStream(file);\n            ObjectInputStream ois = new ObjectInputStream(fis);\n            gpNew = SerializablePrincipal.readPrincipal(ois);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            fail(\"fnfe reading object output stream\");\n        } catch (IOException e) {\n            e.printStackTrace();\n            fail(\"ioe de-serializing principal\");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            fail(\"cnfe de-serializing principal\");\n        }\n\n        // Now test how similar original and de-serialized versions are\n        assertEquals(\"User names different\", gpOriginal.getName(),\n                gpNew.getName());\n        assertEquals(\"Passwords different\", gpOriginal.getPassword(),\n                gpNew.getPassword());\n        assertEquals(\"Number of roles different\", gpOriginal.getRoles().length,\n                gpNew.getRoles().length);\n        for (int i = 0; i < gpOriginal.getRoles().length; i++) {\n            assertEquals(\"Role name index \" + i + \"different\",\n                    gpOriginal.getRoles()[i], gpNew.getRoles()[i]);\n        }\n        // These are the key tests for bug 43840\n        assertNotSame(\"Inner principal not present\", gpNew,\n                gpNew.getUserPrincipal());\n        assertEquals(\"Inner user names are different\", tpOriginal.getName(),\n                gpNew.getUserPrincipal().getName());\n    }"
            ],
            "test\\org\\apache\\catalina\\core\\TestStandardContextValve.java": [
                "    public void testBug51653a() throws Exception {\n        // Set up a container\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        // Traces order of events across multiple components\n        StringBuilder trace = new StringBuilder();\n\n        //Add the error page\n        Tomcat.addServlet(ctx, \"errorPage\", new Bug51653ErrorPage(trace));\n        ctx.addServletMapping(\"/error\", \"errorPage\");\n        // And the handling for 404 responses\n        ErrorPage errorPage = new ErrorPage();\n        errorPage.setErrorCode(Response.SC_NOT_FOUND);\n        errorPage.setLocation(\"/error\");\n        ctx.addErrorPage(errorPage);\n\n        // Add the request listener\n        Bug51653RequestListener reqListener =\n            new Bug51653RequestListener(trace);\n        ((StandardContext) ctx).addApplicationEventListener(reqListener);\n\n        tomcat.start();\n\n        // Request a page that does not exist\n        int rc = getUrl(\"http://localhost:\" + getPort() + \"/invalid\",\n                new ByteChunk(), null);\n\n        // Need to allow time (but not too long in case the test fails) for\n        // ServletRequestListener to complete\n        int i = 20;\n        while (i > 0) {\n            if (trace.toString().endsWith(\"Destroy\")) {\n                break;\n            }\n            Thread.sleep(250);\n            i--;\n        }\n\n        assertEquals(Response.SC_NOT_FOUND, rc);\n        assertEquals(\"InitErrorDestroy\", trace.toString());\n    }",
                "    public void testBug51653b() throws Exception {\n        // Set up a container\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        // Traces order of events across multiple components\n        StringBuilder trace = new StringBuilder();\n\n        // Add the page that generates the error\n        Tomcat.addServlet(ctx, \"test\", new Bug51653ErrorTrigger());\n        ctx.addServletMapping(\"/test\", \"test\");\n\n        // Add the error page\n        Tomcat.addServlet(ctx, \"errorPage\", new Bug51653ErrorPage(trace));\n        ctx.addServletMapping(\"/error\", \"errorPage\");\n        // And the handling for 404 responses\n        ErrorPage errorPage = new ErrorPage();\n        errorPage.setErrorCode(Response.SC_NOT_FOUND);\n        errorPage.setLocation(\"/error\");\n        ctx.addErrorPage(errorPage);\n\n        // Add the request listener\n        Bug51653RequestListener reqListener =\n            new Bug51653RequestListener(trace);\n        ((StandardContext) ctx).addApplicationEventListener(reqListener);\n\n        tomcat.start();\n\n        // Request a page that does not exist\n        int rc = getUrl(\"http://localhost:\" + getPort() + \"/test\",\n                new ByteChunk(), null);\n\n        // Need to allow time (but not too long in case the test fails) for\n        // ServletRequestListener to complete\n        int i = 20;\n        while (i > 0) {\n            if (trace.toString().endsWith(\"Destroy\")) {\n                break;\n            }\n            Thread.sleep(250);\n            i--;\n        }\n\n        assertEquals(Response.SC_NOT_FOUND, rc);\n        assertEquals(\"InitErrorDestroy\", trace.toString());\n    }"
            ],
            "java\\org\\apache\\catalina\\tribes\\transport\\bio\\MultipointBioSender.java": [
                "    public synchronized void sendMessage(Member[] destination, ChannelMessage msg) throws ChannelException {\n        byte[] data = XByteBuffer.createDataPackage((ChannelData)msg);\n        BioSender[] senders = setupForSend(destination);\n        ChannelException cx = null;\n        for ( int i=0; i<senders.length; i++ ) {\n            try {\n                senders[i].sendMessage(data,(msg.getOptions()&Channel.SEND_OPTIONS_USE_ACK)==Channel.SEND_OPTIONS_USE_ACK);\n            } catch (Exception x) {\n                if (cx == null) cx = new ChannelException(x);\n                cx.addFaultyMember(destination[i],x);\n            }\n        }\n        if (cx!=null ) throw cx;\n    }\n\n    public void connect() throws IOException {\n        //do nothing, we connect on demand\n        setConnected(true);\n    }\n\n    private synchronized void close() throws ChannelException  {\n        ChannelException x = null;\n        Object[] members = bioSenders.keySet().toArray();\n        for (int i=0; i<members.length; i++ ) {\n            Member mbr = (Member)members[i];\n            try {\n                BioSender sender = bioSenders.get(mbr);\n                sender.disconnect();\n            }catch ( Exception e ) {\n                if ( x == null ) x = new ChannelException(e);\n                x.addFaultyMember(mbr,e);\n            }\n            bioSenders.remove(mbr);\n        }\n        if ( x != null ) throw x;\n    }",
                "    public void remove(Member member) {\n        //disconnect senders\n        BioSender sender = bioSenders.remove(member);\n        if ( sender != null ) sender.disconnect();\n    }\n\n    public synchronized void disconnect() {\n        try {close(); }catch (Exception x){/* Ignore */}\n        setConnected(false);\n    }\n\n    public boolean keepalive() {\n        //throw new UnsupportedOperationException(\"Method ParallelBioSender.checkKeepAlive() not implemented\");\n        boolean result = false;\n        @SuppressWarnings(\"unchecked\") // bioSenders is of type HashMap<Member, BioSender>\n        Map.Entry<Member,BioSender>[] entries = bioSenders.entrySet().toArray(new Map.Entry[bioSenders.size()]);\n        for ( int i=0; i<entries.length; i++ ) {\n            BioSender sender = entries[i].getValue();\n            if ( sender.keepalive() ) {\n                bioSenders.remove(entries[i].getKey());\n            }\n        }\n        return result;\n    }"
            ],
            "java\\org\\apache\\jasper\\compiler\\Compiler.java": [
                "    protected String[] generateJava() throws Exception {\n\n        String[] smapStr = null;\n\n        long t1, t2, t3, t4;\n\n        t1 = t2 = t3 = t4 = 0;\n\n        if (log.isDebugEnabled()) {\n            t1 = System.currentTimeMillis();\n        }\n\n        // Setup page info area\n        pageInfo = new PageInfo(new BeanRepository(ctxt.getClassLoader(),\n                errDispatcher), ctxt.getJspFile(), ctxt.isTagFile());\n\n        JspConfig jspConfig = options.getJspConfig();\n        JspConfig.JspProperty jspProperty = jspConfig.findJspProperty(ctxt\n                .getJspFile());\n\n        /*\n         * If the current uri is matched by a pattern specified in a\n         * jsp-property-group in web.xml, initialize pageInfo with those\n         * properties.\n         */\n        if (jspProperty.isELIgnored() != null) {\n            pageInfo.setELIgnored(JspUtil.booleanValue(jspProperty\n                    .isELIgnored()));\n        }\n        if (jspProperty.isScriptingInvalid() != null) {\n            pageInfo.setScriptingInvalid(JspUtil.booleanValue(jspProperty\n                    .isScriptingInvalid()));\n        }\n        if (jspProperty.getIncludePrelude() != null) {\n            pageInfo.setIncludePrelude(jspProperty.getIncludePrelude());\n        }\n        if (jspProperty.getIncludeCoda() != null) {\n            pageInfo.setIncludeCoda(jspProperty.getIncludeCoda());\n        }\n        if (jspProperty.isDeferedSyntaxAllowedAsLiteral() != null) {\n            pageInfo.setDeferredSyntaxAllowedAsLiteral(JspUtil.booleanValue(jspProperty\n                    .isDeferedSyntaxAllowedAsLiteral()));\n        }\n        if (jspProperty.isTrimDirectiveWhitespaces() != null) {\n            pageInfo.setTrimDirectiveWhitespaces(JspUtil.booleanValue(jspProperty\n                    .isTrimDirectiveWhitespaces()));\n        }\n        // Default ContentType processing is deferred until after the page has\n        // been parsed\n        if (jspProperty.getBuffer() != null) {\n            pageInfo.setBufferValue(jspProperty.getBuffer(), null,\n                    errDispatcher);\n        }\n        if (jspProperty.isErrorOnUndeclaredNamespace() != null) {\n            pageInfo.setErrorOnUndeclaredNamespace(\n                    JspUtil.booleanValue(\n                            jspProperty.isErrorOnUndeclaredNamespace()));\n        }\n        if (ctxt.isTagFile()) {\n            try {\n                double libraryVersion = Double.parseDouble(ctxt.getTagInfo()\n                        .getTagLibrary().getRequiredVersion());\n                if (libraryVersion < 2.0) {\n                    pageInfo.setIsELIgnored(\"true\", null, errDispatcher, true);\n                }\n                if (libraryVersion < 2.1) {\n                    pageInfo.setDeferredSyntaxAllowedAsLiteral(\"true\", null,\n                            errDispatcher, true);\n                }\n            } catch (NumberFormatException ex) {\n                errDispatcher.jspError(ex);\n            }\n        }\n\n        ctxt.checkOutputDir();\n        String javaFileName = ctxt.getServletJavaFileName();\n\n        ServletWriter writer = null;\n        try {\n            /*\n             * The setting of isELIgnored changes the behaviour of the parser\n             * in subtle ways. To add to the 'fun', isELIgnored can be set in\n             * any file that forms part of the translation unit so setting it\n             * in a file included towards the end of the translation unit can\n             * change how the parser should have behaved when parsing content\n             * up to the point where isELIgnored was set. Arghh!\n             * Previous attempts to hack around this have only provided partial\n             * solutions. We now use two passes to parse the translation unit.\n             * The first just parses the directives and the second parses the\n             * whole translation unit once we know how isELIgnored has been set.\n             * TODO There are some possible optimisations of this process.  \n             */ \n            // Parse the file\n            ParserController parserCtl = new ParserController(ctxt, this);\n            \n            // Pass 1 - the directives\n            Node.Nodes directives =\n                parserCtl.parseDirectives(ctxt.getJspFile());\n            Validator.validateDirectives(this, directives);\n            \n            // Pass 2 - the whole translation unit\n            pageNodes = parserCtl.parse(ctxt.getJspFile());\n\n            // Leave this until now since it can only be set once - bug 49726\n            if (pageInfo.getContentType() == null &&\n                    jspProperty.getDefaultContentType() != null) {\n                pageInfo.setContentType(jspProperty.getDefaultContentType());\n            }\n\n            if (ctxt.isPrototypeMode()) {\n                // generate prototype .java file for the tag file\n                writer = setupContextWriter(javaFileName);\n                Generator.generate(writer, this, pageNodes);\n                writer.close();\n                writer = null;\n                return null;\n            }\n\n            // Validate and process attributes - don't re-validate the\n            // directives we validated in pass 1\n            Validator.validateExDirectives(this, pageNodes);\n\n            if (log.isDebugEnabled()) {\n                t2 = System.currentTimeMillis();\n            }\n\n            // Collect page info\n            Collector.collect(this, pageNodes);\n\n            // Compile (if necessary) and load the tag files referenced in\n            // this compilation unit.\n            tfp = new TagFileProcessor();\n            tfp.loadTagFiles(this, pageNodes);\n\n            if (log.isDebugEnabled()) {\n                t3 = System.currentTimeMillis();\n            }\n\n            // Determine which custom tag needs to declare which scripting vars\n            ScriptingVariabler.set(pageNodes, errDispatcher);\n\n            // Optimizations by Tag Plugins\n            TagPluginManager tagPluginManager = options.getTagPluginManager();\n            tagPluginManager.apply(pageNodes, errDispatcher, pageInfo);\n\n            // Optimization: concatenate contiguous template texts.\n            TextOptimizer.concatenate(this, pageNodes);\n\n            // Generate static function mapper codes.\n            ELFunctionMapper.map(pageNodes);\n\n            // generate servlet .java file\n            writer = setupContextWriter(javaFileName);\n            Generator.generate(writer, this, pageNodes);\n            writer.close();\n            writer = null;\n\n            // The writer is only used during the compile, dereference\n            // it in the JspCompilationContext when done to allow it\n            // to be GC'd and save memory.\n            ctxt.setWriter(null);\n\n            if (log.isDebugEnabled()) {\n                t4 = System.currentTimeMillis();\n                log.debug(\"Generated \" + javaFileName + \" total=\" + (t4 - t1)\n                        + \" generate=\" + (t4 - t3) + \" validate=\" + (t2 - t1));\n            }\n\n        } catch (Exception e) {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (Exception e1) {\n                    // do nothing\n                }\n            }\n            // Remove the generated .java file\n            File file = new File(javaFileName);\n            if (file.exists()) {\n                if (!file.delete()) {\n                    log.warn(Localizer.getMessage(\n                            \"jsp.warning.compiler.javafile.delete.fail\",\n                            file.getAbsolutePath()));\n                }\n            }\n            throw e;\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                } catch (Exception e2) {\n                    // do nothing\n                }\n            }\n        }\n\n        // JSR45 Support\n        if (!options.isSmapSuppressed()) {\n            smapStr = SmapUtil.generateSmap(ctxt, pageNodes);\n        }\n\n        // If any proto type .java and .class files was generated,\n        // the prototype .java may have been replaced by the current\n        // compilation (if the tag file is self referencing), but the\n        // .class file need to be removed, to make sure that javac would\n        // generate .class again from the new .java file just generated.\n        tfp.removeProtoTypeFiles(ctxt.getClassFileName());\n\n        return smapStr;\n    }",
                "    public boolean isOutDated(boolean checkClass) {\n\n        if (jsw != null\n                && (ctxt.getOptions().getModificationTestInterval() > 0)) {\n\n            if (jsw.getLastModificationTest()\n                    + (ctxt.getOptions().getModificationTestInterval() * 1000) > System\n                    .currentTimeMillis()) {\n                return false;\n            }\n            jsw.setLastModificationTest(System.currentTimeMillis());\n        }\n\n        Long jspRealLastModified = ctxt.getLastModified(ctxt.getJspFile());\n        if (jspRealLastModified.longValue() < 0) {\n            // Something went wrong - assume modification\n            return true;\n        }\n\n        long targetLastModified = 0;\n        File targetFile;\n\n        if (checkClass) {\n            targetFile = new File(ctxt.getClassFileName());\n        } else {\n            targetFile = new File(ctxt.getServletJavaFileName());\n        }\n\n        if (!targetFile.exists()) {\n            return true;\n        }\n\n        targetLastModified = targetFile.lastModified();\n        if (checkClass && jsw != null) {\n            jsw.setServletClassLastModifiedTime(targetLastModified);\n        }\n        if (targetLastModified != jspRealLastModified.longValue()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Compiler: outdated: \" + targetFile + \" \"\n                        + targetLastModified);\n            }\n            return true;\n        }\n\n        // determine if source dependent files (e.g. includes using include\n        // directives) have been changed.\n        if (jsw == null) {\n            return false;\n        }\n\n        Map<String,Long> depends = jsw.getDependants();\n        if (depends == null) {\n            return false;\n        }\n\n        Iterator<Entry<String,Long>> it = depends.entrySet().iterator();\n        while (it.hasNext()) {\n            Entry<String,Long> include = it.next();\n            try {\n                String key = include.getKey();\n                URL includeUrl;\n                if (key.startsWith(\"jar:\") || key.startsWith(\"file:\")) {\n                    includeUrl = new URL(key);\n                } else {\n                    includeUrl = ctxt.getResource(include.getKey());\n                }\n                if (includeUrl == null) {\n                    return true;\n                }\n\n                URLConnection iuc = includeUrl.openConnection();\n                long includeLastModified = 0;\n                if (iuc instanceof JarURLConnection) {\n                    includeLastModified =\n                        ((JarURLConnection) iuc).getJarEntry().getTime();\n                } else {\n                    includeLastModified = iuc.getLastModified();\n                }\n                iuc.getInputStream().close();\n\n                if (includeLastModified != include.getValue().longValue()) {\n                    return true;\n                }\n            } catch (Exception e) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Problem accessing resource. Treat as outdated.\",\n                            e);\n                return true;\n            }\n        }\n\n        return false;\n\n    }",
                "    public void removeGeneratedFiles() {\n        removeGeneratedClassFiles();\n\n        try {\n            String javaFileName = ctxt.getServletJavaFileName();\n            if (javaFileName != null) {\n                File javaFile = new File(javaFileName);\n                if (log.isDebugEnabled())\n                    log.debug(\"Deleting \" + javaFile);\n                if (javaFile.exists()) {\n                    if (!javaFile.delete()) {\n                        log.warn(Localizer.getMessage(\n                                \"jsp.warning.compiler.javafile.delete.fail\",\n                                javaFile.getAbsolutePath()));\n                    }\n                }\n            }\n        } catch (Exception e) {\n            // Remove as much as possible, log possible exceptions\n            log.warn(Localizer.getMessage(\"jsp.warning.compiler.classfile.delete.fail.unknown\"),\n                     e);\n        }\n    }",
                "    public void removeGeneratedClassFiles() {\n        try {\n            String classFileName = ctxt.getClassFileName();\n            if (classFileName != null) {\n                File classFile = new File(classFileName);\n                if (log.isDebugEnabled())\n                    log.debug(\"Deleting \" + classFile);\n                if (classFile.exists()) {\n                    if (!classFile.delete()) {\n                        log.warn(Localizer.getMessage(\n                                \"jsp.warning.compiler.classfile.delete.fail\",\n                                classFile.getAbsolutePath()));\n                    }\n                }\n            }\n        } catch (Exception e) {\n            // Remove as much as possible, log possible exceptions\n            log.warn(Localizer.getMessage(\"jsp.warning.compiler.classfile.delete.fail.unknown\"),\n                     e);\n        }\n    }"
            ],
            "java\\org\\apache\\tomcat\\util\\bcel\\classfile\\Unknown.java": [
                "    public Attribute copy( ConstantPool _constant_pool ) {\n        Unknown c = (Unknown) clone();\n        if (bytes != null) {\n            c.bytes = new byte[bytes.length];\n            System.arraycopy(bytes, 0, c.bytes, 0, bytes.length);\n        }\n        c.constant_pool = _constant_pool;\n        return c;\n    }"
            ]
        }
    },
    "56029": {
        "summary": "Bug 56029 Ternary operator doesn't work as expected inside attributes in jspx pages",
        "code_segments": {
            "test\\org\\apache\\catalina\\core\\TestStandardHostValve.java": [
                "    public void testErrorPageHandling() throws Exception {\n        // Set up a container\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        // Add the error page\n        Tomcat.addServlet(ctx, \"error\", new ErrorServlet());\n        ctx.addServletMapping(\"/error\", \"error\");\n\n        // Add the error handling page\n        Tomcat.addServlet(ctx, \"report\", new ReportServlet());\n        ctx.addServletMapping(\"/report/*\", \"report\");\n\n        // And the handling for 500 responses\n        ErrorPage errorPage500 = new ErrorPage();\n        errorPage500.setErrorCode(Response.SC_INTERNAL_SERVER_ERROR);\n        errorPage500.setLocation(\"/report/500\");\n        ctx.addErrorPage(errorPage500);\n\n        // And the default error handling\n        ErrorPage errorPageDefault = new ErrorPage();\n        errorPageDefault.setLocation(\"/report/default\");\n        ctx.addErrorPage(errorPageDefault);\n\n        tomcat.start();\n\n        doTestErrorPageHandling(500, \"/500\");\n        doTestErrorPageHandling(501, \"/default\");\n    }"
            ],
            "java\\javax\\el\\ValueExpression.java": [
                "    public abstract boolean isReadOnly(ELContext context) throws NullPointerException, PropertyNotFoundException, ELException;"
            ],
            "java\\org\\apache\\catalina\\ant\\JMXGetTask.java": [
                "    public void execute() throws BuildException {\n        super.execute();\n        if (bean == null || attribute == null) {\n            throw new BuildException\n                (\"Must specify 'bean' and 'attribute' attributes\");\n        }\n        log(\"Getting attribute \" + attribute +\n                \" in bean \" + bean );\n        try {\n            execute(\"/jmxproxy/?get=\" + URLEncoder.encode(bean, getCharset()) \n                    + \"&att=\" + URLEncoder.encode(attribute, getCharset()));\n        } catch (UnsupportedEncodingException e) {\n            throw new BuildException\n                (\"Invalid 'charset' attribute: \" + getCharset());\n        }\n    }"
            ],
            "java\\org\\apache\\catalina\\ant\\JMXSetTask.java": [
                "    public void execute() throws BuildException {\n        super.execute();\n        if (bean == null || attribute == null || value == null) {\n            throw new BuildException\n                (\"Must specify 'bean', 'attribute' and 'value' attributes\");\n        }\n        log(\"Setting attribute \" + attribute +\n                            \" in bean \" + bean +\n                            \" to \" + value); \n        try {\n            execute(\"/jmxproxy/?set=\" + URLEncoder.encode(bean, getCharset()) \n                    + \"&att=\" + URLEncoder.encode(attribute, getCharset()) \n                    + \"&val=\" + URLEncoder.encode(value, getCharset()));\n        } catch (UnsupportedEncodingException e) {\n            throw new BuildException\n                (\"Invalid 'charset' attribute: \" + getCharset());\n        }\n    }"
            ],
            "java\\org\\apache\\jasper\\tagplugins\\jstl\\core\\Remove.java": [
                "    public void doTag(TagPluginContext ctxt) {\n        \n        //scope flag\n        boolean hasScope = ctxt.isAttributeSpecified(\"scope\");\n        \n        //the value of the \"var\"\n        String strVar = ctxt.getConstantAttribute(\"var\");\n        \n        //remove attribute from certain scope.\n        //default scope is \"page\".\n        if(hasScope){\n            int iScope = Util.getScope(ctxt.getConstantAttribute(\"scope\"));\n            ctxt.generateJavaSource(\"pageContext.removeAttribute(\\\"\" + strVar + \"\\\",\" + iScope + \");\");\n        }else{\n            ctxt.generateJavaSource(\"pageContext.removeAttribute(\\\"\" + strVar + \"\\\");\");\n        }\n    }"
            ],
            "java\\org\\apache\\catalina\\ant\\ResourcesTask.java": [
                "    public void execute() throws BuildException {\n\n        super.execute();\n        if (type != null) {\n            try {\n                execute(\"/resources?type=\" +\n                        URLEncoder.encode(type, getCharset()));\n            } catch (UnsupportedEncodingException e) {\n                throw new BuildException\n                    (\"Invalid 'charset' attribute: \" + getCharset());\n            }\n        } else {\n            execute(\"/resources\");\n        }\n\n    }"
            ],
            "test\\org\\apache\\catalina\\tribes\\group\\interceptors\\TestDomainFilterInterceptor.java": [
                "    public void testMemberArrival() throws Exception {\n        //purpose of this test is to make sure that we have received all the members\n        //that we can expect before the start method returns\n        Thread[] threads = new Thread[channels.length];\n        for (int i=0; i<channels.length; i++ ) {\n            final Channel channel = channels[i];\n            Thread t = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        channel.start(Channel.DEFAULT);\n                    }catch ( Exception x ) {\n                        throw new RuntimeException(x);\n                    }\n                }\n            };\n            threads[i] = t;\n        }\n        for (int i=0; i<threads.length; i++ ) threads[i].start();\n        for (int i=0; i<threads.length; i++ ) threads[i].join();\n        System.out.println(\"All channels started.\");\n        for (int i=listeners.length-1; i>=0; i-- ) assertEquals(\"Checking member arrival length\",0,listeners[i].members.size());\n    }\n\n    public void tearDown() throws Exception {\n\n        for (int i = 0; i < channels.length; i++) {\n            try {\n                channels[i].stop(Channel.DEFAULT);\n            } catch (Exception ignore) {\n                // Ignore\n            }\n        }\n    }"
            ],
            "java\\org\\apache\\tomcat\\util\\modeler\\OperationInfo.java": [
                "    MBeanOperationInfo createOperationInfo() {\n\n        // Return our cached information (if any)\n        if (info == null) {\n            // Create and return a new information object\n            int impact = MBeanOperationInfo.UNKNOWN;\n            if (\"ACTION\".equals(getImpact()))\n                impact = MBeanOperationInfo.ACTION;\n            else if (\"ACTION_INFO\".equals(getImpact()))\n                impact = MBeanOperationInfo.ACTION_INFO;\n            else if (\"INFO\".equals(getImpact()))\n                impact = MBeanOperationInfo.INFO;\n    \n            info = new MBeanOperationInfo(getName(), getDescription(), \n                                          getMBeanParameterInfo(),\n                                          getReturnType(), impact);\n        }\n        return (MBeanOperationInfo)info;\n    }"
            ],
            "test\\org\\apache\\catalina\\tribes\\group\\TestGroupChannelMemberArrival.java": [
                "    public void testMemberArrival() throws Exception {\n        //purpose of this test is to make sure that we have received all the members\n        //that we can expect before the start method returns\n        Thread[] threads = new Thread[channels.length];\n        for (int i=0; i<channels.length; i++ ) {\n            final Channel channel = channels[i];\n            Thread t = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        channel.start(Channel.DEFAULT);\n                    }catch ( Exception x ) {\n                        throw new RuntimeException(x);\n                    }\n                }\n            };\n            threads[i] = t;\n        }\n        for (int i = 0; i < threads.length; i++) {\n            threads[i].start();\n        }\n        for (int i = 0; i < threads.length; i++) {\n            threads[i].join();\n        }\n        Thread.sleep(5000);\n        System.out.println(System.currentTimeMillis()\n                + \" All channels started.\");\n        for (int i = listeners.length - 1; i >= 0; i--) {\n            TestMbrListener listener = listeners[i];\n            synchronized (listener.members) {\n                assertEquals(\"Checking member arrival length (\" + listener.name\n                        + \")\", channels.length - 1, listener.members.size());\n            }\n        }\n        System.out.println(System.currentTimeMillis()\n                + \" Members arrival counts checked.\");\n    }",
                "    public void tearDown() throws Exception {\n\n        for (int i = 0; i < channels.length; i++) {\n            try {\n                channels[i].stop(Channel.DEFAULT);\n            } catch (Exception ignore) {\n                // Ignore\n            }\n        }\n    }"
            ],
            "test\\org\\apache\\catalina\\tribes\\group\\TestGroupChannelStartStop.java": [
                "    public void tearDown() throws Exception {\n        try {channel.stop(Channel.DEFAULT);}catch (Exception ignore){ /* Ignore */ }\n    }\n\n    public void testDoubleFullStart() throws Exception {\n        int count = 0;\n        try {\n            channel.start(Channel.DEFAULT);\n            count++;\n        } catch ( Exception x){x.printStackTrace();}\n        try {\n            channel.start(Channel.DEFAULT);\n            count++;\n        } catch ( Exception x){x.printStackTrace();}\n        assertEquals(count,2);\n        channel.stop(Channel.DEFAULT);\n    }\n\n    public void testScrap() throws Exception {\n        System.out.println(channel.getChannelReceiver().getClass());\n        ((ReceiverBase)channel.getChannelReceiver()).setMaxThreads(1);\n    }",
                "    public void testDoublePartialStart() throws Exception {\n        //try to double start the RX\n        int count = 0;\n        try {\n            channel.start(Channel.SND_RX_SEQ);\n            channel.start(Channel.MBR_RX_SEQ);\n            count++;\n        } catch ( Exception x){x.printStackTrace();}\n        try {\n            channel.start(Channel.MBR_RX_SEQ);\n            count++;\n        } catch ( Exception x){/*expected*/}\n        assertEquals(count,1);\n        channel.stop(Channel.DEFAULT);\n        //double the membership sender\n        count = 0;\n        try {\n            channel.start(Channel.SND_RX_SEQ);\n            channel.start(Channel.MBR_TX_SEQ);\n            count++;\n        } catch ( Exception x){x.printStackTrace();}\n        try {\n            channel.start(Channel.MBR_TX_SEQ);\n            count++;\n        } catch ( Exception x){/*expected*/}\n        assertEquals(count,1);\n        channel.stop(Channel.DEFAULT);\n\n        count = 0;\n        try {\n            channel.start(Channel.SND_RX_SEQ);\n            count++;\n        } catch ( Exception x){x.printStackTrace();}\n        try {\n            channel.start(Channel.SND_RX_SEQ);\n            count++;\n        } catch ( Exception x){/*expected*/}\n        assertEquals(count,1);\n        channel.stop(Channel.DEFAULT);\n\n        count = 0;\n        try {\n            channel.start(Channel.SND_TX_SEQ);\n            count++;\n        } catch ( Exception x){x.printStackTrace();}\n        try {\n            channel.start(Channel.SND_TX_SEQ);\n            count++;\n        } catch ( Exception x){/*expected*/}\n        assertEquals(count,1);\n        channel.stop(Channel.DEFAULT);\n    }",
                "    public void testFalseOption() throws Exception {\n        int flag = 0xFFF0;//should get ignored by the underlying components\n        int count = 0;\n        try {\n            channel.start(flag);\n            count++;\n        } catch ( Exception x){x.printStackTrace();}\n        try {\n            channel.start(flag);\n            count++;\n        } catch ( Exception x){/*expected*/}\n        assertEquals(count,2);\n        channel.stop(Channel.DEFAULT);\n    }\n\n    public void testUdpReceiverStart() throws Exception {\n        ReceiverBase rb = (ReceiverBase)channel.getChannelReceiver();\n        rb.setUdpPort(udpPort);\n        channel.start(Channel.DEFAULT);\n        Thread.sleep(1000);\n        channel.stop(Channel.DEFAULT);\n    }"
            ],
            "java\\org\\apache\\jasper\\compiler\\ELParser.java": [
                "    private ELNode.Nodes parseEL() {\n\n        StringBuilder buf = new StringBuilder();\n        ELexpr = new ELNode.Nodes();\n        curToken = null;\n        prevToken = null;\n        while (hasNext()) {\n            curToken = nextToken();\n            if (curToken instanceof Char) {\n                if (curToken.toChar() == '}') {\n                    break;\n                }\n                buf.append(curToken.toString());\n            } else {\n                // Output whatever is in buffer\n                if (buf.length() > 0) {\n                    ELexpr.add(new ELNode.ELText(buf.toString()));\n                    buf.setLength(0);\n                }\n                if (!parseFunction()) {\n                    ELexpr.add(new ELNode.ELText(curToken.toString()));\n                }\n            }\n        }",
                "    private boolean parseFunction() {\n        if (!(curToken instanceof Id) || isELReserved(curToken.toTrimmedString()) ||\n                prevToken instanceof Char && prevToken.toChar() == '.') {\n            return false;\n        }\n        String s1 = null; // Function prefix\n        String s2 = curToken.toTrimmedString(); // Function name\n        int start = index - curToken.toString().length();\n        Token original = curToken;\n        if (hasNext()) {\n            int mark = getIndex() - whiteSpace.length();\n            curToken = nextToken();\n            if (curToken.toChar() == ':') {\n                if (hasNext()) {\n                    Token t2 = nextToken();\n                    if (t2 instanceof Id) {\n                        s1 = s2;\n                        s2 = t2.toTrimmedString();\n                        if (hasNext()) {\n                            curToken = nextToken();\n                        }\n                    }\n                }\n            }\n            if (curToken.toChar() == '(') {\n                ELexpr.add(new ELNode.Function(s1, s2, expression.substring(start, index - 1)));\n                return true;\n            }\n            curToken = original;\n            setIndex(mark);\n        }\n        return false;\n    }",
                "    private boolean isELReserved(String id) {\n        int i = 0;\n        int j = reservedWords.length;\n        while (i < j) {\n            int k = (i + j) / 2;\n            int result = reservedWords[k].compareTo(id);\n            if (result == 0) {\n                return true;\n            }\n            if (result < 0) {\n                i = k + 1;\n            } else {\n                j = k;\n            }\n        }\n        return false;\n    }",
                "    private String skipUntilEL() {\n        char prev = 0;\n        StringBuilder buf = new StringBuilder();\n        while (hasNextChar()) {\n            char ch = nextChar();\n            if (prev == '\\\\') {\n                prev = 0;\n                if (ch == '\\\\') {\n                    buf.append('\\\\');\n                    prev = '\\\\';\n                } else if (ch == '$'\n                        || (!isDeferredSyntaxAllowedAsLiteral && ch == '#')) {\n                    buf.append(ch);\n                }\n                // else error!\n            } else if (prev == '$'\n                    || (!isDeferredSyntaxAllowedAsLiteral && prev == '#')) {\n                if (ch == '{') {\n                    this.type = prev;\n                    prev = 0;\n                    break;\n                }\n                buf.append(prev);\n                prev = 0;\n            }\n            if (ch == '\\\\' || ch == '$'\n                    || (!isDeferredSyntaxAllowedAsLiteral && ch == '#')) {\n                prev = ch;\n            } else {\n                buf.append(ch);\n            }\n        }\n        if (prev != 0) {\n            buf.append(prev);\n        }\n        return buf.toString();\n    }\n\n    /*\n     * @return true if there is something left in EL expression buffer other\n     * than white spaces.\n     */\n    private boolean hasNext() {\n        skipSpaces();\n        return hasNextChar();\n    }\n\n    private String getAndResetWhiteSpace() {\n        String result = whiteSpace;\n        whiteSpace = \"\";\n        return result;\n    }\n\n    /*\n     * Implementation note: This method assumes that it is always preceded by a\n     * call to hasNext() in order for whitespace handling to be correct.\n     *\n     * @return The next token in the EL expression buffer.\n     */\n    private Token nextToken() {\n        prevToken = curToken;\n        if (hasNextChar()) {\n            char ch = nextChar();\n            if (Character.isJavaIdentifierStart(ch)) {\n                int start = index - 1;\n                while (index < expression.length() &&\n                        Character.isJavaIdentifierPart(\n                                ch = expression.charAt(index))) {\n                    nextChar();\n                }\n                return new Id(getAndResetWhiteSpace(), expression.substring(start, index));\n            }\n\n            if (ch == '\\'' || ch == '\"') {\n                return parseQuotedChars(ch);\n            } else {\n                // For now...\n                return new Char(getAndResetWhiteSpace(), ch);\n            }\n        }\n        return null;\n    }\n\n    /*\n     * Parse a string in single or double quotes, allowing for escape sequences\n     * '\\\\', and ('\\\"', or \"\\'\")\n     */\n    private Token parseQuotedChars(char quote) {\n        StringBuilder buf = new StringBuilder();\n        buf.append(quote);\n        while (hasNextChar()) {\n            char ch = nextChar();\n            if (ch == '\\\\') {\n                ch = nextChar();\n                if (ch == '\\\\' || ch == quote) {\n                    buf.append(ch);\n                }\n                // else error!\n            } else if (ch == quote) {\n                buf.append(ch);\n                break;\n            } else {\n                buf.append(ch);\n            }\n        }\n        return new QuotedString(getAndResetWhiteSpace(), buf.toString());\n    }\n\n    /*\n     * A collection of low level parse methods dealing with character in the EL\n     * expression buffer.\n     */\n\n    private void skipSpaces() {\n        int start = index;\n        while (hasNextChar()) {\n            char c = expression.charAt(index);\n            if (c > ' ')\n                break;\n            index++;\n        }\n        whiteSpace = expression.substring(start, index);\n    }\n\n    private boolean hasNextChar() {\n        return index < expression.length();\n    }\n\n    private char nextChar() {\n        if (index >= expression.length()) {\n            return (char) -1;\n        }\n        return expression.charAt(index++);\n    }\n\n    private int getIndex() {\n        return index;\n    }\n\n    private void setIndex(int i) {\n        index = i;\n    }\n\n    /*\n     * Represents a token in EL expression string\n     */\n    private static class Token {\n\n        protected final String whiteSpace;\n\n        Token(String whiteSpace) {\n            this.whiteSpace = whiteSpace;\n        }\n\n        char toChar() {\n            return 0;\n        }\n\n        @Override\n        public String toString() {\n            return whiteSpace;\n        }\n\n        String toTrimmedString() {\n            return \"\";\n        }\n\n        String getWhiteSpace() {\n            return whiteSpace;\n        }\n    }\n\n    /*\n     * Represents an ID token in EL\n     */\n    private static class Id extends Token {\n        String id;\n\n        Id(String whiteSpace, String id) {\n            super(whiteSpace);\n            this.id = id;\n        }\n\n        @Override\n        public String toString() {\n            return whiteSpace + id;\n        }\n\n        @Override\n        String toTrimmedString() {\n            return id;\n        }\n    }\n\n    /*\n     * Represents a character token in EL\n     */\n    private static class Char extends Token {\n\n        private char ch;\n\n        Char(String whiteSpace, char ch) {\n            super(whiteSpace);\n            this.ch = ch;\n        }\n\n        @Override\n        char toChar() {\n            return ch;\n        }\n\n        @Override\n        public String toString() {\n            return whiteSpace + ch;\n        }\n\n        @Override\n        String toTrimmedString() {\n            return \"\" + ch;\n        }\n    }\n\n    /*\n     * Represents a quoted (single or double) string token in EL\n     */\n    private static class QuotedString extends Token {\n\n        private String value;\n\n        QuotedString(String whiteSpace, String v) {\n            super(whiteSpace);\n            this.value = v;\n        }\n\n        @Override\n        public String toString() {\n            return whiteSpace + value;\n        }\n\n        @Override\n        String toTrimmedString() {\n            return value;\n        }\n    }\n\n    public char getType() {\n        return type;\n    }\n\n\n    protected static class TextBuilder extends ELNode.Visitor {\n\n        protected StringBuilder output = new StringBuilder();\n\n        public String getText() {\n            return output.toString();\n        }\n\n        @Override\n        public void visit(Root n) throws JasperException {\n            output.append(n.getType());\n            output.append('{');\n            n.getExpression().visit(this);\n            output.append('}');\n        }\n\n        @Override\n        public void visit(Function n) throws JasperException {\n            output.append(n.getOriginalText());\n            output.append('(');\n        }\n\n        @Override\n        public void visit(Text n) throws JasperException {\n            output.append(n.getText());\n        }\n\n        @Override\n        public void visit(ELText n) throws JasperException {\n            output.append(n.getText());\n        }\n    }\n}",
                "    private Token nextToken() {\n        prevToken = curToken;\n        if (hasNextChar()) {\n            char ch = nextChar();\n            if (Character.isJavaIdentifierStart(ch)) {\n                int start = index - 1;\n                while (index < expression.length() &&\n                        Character.isJavaIdentifierPart(\n                                ch = expression.charAt(index))) {\n                    nextChar();\n                }\n                return new Id(getAndResetWhiteSpace(), expression.substring(start, index));\n            }\n\n            if (ch == '\\'' || ch == '\"') {\n                return parseQuotedChars(ch);\n            } else {\n                // For now...\n                return new Char(getAndResetWhiteSpace(), ch);\n            }\n        }\n        return null;\n    }",
                "    private Token parseQuotedChars(char quote) {\n        StringBuilder buf = new StringBuilder();\n        buf.append(quote);\n        while (hasNextChar()) {\n            char ch = nextChar();\n            if (ch == '\\\\') {\n                ch = nextChar();\n                if (ch == '\\\\' || ch == quote) {\n                    buf.append(ch);\n                }\n                // else error!\n            } else if (ch == quote) {\n                buf.append(ch);\n                break;\n            } else {\n                buf.append(ch);\n            }\n        }\n        return new QuotedString(getAndResetWhiteSpace(), buf.toString());\n    }"
            ],
            "java\\org\\apache\\jasper\\tagplugins\\jstl\\core\\Catch.java": [
                "    public void doTag(TagPluginContext ctxt) {\n        \n        //flag for the existence of the var attribute\n        boolean hasVar = ctxt.isAttributeSpecified(\"var\");\n        \n        //temp name for exception and caught\n        String exceptionName = ctxt.getTemporaryVariableName();\n        String caughtName = ctxt.getTemporaryVariableName();\n        \n        //main part to generate code\n        ctxt.generateJavaSource(\"boolean \" + caughtName + \" = false;\");\n        ctxt.generateJavaSource(\"try{\");\n        ctxt.generateBody();\n        ctxt.generateJavaSource(\"}\");\n        \n        //do catch\n        ctxt.generateJavaSource(\"catch(Throwable \" + exceptionName + \"){\");\n        \n        //if the var specified, the exception object should \n        //be set to the attribute \"var\" defines in page scope \n        if(hasVar){\n            String strVar = ctxt.getConstantAttribute(\"var\");\n            ctxt.generateJavaSource(\"    pageContext.setAttribute(\\\"\" + strVar + \"\\\", \" \n                    + exceptionName + \", PageContext.PAGE_SCOPE);\");\n        }\n        \n        //whenever there's exception caught, \n        //the flag caught should be set true;\n        ctxt.generateJavaSource(\"    \" + caughtName + \" = true;\");\n        ctxt.generateJavaSource(\"}\");\n        \n        //do finally\n        ctxt.generateJavaSource(\"finally{\");\n        \n        //if var specified, the attribute it defines \n        //in page scope should be removed\n        if(hasVar){\n            String strVar = ctxt.getConstantAttribute(\"var\");\n            ctxt.generateJavaSource(\"    if(!\" + caughtName + \"){\");\n            ctxt.generateJavaSource(\"        pageContext.removeAttribute(\\\"\" + strVar + \"\\\", PageContext.PAGE_SCOPE);\");\n            ctxt.generateJavaSource(\"    }\");\n        }\n        \n        ctxt.generateJavaSource(\"}\");\n    }"
            ],
            "java\\org\\apache\\catalina\\ant\\JMXQueryTask.java": [
                "    public void execute() throws BuildException {\n        super.execute();\n        String queryString;\n        if (query == null) {\n            queryString = \"\";\n        } else {\n            try {\n                queryString = \"?qry=\" + URLEncoder.encode(query, getCharset());\n            } catch (UnsupportedEncodingException e) {\n                throw new BuildException\n                    (\"Invalid 'charset' attribute: \" + getCharset());\n            }\n        }\n        log(\"Query string is \" + queryString); \n        execute (\"/jmxproxy/\" + queryString);\n    }"
            ],
            "test\\org\\apache\\catalina\\ha\\session\\TestSerializablePrincipal.java": [
                "    public void testWriteReadPrincipal() {\n        // Get a temporary file to use for the serialization test\n        File file = null;\n        try {\n            file = File.createTempFile(\"ser\", null);\n            file.deleteOnExit();\n        } catch (IOException e) {\n            e.printStackTrace();\n            fail(\"ioe creating temporary file\");\n        }\n\n        // Create the Principal to serialize\n        List<String> roles = new ArrayList<String>();\n        roles.add(\"RoleA\");\n        roles.add(\"RoleB\");\n        TesterPrincipal tpOriginal = new TesterPrincipal(\"inner\");\n        GenericPrincipal gpOriginal =\n            new GenericPrincipal(\"usr\", \"pwd\", roles, tpOriginal);\n\n        // Do the serialization\n        try {\n            FileOutputStream fos = new FileOutputStream(file);\n            ObjectOutputStream oos = new ObjectOutputStream(fos);\n            SerializablePrincipal.writePrincipal(gpOriginal, oos);\n            oos.close();\n            fos.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            fail(\"fnfe creating object output stream\");\n        } catch (IOException e) {\n            e.printStackTrace();\n            fail(\"ioe serializing principal\");\n        }\n\n        // De-serialize the Principal\n        GenericPrincipal gpNew = null;\n        try {\n            FileInputStream fis = new FileInputStream(file);\n            ObjectInputStream ois = new ObjectInputStream(fis);\n            gpNew = SerializablePrincipal.readPrincipal(ois);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            fail(\"fnfe reading object output stream\");\n        } catch (IOException e) {\n            e.printStackTrace();\n            fail(\"ioe de-serializing principal\");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            fail(\"cnfe de-serializing principal\");\n        }\n\n        // Now test how similar original and de-serialized versions are\n        assertEquals(\"User names different\", gpOriginal.getName(),\n                gpNew.getName());\n        assertEquals(\"Passwords different\", gpOriginal.getPassword(),\n                gpNew.getPassword());\n        assertEquals(\"Number of roles different\", gpOriginal.getRoles().length,\n                gpNew.getRoles().length);\n        for (int i = 0; i < gpOriginal.getRoles().length; i++) {\n            assertEquals(\"Role name index \" + i + \"different\",\n                    gpOriginal.getRoles()[i], gpNew.getRoles()[i]);\n        }\n        // These are the key tests for bug 43840\n        assertNotSame(\"Inner principal not present\", gpNew,\n                gpNew.getUserPrincipal());\n        assertEquals(\"Inner user names are different\", tpOriginal.getName(),\n                gpNew.getUserPrincipal().getName());\n    }"
            ],
            "test\\org\\apache\\tomcat\\util\\buf\\TestB2CConverter.java": [
                "    private void testMessages(int msgCount) throws Exception {\n        B2CConverter conv = new B2CConverter(\"UTF-16\");\n\n        ByteChunk bc = new ByteChunk();\n        CharChunk cc = new CharChunk(32);\n\n\n        for (int i = 0; i < msgCount; i++) {\n            bc.append(UTF16_MESSAGE, 0, UTF16_MESSAGE.length);\n            conv.convert(bc, cc, true);\n            Assert.assertEquals(\"ABC\", cc.toString());\n            bc.recycle();\n            cc.recycle();\n            conv.recycle();\n        }\n\n        System.out.println(cc);\n    }",
                "    public void testLeftoverSize() {\n        float maxLeftover = 0;\n        String charsetName = \"UNSET\";\n        for (Charset charset : Charset.availableCharsets().values()) {\n            float leftover;\n            if (charset.name().toLowerCase().startsWith(\"x-\")) {\n                // Non-standard charset that browsers won't be using\n                // Likely something used internally by the JRE\n                continue;\n            }\n            if (charset.name().equals(\"COMPOUND_TEXT\")) {\n                // Java for-internal-use-only charset\n                // See:\n                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6392670\n                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6381697\n                continue;\n            }\n            try {\n                leftover = charset.newEncoder().maxBytesPerChar();\n            } catch (UnsupportedOperationException uoe) {\n                // Skip it\n                continue;\n            }\n            if (leftover > maxLeftover) {\n                maxLeftover = leftover;\n                charsetName = charset.name();\n            }\n        }\n        Assert.assertTrue(\"Limit needs to be at least \" + maxLeftover +\n                \" (used in charset '\" + charsetName + \"')\",\n                maxLeftover <= B2CConverter.LEFTOVER_SIZE);\n    }",
                "    public void testBug54602a() throws Exception {\n        // Check invalid input is rejected straight away\n        B2CConverter conv = new B2CConverter(\"UTF-8\");\n        ByteChunk bc = new ByteChunk();\n        CharChunk cc = new CharChunk();\n\n        bc.append(UTF8_INVALID, 0, UTF8_INVALID.length);\n        cc.allocate(bc.getLength(), -1);\n\n        conv.convert(bc, cc, false);\n    }\n\n    public void testBug54602b() throws Exception {\n        // Check partial input is rejected\n        B2CConverter conv = new B2CConverter(\"UTF-8\");\n        ByteChunk bc = new ByteChunk();\n        CharChunk cc = new CharChunk();\n\n        bc.append(UTF8_PARTIAL, 0, UTF8_PARTIAL.length);\n        cc.allocate(bc.getLength(), -1);\n\n        conv.convert(bc, cc, true);\n    }",
                "    public void testBug54602c() throws Exception {\n        // Check partial input is rejected once it is known to be all available\n        B2CConverter conv = new B2CConverter(\"UTF-8\");\n        ByteChunk bc = new ByteChunk();\n        CharChunk cc = new CharChunk();\n\n        bc.append(UTF8_PARTIAL, 0, UTF8_PARTIAL.length);\n        cc.allocate(bc.getLength(), -1);\n\n        conv.convert(bc, cc, false);\n\n        Exception e = null;\n        try {\n            conv.convert(bc, cc, true);\n        } catch (MalformedInputException mie) {\n            e = mie;\n        }\n        Assert.assertNotNull(e);\n    }"
            ],
            "modules\\jdbc-pool\\src\\test\\java\\org\\apache\\tomcat\\jdbc\\test\\TestSizePreservation.java": [
                "    private void initSimplePoolProperties() {\n        PoolConfiguration p = new DefaultProperties();\n        ds = new org.apache.tomcat.jdbc.pool.DataSource();\n        ds.setPoolProperties(p);\n\n        ds.getPoolProperties().setDriverClassName(Driver.class.getName());\n        ds.getPoolProperties().setUrl(Driver.url);\n        ds.getPoolProperties().setFairQueue(true);\n        ds.getPoolProperties().setJmxEnabled(false);\n        ds.getPoolProperties().setTestWhileIdle(true);\n        ds.getPoolProperties().setTestOnBorrow(false);\n        ds.getPoolProperties().setTestOnReturn(false);\n        ds.getPoolProperties().setValidationInterval(30000);\n        ds.getPoolProperties().setTimeBetweenEvictionRunsMillis(30000);\n        ds.getPoolProperties().setInitialSize(100);\n        ds.getPoolProperties().setMaxActive(100);\n        ds.getPoolProperties().setMinIdle(0);\n        ds.getPoolProperties().setMaxIdle(0);\n        ds.getPoolProperties().setMaxWait(10000);\n        ds.getPoolProperties().setRemoveAbandonedTimeout(10);\n        ds.getPoolProperties().setMinEvictableIdleTimeMillis(10000);\n        ds.getPoolProperties().setLogAbandoned(false);\n        ds.getPoolProperties().setRemoveAbandoned(false);\n        ds.getPoolProperties().setUseLock(true);\n    }\n\n    public void testSimple() throws Exception {\n        initSimplePoolProperties();\n        common();\n        ds.close(true);\n        Driver.reset();\n    }\n\n    public void testEvicting() throws Exception {\n        initEvictingPool();\n        common();\n        ds.close(true);\n        Driver.reset();\n    }",
                "    private void common() throws Exception {\n        ds.getConnection().close();\n        final int iterations = 1000;\n        final AtomicInteger loopcount = new AtomicInteger(0);\n        final Runnable run = new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    while (loopcount.incrementAndGet() < iterations) {\n                        Connection c = ds.getConnection();\n                        Thread.sleep(1000);\n                        c.close();\n                    }\n                } catch (Exception x) {\n                    x.printStackTrace();\n                }\n            }\n        };\n        Thread[] threads = new Thread[200];\n        for (int i = 0; i < threads.length; i++) {\n            threads[i] = new Thread(run);\n        }\n        for (int i = 0; i < threads.length; i++) {\n            threads[i].start();\n        }\n        try {\n            while (loopcount.get() < iterations) {\n                Thread.sleep(250);\n            }\n        } catch (Exception x) {\n            loopcount.set(iterations); // stops the test\n            x.printStackTrace();\n        }\n        for (int i = 0; i < threads.length; i++) {\n            threads[i].join();\n        }\n        System.out.println(\"Pool size:\"+ds.getPool().getSize());\n        Assert.assertTrue(\"Size validity check: \", ds.getPool().getSize() >= 0);\n    }"
            ],
            "test\\org\\apache\\el\\lang\\TestELSupport.java": [
                "    public void testCoerceEnumAToEnumA() {\n        Object output = null;\n        try {\n            output = ELSupport.coerceToEnum(TestEnumA.VALA1, TestEnumA.class);\n        } finally {\n            assertEquals(TestEnumA.VALA1, output);\n        }\n    }\n\n    public void testCoerceEnumAToEnumB() {\n        Object output = null;\n        try {\n            output = ELSupport.coerceToEnum(TestEnumA.VALA1, TestEnumB.class);\n        } catch (ELException ele) {\n            // Ignore\n        }\n        assertNull(output);\n    }\n\n    public void testCoerceEnumAToEnumC() {\n        Object output = null;\n        try {\n            output = ELSupport.coerceToEnum(TestEnumA.VALA1, TestEnumC.class);\n        } catch (ELException ele) {\n            // Ignore\n        }\n        assertNull(output);\n    }"
            ],
            "java\\org\\apache\\jasper\\util\\UniqueAttributesImpl.java": [
                "    private void handleDuplicate(String qName, String value) {\n        if (pageDirective) {\n            if (IMPORT.equalsIgnoreCase(qName)) {\n                // Always merge imports\n                int i = super.getIndex(IMPORT);\n                String v = super.getValue(i);\n                super.setValue(i, v + \",\" + value);\n                return;\n            } else if (PAGE_ENCODING.equalsIgnoreCase(qName)) {\n                // Page encoding can only occur once per file so a second\n                // attribute - even one with a duplicate value - is an error\n            } else {\n                // Other attributes can be repeated if and only if the values\n                // are identical\n                String v = super.getValue(qName);\n                if (v.equals(value)) {\n                    return;\n                }\n            }\n        }\n\n        // Ordinary tag attributes can't be repeated, even with identical values\n        throw new IllegalArgumentException(\n                    Localizer.getMessage(\"jsp.error.duplicateqname\", qName));\n    }"
            ]
        }
    },
    "55943": {
        "summary": "Bug 55943 Provide a way prevent looking at the System classloader before the webapp classloaders",
        "code_segments": {
            "java\\org\\apache\\catalina\\startup\\WebappServiceLoader.java": [
                "    public List<T> load(Class<T> serviceType) throws IOException {\n        String configFile = SERVICES + serviceType.getName();\n\n        LinkedHashSet<String> applicationServicesFound = new LinkedHashSet<String>();\n        LinkedHashSet<String> containerServicesFound = new LinkedHashSet<String>();\n\n        ClassLoader loader = context.getClassLoader();\n\n        // if the ServletContext has ORDERED_LIBS, then use that to specify the\n        // set of JARs from WEB-INF/lib that should be used for loading services\n        @SuppressWarnings(\"unchecked\")\n        List<String> orderedLibs =\n                (List<String>) context.getAttribute(ServletContext.ORDERED_LIBS);\n        if (orderedLibs != null) {\n            // handle ordered libs directly, ...\n            for (String lib : orderedLibs) {\n                URL jarUrl = context.getResource(LIB + lib);\n                if (jarUrl == null) {\n                    // should not happen, just ignore\n                    continue;\n                }\n\n                String base = jarUrl.toExternalForm();\n                URL url;\n                if (base.endsWith(\"/\")) {\n                    url = new URL(base + configFile);\n                } else {\n                    url = new URL(\"jar:\" + base + \"!/\" + configFile);\n                }\n                try {\n                    parseConfigFile(applicationServicesFound, url);\n                } catch (FileNotFoundException e) {\n                    // no provider file found, this is OK\n                }\n            }\n\n            // and the parent ClassLoader for all others\n            loader = loader.getParent();\n        }\n\n        Enumeration<URL> resources;\n        if (loader == null) {\n            resources = ClassLoader.getSystemResources(configFile);\n        } else {\n            resources = loader.getResources(configFile);\n        }\n        while (resources.hasMoreElements()) {\n            parseConfigFile(containerServicesFound, resources.nextElement());\n        }\n\n        // Filter the discovered container SCIs if required\n        if (containerSciFilterPattern != null) {\n            Iterator<String> iter = containerServicesFound.iterator();\n            while (iter.hasNext()) {\n                if (containerSciFilterPattern.matcher(iter.next()).find()) {\n                    iter.remove();\n                }\n            }\n        }\n\n        // Add the application services after the container services to ensure\n        // that the container services are loaded first\n        containerServicesFound.addAll(applicationServicesFound);\n\n        // load the discovered services\n        if (containerServicesFound.isEmpty()) {\n            return Collections.emptyList();\n        }\n        return loadServices(serviceType, containerServicesFound);\n    }"
            ],
            "java\\org\\apache\\catalina\\loader\\JdbcLeakPrevention.java": [
                "    public List<String> clearJdbcDriverRegistrations() throws SQLException {\n        List<String> driverNames = new ArrayList<String>();\n\n        /*\n         * DriverManager.getDrivers() has a nasty side-effect of registering\n         * drivers that are visible to this class loader but haven't yet been\n         * loaded. Therefore, the first call to this method a) gets the list\n         * of originally loaded drivers and b) triggers the unwanted\n         * side-effect. The second call gets the complete list of drivers\n         * ensuring that both original drivers and any loaded as a result of the\n         * side-effects are all de-registered.\n         */\n        HashSet<Driver> originalDrivers = new HashSet<Driver>();\n        Enumeration<Driver> drivers = DriverManager.getDrivers();\n        while (drivers.hasMoreElements()) {\n            originalDrivers.add(drivers.nextElement());\n        }\n        drivers = DriverManager.getDrivers();\n        while (drivers.hasMoreElements()) {\n            Driver driver = drivers.nextElement();\n            // Only unload the drivers this web app loaded\n            if (driver.getClass().getClassLoader() !=\n                this.getClass().getClassLoader()) {\n                continue;\n            }\n            // Only report drivers that were originally registered. Skip any\n            // that were registered as a side-effect of this code.\n            if (originalDrivers.contains(driver)) {\n                driverNames.add(driver.getClass().getCanonicalName());\n            }\n            DriverManager.deregisterDriver(driver);\n        }\n        return driverNames;\n    }"
            ],
            "test\\org\\apache\\catalina\\startup\\TestWebappServiceLoader.java": [
                "    public void testWebapp() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n        File appDir = new File(\"test/webapp-3.0-fragments-empty-absolute-ordering\");\n        StandardContext ctxt = (StandardContext) tomcat.addContext(null, \"/test\", appDir.getAbsolutePath());\n        ctxt.addLifecycleListener(new ContextConfig());\n        tomcat.start();\n\n        WebappServiceLoader<ServletContainerInitializer> loader =\n                new WebappServiceLoader<ServletContainerInitializer>(ctxt.getServletContext(), null);\n        @SuppressWarnings(\"unused\")\n        Collection<ServletContainerInitializer> initializers = loader.load(ServletContainerInitializer.class);\n    }"
            ],
            "java\\org\\apache\\catalina\\core\\JreMemoryLeakPreventionListener.java": [
                "    public void lifecycleEvent(LifecycleEvent event) {\n        // Initialise these classes when Tomcat starts\n        if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {\n\n            ClassLoader loader = Thread.currentThread().getContextClassLoader();\n\n            try\n            {\n                // Use the system classloader as the victim for all this\n                // ClassLoader pinning we're about to do.\n                Thread.currentThread().setContextClassLoader(\n                        ClassLoader.getSystemClassLoader());\n\n                /*\n                 * First call to this loads all drivers in the current class\n                 * loader\n                 */\n                if (driverManagerProtection) {\n                    DriverManager.getDrivers();\n                }\n\n                /*\n                 * Several components end up calling:\n                 * sun.awt.AppContext.getAppContext()\n                 * \n                 * Those libraries / components known to trigger memory leaks\n                 * due to eventual calls to getAppContext() are:\n                 * - Google Web Toolkit via its use of javax.imageio\n                 * - Tomcat via its use of java.beans.Introspector.flushCaches()\n                 *   in 1.6.0_15 to 1.7.0_01. From 1.7.0_02 onwards use of\n                 *   AppContext by Introspector.flushCaches() was replaced with\n                 *   ThreadGroupContext\n                 * - others TBD\n                 *\n                 * From 1.7.0_25 onwards, a call to\n                 * sun.awt.AppContext.getAppContext() results in a thread being\n                 * started named AWT-AppKit that requires a graphic environment\n                 * to be available.\n                 */\n                \n                // Trigger a call to sun.awt.AppContext.getAppContext(). This\n                // will pin the system class loader in memory but that shouldn't\n                // be an issue.\n                if (appContextProtection) {\n                    ImageIO.getCacheDirectory();\n                }\n\n                // Trigger the creation of the AWT (AWT-Windows, AWT-XAWT,\n                // etc.) thread\n                if (awtThreadProtection) {\n                  java.awt.Toolkit.getDefaultToolkit();\n                }\n\n                // Trigger the creation of the \"Java2D Disposer\" thread.\n                // See https://issues.apache.org/bugzilla/show_bug.cgi?id=51687\n                if(java2dDisposerProtection) {\n                    try {\n                        Class.forName(\"sun.java2d.Disposer\");\n                    }\n                    catch (ClassNotFoundException cnfe) {\n                        // Ignore this case: we must be running on a\n                        // non-Sun-based JRE.\n                    }\n                }\n\n                /*\n                 * Several components end up calling\n                 * sun.misc.GC.requestLatency(long) which creates a daemon\n                 * thread without setting the TCCL.\n                 * \n                 * Those libraries / components known to trigger memory leaks\n                 * due to eventual calls to requestLatency(long) are:\n                 * - javax.management.remote.rmi.RMIConnectorServer.start()\n                 *\n                 * Note: Long.MAX_VALUE is a special case that causes the thread\n                 *       to terminate\n                 *\n                 */\n                if (gcDaemonProtection) {\n                    try {\n                        Class<?> clazz = Class.forName(\"sun.misc.GC\");\n                        Method method = clazz.getDeclaredMethod(\n                                \"requestLatency\",\n                                new Class[] {long.class});\n                        method.invoke(null, Long.valueOf(Long.MAX_VALUE - 1));\n                    } catch (ClassNotFoundException e) {\n                        if (Globals.IS_ORACLE_JVM) {\n                            log.error(sm.getString(\n                                    \"jreLeakListener.gcDaemonFail\"), e);\n                        } else {\n                            log.debug(sm.getString(\n                                    \"jreLeakListener.gcDaemonFail\"), e);\n                        }\n                    } catch (SecurityException e) {\n                        log.error(sm.getString(\"jreLeakListener.gcDaemonFail\"),\n                                e);\n                    } catch (NoSuchMethodException e) {\n                        log.error(sm.getString(\"jreLeakListener.gcDaemonFail\"),\n                                e);\n                    } catch (IllegalArgumentException e) {\n                        log.error(sm.getString(\"jreLeakListener.gcDaemonFail\"),\n                                e);\n                    } catch (IllegalAccessException e) {\n                        log.error(sm.getString(\"jreLeakListener.gcDaemonFail\"),\n                                e);\n                    } catch (InvocationTargetException e) {\n                        ExceptionUtils.handleThrowable(e.getCause());\n                        log.error(sm.getString(\"jreLeakListener.gcDaemonFail\"),\n                                e);\n                    }\n                }\n    \n                /*\n                 * Calling getPolicy retains a static reference to the context \n                 * class loader.\n                 */\n                if (securityPolicyProtection) {\n                    try {\n                        // Policy.getPolicy();\n                        Class<?> policyClass = Class\n                                .forName(\"javax.security.auth.Policy\");\n                        Method method = policyClass.getMethod(\"getPolicy\");\n                        method.invoke(null);\n                    } catch(ClassNotFoundException e) {\n                        // Ignore. The class is deprecated.\n                    } catch(SecurityException e) {\n                        // Ignore. Don't need call to getPolicy() to be\n                        // successful, just need to trigger static initializer.\n                    } catch (NoSuchMethodException e) {\n                        log.warn(sm.getString(\"jreLeakListener.authPolicyFail\"),\n                                e);\n                    } catch (IllegalArgumentException e) {\n                        log.warn(sm.getString(\"jreLeakListener.authPolicyFail\"),\n                                e);\n                    } catch (IllegalAccessException e) {\n                        log.warn(sm.getString(\"jreLeakListener.authPolicyFail\"),\n                                e);\n                    } catch (InvocationTargetException e) {\n                        ExceptionUtils.handleThrowable(e.getCause());\n                        log.warn(sm.getString(\"jreLeakListener.authPolicyFail\"),\n                                e);\n                    }\n                }\n    \n                \n                /*\n                 * Initializing javax.security.auth.login.Configuration retains a static reference to the context \n                 * class loader.\n                 */\n                if (securityLoginConfigurationProtection) {\n                    try {\n                        Class.forName(\"javax.security.auth.login.Configuration\", true, ClassLoader.getSystemClassLoader());\n                    } catch(ClassNotFoundException e) {\n                        // Ignore\n                    }\n                }\n\n                /*\n                 * Creating a MessageDigest during web application startup\n                 * initializes the Java Cryptography Architecture. Under certain\n                 * conditions this starts a Token poller thread with TCCL equal\n                 * to the web application class loader.\n                 * \n                 * Instead we initialize JCA right now.\n                 */\n                if (tokenPollerProtection) {\n                    java.security.Security.getProviders();\n                }\n                \n                /*\n                 * Several components end up opening JarURLConnections without\n                 * first disabling caching. This effectively locks the file.\n                 * Whilst more noticeable and harder to ignore on Windows, it\n                 * affects all operating systems.\n                 * \n                 * Those libraries/components known to trigger this issue\n                 * include:\n                 * - log4j versions 1.2.15 and earlier\n                 * - javax.xml.bind.JAXBContext.newInstance()\n                 */\n                \n                // Set the default URL caching policy to not to cache\n                if (urlCacheProtection) {\n                    try {\n                        // Doesn't matter that this JAR doesn't exist - just as\n                        // long as the URL is well-formed\n                        URL url = new URL(\"jar:file://dummy.jar!/\");\n                        URLConnection uConn = url.openConnection();\n                        uConn.setDefaultUseCaches(false);\n                    } catch (MalformedURLException e) {\n                        log.error(sm.getString(\n                                \"jreLeakListener.jarUrlConnCacheFail\"), e);\n                    } catch (IOException e) {\n                        log.error(sm.getString(\n                                \"jreLeakListener.jarUrlConnCacheFail\"), e);\n                    }\n                }\n                \n                /*\n                 * Haven't got to the root of what is going on with this leak\n                 * but if a web app is the first to make the calls below the web\n                 * application class loader will be pinned in memory.\n                 */\n                if (xmlParsingProtection) {\n                    DocumentBuilderFactory factory =\n                        DocumentBuilderFactory.newInstance();\n                    try {\n                        factory.newDocumentBuilder();\n                    } catch (ParserConfigurationException e) {\n                        log.error(sm.getString(\"jreLeakListener.xmlParseFail\"),\n                                e);\n                    }\n                }\n                \n                if (ldapPoolProtection) {\n                    try {\n                        Class.forName(\"com.sun.jndi.ldap.LdapPoolManager\");\n                    } catch (ClassNotFoundException e) {\n                        if (Globals.IS_ORACLE_JVM) {\n                            log.error(sm.getString(\n                                    \"jreLeakListener.ldapPoolManagerFail\"), e);\n                        } else {\n                            log.debug(sm.getString(\n                                    \"jreLeakListener.ldapPoolManagerFail\"), e);\n                        }\n                    }\n                }\n                \n                if (classesToInitialize != null) {\n                    StringTokenizer strTok =\n                        new StringTokenizer(classesToInitialize, \", \\r\\n\\t\");\n                    while (strTok.hasMoreTokens()) {\n                        String classNameToLoad = strTok.nextToken();\n                        try {\n                            Class.forName(classNameToLoad);\n                        } catch (ClassNotFoundException e) {\n                            log.error(\n                                sm.getString(\"jreLeakListener.classToInitializeFail\",\n                                    classNameToLoad), e);\n                            // continue with next class to load\n                        }\n                    }\n                }\n\n            } finally {\n                Thread.currentThread().setContextClassLoader(loader);\n            }\n        }\n    }"
            ],
            "java\\org\\apache\\catalina\\loader\\WebappLoader.java": [
                "    public void addRepository(String repository) {\n\n        if (log.isDebugEnabled())\n            log.debug(sm.getString(\"webappLoader.addRepository\", repository));\n\n        for (int i = 0; i < repositories.length; i++) {\n            if (repository.equals(repositories[i]))\n                return;\n        }\n        String results[] = new String[repositories.length + 1];\n        for (int i = 0; i < repositories.length; i++)\n            results[i] = repositories[i];\n        results[repositories.length] = repository;\n        repositories = results;\n\n        if (getState().isAvailable() && (classLoader != null)) {\n            classLoader.addRepository(repository);\n            if( loaderRepositories != null ) loaderRepositories.add(repository);\n            setClassPath();\n        }\n\n    }\n\n    public void backgroundProcess() {\n        if (reloadable && modified()) {\n            try {\n                Thread.currentThread().setContextClassLoader\n                    (WebappLoader.class.getClassLoader());\n                if (container instanceof StandardContext) {\n                    ((StandardContext) container).reload();\n                }\n            } finally {\n                if (container.getLoader() != null) {\n                    Thread.currentThread().setContextClassLoader\n                        (container.getLoader().getClassLoader());\n                }\n            }\n        } else {\n            closeJARs(false);\n        }\n    }",
                "    public void closeJARs(boolean force) {\n        if (classLoader !=null) {\n            classLoader.closeJARs(force);\n        }\n    }",
                "    protected void startInternal() throws LifecycleException {\n\n        if (log.isDebugEnabled())\n            log.debug(sm.getString(\"webappLoader.starting\"));\n\n        if (container.getResources() == null) {\n            log.info(\"No resources for \" + container);\n            setState(LifecycleState.STARTING);\n            return;\n        }\n\n        // Register a stream handler factory for the JNDI protocol\n        URLStreamHandlerFactory streamHandlerFactory =\n                DirContextURLStreamHandlerFactory.getInstance();\n        if (first) {\n            first = false;\n            try {\n                URL.setURLStreamHandlerFactory(streamHandlerFactory);\n            } catch (Exception e) {\n                // Log and continue anyway, this is not critical\n                log.error(\"Error registering jndi stream handler\", e);\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                // This is likely a dual registration\n                log.info(\"Dual registration of jndi stream handler: \"\n                         + t.getMessage());\n            }\n        }\n\n        // Construct a class loader based on our current repositories list\n        try {\n\n            classLoader = createClassLoader();\n            classLoader.setResources(container.getResources());\n            classLoader.setDelegate(this.delegate);\n            classLoader.setSearchExternalFirst(searchExternalFirst);\n            if (container instanceof StandardContext) {\n                classLoader.setAntiJARLocking(\n                        ((StandardContext) container).getAntiJARLocking());\n                classLoader.setClearReferencesStatic(\n                        ((StandardContext) container).getClearReferencesStatic());\n                classLoader.setClearReferencesStopThreads(\n                        ((StandardContext) container).getClearReferencesStopThreads());\n                classLoader.setClearReferencesStopTimerThreads(\n                        ((StandardContext) container).getClearReferencesStopTimerThreads());\n                classLoader.setClearReferencesHttpClientKeepAliveThread(\n                        ((StandardContext) container).getClearReferencesHttpClientKeepAliveThread());\n            }\n\n            for (int i = 0; i < repositories.length; i++) {\n                classLoader.addRepository(repositories[i]);\n            }\n\n            // Configure our repositories\n            setRepositories();\n            setClassPath();\n\n            setPermissions();\n\n            ((Lifecycle) classLoader).start();\n\n            // Binding the Webapp class loader to the directory context\n            DirContextURLStreamHandler.bind(classLoader,\n                    this.container.getResources());\n\n            StandardContext ctx=(StandardContext)container;\n            String contextName = ctx.getName();\n            if (!contextName.startsWith(\"/\")) {\n                contextName = \"/\" + contextName;\n            }\n            ObjectName cloname = new ObjectName\n                (MBeanUtils.getDomain(ctx) + \":type=WebappClassLoader,context=\"\n                 + contextName + \",host=\" + ctx.getParent().getName());\n            Registry.getRegistry(null, null)\n                .registerComponent(classLoader, cloname, null);\n\n        } catch (Throwable t) {\n            t = ExceptionUtils.unwrapInvocationTargetException(t);\n            ExceptionUtils.handleThrowable(t);\n            log.error( \"LifecycleException \", t );\n            throw new LifecycleException(\"start: \", t);\n        }\n\n        setState(LifecycleState.STARTING);\n    }",
                "    protected void stopInternal() throws LifecycleException {\n\n        if (log.isDebugEnabled())\n            log.debug(sm.getString(\"webappLoader.stopping\"));\n\n        setState(LifecycleState.STOPPING);\n\n        // Remove context attributes as appropriate\n        if (container instanceof Context) {\n            ServletContext servletContext =\n                ((Context) container).getServletContext();\n            servletContext.removeAttribute(Globals.CLASS_PATH_ATTR);\n        }\n\n        // Throw away our current class loader\n        if (classLoader != null) {\n            ((Lifecycle) classLoader).stop();\n            DirContextURLStreamHandler.unbind(classLoader);\n        }\n\n        try {\n            StandardContext ctx=(StandardContext)container;\n            String contextName = ctx.getName();\n            if (!contextName.startsWith(\"/\")) {\n                contextName = \"/\" + contextName;\n            }\n            ObjectName cloname = new ObjectName\n                (MBeanUtils.getDomain(ctx) + \":type=WebappClassLoader,context=\"\n                 + contextName + \",host=\" + ctx.getParent().getName());\n            Registry.getRegistry(null, null).unregisterComponent(cloname);\n        } catch (Exception e) {\n            log.error(\"LifecycleException \", e);\n        }\n\n        classLoader = null;\n    }",
                "    public void propertyChange(PropertyChangeEvent event) {\n\n        // Validate the source of this event\n        if (!(event.getSource() instanceof Context))\n            return;\n\n        // Process a relevant property change\n        if (event.getPropertyName().equals(\"reloadable\")) {\n            try {\n                setReloadable\n                    ( ((Boolean) event.getNewValue()).booleanValue() );\n            } catch (NumberFormatException e) {\n                log.error(sm.getString(\"webappLoader.reloadable\",\n                                 event.getNewValue().toString()));\n            }\n        }\n\n    }\n\n    private String utf8Decode(String input) {\n        String result = null;\n        try {\n            result = URLDecoder.decode(input, \"UTF-8\");\n        } catch (UnsupportedEncodingException uee) {\n            // Impossible. All JVMs are required to support UTF-8.\n        }\n        return result;\n    }",
                "    private boolean copyDir(DirContext srcDir, File destDir) {\n\n        try {\n\n            NamingEnumeration<NameClassPair> enumeration = srcDir.list(\"\");\n            while (enumeration.hasMoreElements()) {\n                NameClassPair ncPair = enumeration.nextElement();\n                String name = ncPair.getName();\n                Object object = srcDir.lookup(name);\n                File currentFile = new File(destDir, name);\n                if (object instanceof Resource) {\n                    InputStream is = ((Resource) object).streamContent();\n                    OutputStream os = new FileOutputStream(currentFile);\n                    if (!copy(is, os))\n                        return false;\n                } else if (object instanceof InputStream) {\n                    OutputStream os = new FileOutputStream(currentFile);\n                    if (!copy((InputStream) object, os))\n                        return false;\n                } else if (object instanceof DirContext) {\n                    if (!currentFile.isDirectory() && !currentFile.mkdir())\n                        return false;\n                    if (!copyDir((DirContext) object, currentFile))\n                        return false;\n                }\n            }\n\n        } catch (NamingException e) {\n            return false;\n        } catch (IOException e) {\n            return false;\n        }\n\n        return true;\n\n    }",
                "    private boolean copy(InputStream is, OutputStream os) {\n\n        try {\n            byte[] buf = new byte[4096];\n            while (true) {\n                int len = is.read(buf);\n                if (len < 0)\n                    break;\n                os.write(buf, 0, len);\n            }\n            is.close();\n            os.close();\n        } catch (IOException e) {\n            return false;\n        }\n\n        return true;\n\n    }"
            ],
            "java\\org\\apache\\catalina\\connector\\CoyoteWriter.java": [
                "    public void flush() {\n\n        if (error) {\n            return;\n        }\n\n        try {\n            ob.flush();\n        } catch (IOException e) {\n            error = true;\n        }\n\n    }\n\n    public void close() {\n\n        // We don't close the PrintWriter - super() is not called,\n        // so the stream can be reused. We close ob.\n        try {\n            ob.close();\n        } catch (IOException ex ) {\n            // Ignore\n        }\n        error = false;\n\n    }\n\n    public void write(int c) {\n\n        if (error) {\n            return;\n        }\n\n        try {\n            ob.write(c);\n        } catch (IOException e) {\n            error = true;\n        }\n\n    }",
                "    public void write(char buf[], int off, int len) {\n\n        if (error) {\n            return;\n        }\n\n        try {\n            ob.write(buf, off, len);\n        } catch (IOException e) {\n            error = true;\n        }\n\n    }\n\n    public void write(String s, int off, int len) {\n\n        if (error) {\n            return;\n        }\n\n        try {\n            ob.write(s, off, len);\n        } catch (IOException e) {\n            error = true;\n        }\n\n    }\n\n    public void print(String s) {\n        if (s == null) {\n            s = \"null\";\n        }\n        write(s);\n    }"
            ],
            "test\\org\\apache\\catalina\\tribes\\test\\NioSenderTest.java": [
                "    public void init() throws Exception {\n        synchronized (Selector.class) {\n            // Selector.open() isn't thread safe\n            // http://bugs.sun.com/view_bug.do?bug_id=6427854\n            // Affects 1.6.0_29, fixed in 1.7.0_01\n            selector = Selector.open();\n        }\n        mbr = new MemberImpl(\"localhost\",4444,0);\n        NioSender sender = new NioSender();\n        sender.setDestination(mbr);\n        sender.setDirectBuffer(true);\n        sender.setSelector(selector);\n        sender.setMessage(XByteBuffer.createDataPackage(getMessage(mbr)));\n        sender.connect();\n    }",
                "    public void run() {\n        while (true) {\n\n            int selectedKeys = 0;\n            try {\n                selectedKeys = selector.select(100);\n                //               if ( selectedKeys == 0 ) {\n                //                   System.out.println(\"No registered interests. Sleeping for a second.\");\n                //                   Thread.sleep(100);\n            } catch (Exception e) {\n                e.printStackTrace();\n                continue;\n            }\n\n            if (selectedKeys == 0) {\n                continue;\n            }\n\n            Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n            while (it.hasNext()) {\n                SelectionKey sk = it.next();\n                it.remove();\n                try {\n                    int readyOps = sk.readyOps();\n                    sk.interestOps(sk.interestOps() & ~readyOps);\n                    NioSender sender = (NioSender) sk.attachment();\n                    if ( sender.process(sk, (testOptions&Channel.SEND_OPTIONS_USE_ACK)==Channel.SEND_OPTIONS_USE_ACK) ) {\n                        System.out.println(\"Message completed for handler:\"+sender);\n                        Thread.sleep(2000);\n                        sender.reset();\n                        sender.setMessage(XByteBuffer.createDataPackage(getMessage(mbr)));\n                    }\n\n\n                } catch (Throwable t) {\n                    t.printStackTrace();\n                    return;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        NioSenderTest sender = new NioSenderTest();\n        sender.init();\n        sender.run();\n    }\n}"
            ],
            "java\\org\\apache\\catalina\\loader\\VirtualWebappLoader.java": [
                "    protected void startInternal() throws LifecycleException {\n\n        // just add any jar/directory set in virtual classpath to the\n        // repositories list before calling start on the standard WebappLoader\n        StringTokenizer tkn = new StringTokenizer(virtualClasspath, \";\");\n        Set<String> set = new LinkedHashSet<String>();\n        while (tkn.hasMoreTokens()) {\n            String token = tkn.nextToken().trim();\n\n            if (token.isEmpty()) {\n                continue;\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(sm.getString(\"virtualWebappLoader.token\", token));\n\n            if (token.endsWith(\"*.jar\")) {\n                // glob\n                token = token.substring(0, token.length() - \"*.jar\".length());\n\n                File directory = new File(token);\n                if (!directory.isDirectory()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\n                                \"virtualWebappLoader.token.notDirectory\",\n                                directory.getAbsolutePath()));\n                    }\n                    continue;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                            \"virtualWebappLoader.token.glob.dir\",\n                            directory.getAbsolutePath()));\n                }\n                String filenames[] = directory.list();\n                Arrays.sort(filenames);\n                for (int j = 0; j < filenames.length; j++) {\n                    String filename = filenames[j].toLowerCase(Locale.ENGLISH);\n                    if (!filename.endsWith(\".jar\"))\n                        continue;\n                    File file = new File(directory, filenames[j]);\n                    if (!file.isFile()) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\n                                    \"virtualWebappLoader.token.notFile\",\n                                    file.getAbsolutePath()));\n                        }\n                        continue;\n                    }\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\n                                \"virtualWebappLoader.token.file\",\n                                file.getAbsolutePath()));\n                    }\n                    set.add(file.toURI().toString());\n                }\n            } else {\n                // single file or directory\n                File file = new File(token);\n                if (!file.exists()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\n                                \"virtualWebappLoader.token.notExists\",\n                                file.getAbsolutePath()));\n                    }\n                    continue;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                            \"virtualWebappLoader.token.file\",\n                            file.getAbsolutePath()));\n                }\n                set.add(file.toURI().toString());\n            }\n        }\n\n        for (String repository: set) {\n            addRepository(repository);\n        }\n\n        super.startInternal();\n    }"
            ],
            "java\\org\\apache\\juli\\logging\\LogFactory.java": [
                "    public static void release(ClassLoader classLoader) {\n        // JULI's log manager looks at the current classLoader so there is no\n        // need to use the passed in classLoader, the default implementation\n        // does not so calling reset in that case will break things\n        if (!LogManager.getLogManager().getClass().getName().equals(\n                \"java.util.logging.LogManager\")) {\n            LogManager.getLogManager().reset();\n        }\n    }\n\n    public static String objectId(Object o) {\n        if (o == null) {\n            return \"null\";\n        } else {\n            return o.getClass().getName() + \"@\" + System.identityHashCode(o);\n        }\n    }"
            ],
            "java\\org\\apache\\catalina\\loader\\WebappClassLoader.java": [
                "    public void addPermission(String filepath) {\n        if (filepath == null) {\n            return;\n        }\n\n        String path = filepath;\n\n        if (securityManager != null) {\n            Permission permission = null;\n            if (path.startsWith(\"jndi:\") || path.startsWith(\"jar:jndi:\")) {\n                if (!path.endsWith(\"/\")) {\n                    path = path + \"/\";\n                }\n                permission = new JndiPermission(path + \"*\");\n                addPermission(permission);\n            } else {\n                if (!path.endsWith(File.separator)) {\n                    permission = new FilePermission(path, \"read\");\n                    addPermission(permission);\n                    path = path + File.separator;\n                }\n                permission = new FilePermission(path + \"-\", \"read\");\n                addPermission(permission);\n            }\n        }\n    }\n\n    public void addPermission(URL url) {\n        if (url != null) {\n            addPermission(url.toString());\n        }\n    }\n\n    public void addPermission(Permission permission) {\n        if ((securityManager != null) && (permission != null)) {\n            permissionList.add(permission);\n        }\n    }",
                "    public void addRepository(String repository) {\n\n        // Ignore any of the standard repositories, as they are set up using\n        // either addJar or addRepository\n        if (repository.startsWith(\"/WEB-INF/lib\")\n            || repository.startsWith(\"/WEB-INF/classes\"))\n            return;\n\n        // Add this repository to our underlying class loader\n        try {\n            URL url = new URL(repository);\n            super.addURL(url);\n            hasExternalRepositories = true;\n            repositoryURLs = null;\n        } catch (MalformedURLException e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Invalid repository: \" + repository);\n            iae.initCause(e);\n            throw iae;\n        }\n\n    }",
                "    synchronized void addRepository(String repository, File file) {\n\n        // Note : There should be only one (of course), but I think we should\n        // keep this a bit generic\n\n        if (repository == null)\n            return;\n\n        if (log.isDebugEnabled())\n            log.debug(\"addRepository(\" + repository + \")\");\n\n        int i;\n\n        // Add this repository to our internal list\n        String[] result = new String[repositories.length + 1];\n        for (i = 0; i < repositories.length; i++) {\n            result[i] = repositories[i];\n        }\n        result[repositories.length] = repository;\n        repositories = result;\n\n        // Add the file to the list\n        File[] result2 = new File[files.length + 1];\n        for (i = 0; i < files.length; i++) {\n            result2[i] = files[i];\n        }\n        result2[files.length] = file;\n        files = result2;\n\n    }",
                "    public boolean modified() {\n\n        if (log.isDebugEnabled())\n            log.debug(\"modified()\");\n\n        // Checking for modified loaded resources\n        int length = paths.length;\n\n        // A rare race condition can occur in the updates of the two arrays\n        // It's totally ok if the latest class added is not checked (it will\n        // be checked the next time\n        int length2 = lastModifiedDates.length;\n        if (length > length2)\n            length = length2;\n\n        for (int i = 0; i < length; i++) {\n            try {\n                long lastModified =\n                    ((ResourceAttributes) resources.getAttributes(paths[i]))\n                    .getLastModified();\n                if (lastModified != lastModifiedDates[i]) {\n                    if( log.isDebugEnabled() )\n                        log.debug(\"  Resource '\" + paths[i]\n                                  + \"' was modified; Date is now: \"\n                                  + new java.util.Date(lastModified) + \" Was: \"\n                                  + new java.util.Date(lastModifiedDates[i]));\n                    return (true);\n                }\n            } catch (NamingException e) {\n                log.error(\"    Resource '\" + paths[i] + \"' is missing\");\n                return (true);\n            }\n        }\n\n        length = jarNames.length;\n\n        // Check if JARs have been added or removed\n        if (getJarPath() != null) {\n\n            try {\n                NamingEnumeration<Binding> enumeration =\n                    resources.listBindings(getJarPath());\n                int i = 0;\n                while (enumeration.hasMoreElements() && (i < length)) {\n                    NameClassPair ncPair = enumeration.nextElement();\n                    String name = ncPair.getName();\n                    // Ignore non JARs present in the lib folder\n                    if (!name.endsWith(\".jar\"))\n                        continue;\n                    if (!name.equals(jarNames[i])) {\n                        // Missing JAR\n                        log.info(\"    Additional JARs have been added : '\"\n                                 + name + \"'\");\n                        return (true);\n                    }\n                    i++;\n                }\n                if (enumeration.hasMoreElements()) {\n                    while (enumeration.hasMoreElements()) {\n                        NameClassPair ncPair = enumeration.nextElement();\n                        String name = ncPair.getName();\n                        // Additional non-JAR files are allowed\n                        if (name.endsWith(\".jar\")) {\n                            // There was more JARs\n                            log.info(\"    Additional JARs have been added\");\n                            return (true);\n                        }\n                    }\n                } else if (i < jarNames.length) {\n                    // There was less JARs\n                    log.info(\"    Additional JARs have been added\");\n                    return (true);\n                }\n            } catch (NamingException e) {\n                if (log.isDebugEnabled())\n                    log.debug(\"    Failed tracking modifications of '\"\n                        + getJarPath() + \"'\");\n            } catch (ClassCastException e) {\n                log.error(\"    Failed tracking modifications of '\"\n                          + getJarPath() + \"' : \" + e.getMessage());\n            }\n\n        }\n\n        // No classes have been modified\n        return (false);\n\n    }",
                "    public Class<?> findClass(String name) throws ClassNotFoundException {\n\n        if (log.isDebugEnabled())\n            log.debug(\"    findClass(\" + name + \")\");\n\n        // Cannot load anything from local repositories if class loader is stopped\n        if (!started) {\n            throw new ClassNotFoundException(name);\n        }\n\n        // (1) Permission to define this class when using a SecurityManager\n        if (securityManager != null) {\n            int i = name.lastIndexOf('.');\n            if (i >= 0) {\n                try {\n                    if (log.isTraceEnabled())\n                        log.trace(\"      securityManager.checkPackageDefinition\");\n                    securityManager.checkPackageDefinition(name.substring(0,i));\n                } catch (Exception se) {\n                    if (log.isTraceEnabled())\n                        log.trace(\"      -->Exception-->ClassNotFoundException\", se);\n                    throw new ClassNotFoundException(name, se);\n                }\n            }\n        }\n\n        // Ask our superclass to locate this class, if possible\n        // (throws ClassNotFoundException if it is not found)\n        Class<?> clazz = null;\n        try {\n            if (log.isTraceEnabled())\n                log.trace(\"      findClassInternal(\" + name + \")\");\n            if (hasExternalRepositories && searchExternalFirst) {\n                try {\n                    clazz = super.findClass(name);\n                } catch(ClassNotFoundException cnfe) {\n                    // Ignore - will search internal repositories next\n                } catch(AccessControlException ace) {\n                    log.warn(\"WebappClassLoader.findClassInternal(\" + name\n                            + \") security exception: \" + ace.getMessage(), ace);\n                    throw new ClassNotFoundException(name, ace);\n                } catch (RuntimeException e) {\n                    if (log.isTraceEnabled())\n                        log.trace(\"      -->RuntimeException Rethrown\", e);\n                    throw e;\n                }\n            }\n            if ((clazz == null)) {\n                try {\n                    clazz = findClassInternal(name);\n                } catch(ClassNotFoundException cnfe) {\n                    if (!hasExternalRepositories || searchExternalFirst) {\n                        throw cnfe;\n                    }\n                } catch(AccessControlException ace) {\n                    log.warn(\"WebappClassLoader.findClassInternal(\" + name\n                            + \") security exception: \" + ace.getMessage(), ace);\n                    throw new ClassNotFoundException(name, ace);\n                } catch (RuntimeException e) {\n                    if (log.isTraceEnabled())\n                        log.trace(\"      -->RuntimeException Rethrown\", e);\n                    throw e;\n                }\n            }\n            if ((clazz == null) && hasExternalRepositories && !searchExternalFirst) {\n                try {\n                    clazz = super.findClass(name);\n                } catch(AccessControlException ace) {\n                    log.warn(\"WebappClassLoader.findClassInternal(\" + name\n                            + \") security exception: \" + ace.getMessage(), ace);\n                    throw new ClassNotFoundException(name, ace);\n                } catch (RuntimeException e) {\n                    if (log.isTraceEnabled())\n                        log.trace(\"      -->RuntimeException Rethrown\", e);\n                    throw e;\n                }\n            }\n            if (clazz == null) {\n                if (log.isDebugEnabled())\n                    log.debug(\"    --> Returning ClassNotFoundException\");\n                throw new ClassNotFoundException(name);\n            }\n        } catch (ClassNotFoundException e) {\n            if (log.isTraceEnabled())\n                log.trace(\"    --> Passing on ClassNotFoundException\");\n            throw e;\n        }\n\n        // Return the class we have located\n        if (log.isTraceEnabled())\n            log.debug(\"      Returning class \" + clazz);\n\n        if (log.isTraceEnabled()) {\n            ClassLoader cl;\n            if (Globals.IS_SECURITY_ENABLED){\n                cl = AccessController.doPrivileged(\n                    new PrivilegedGetClassLoader(clazz));\n            } else {\n                cl = clazz.getClassLoader();\n            }\n            log.debug(\"      Loaded by \" + cl.toString());\n        }\n        return (clazz);\n\n    }",
                "    public URL findResource(final String name) {\n\n        if (log.isDebugEnabled())\n            log.debug(\"    findResource(\" + name + \")\");\n\n        URL url = null;\n\n        if (hasExternalRepositories && searchExternalFirst)\n            url = super.findResource(name);\n\n        if (url == null) {\n            ResourceEntry entry = resourceEntries.get(name);\n            if (entry == null) {\n                if (securityManager != null) {\n                    PrivilegedAction<ResourceEntry> dp =\n                        new PrivilegedFindResourceByName(name, name);\n                    entry = AccessController.doPrivileged(dp);\n                } else {\n                    entry = findResourceInternal(name, name);\n                }\n            }\n            if (entry != null) {\n                url = entry.source;\n            }\n        }\n\n        if ((url == null) && hasExternalRepositories && !searchExternalFirst)\n            url = super.findResource(name);\n\n        if (log.isDebugEnabled()) {\n            if (url != null)\n                log.debug(\"    --> Returning '\" + url.toString() + \"'\");\n            else\n                log.debug(\"    --> Resource not found, returning null\");\n        }\n        return (url);\n\n    }",
                "    public Enumeration<URL> findResources(String name) throws IOException {\n\n        if (log.isDebugEnabled())\n            log.debug(\"    findResources(\" + name + \")\");\n\n        //we use a LinkedHashSet instead of a Vector to avoid duplicates with virtualmappings\n        LinkedHashSet<URL> result = new LinkedHashSet<URL>();\n\n        int jarFilesLength = jarFiles.length;\n        int repositoriesLength = repositories.length;\n\n        int i;\n\n        // Adding the results of a call to the superclass\n        if (hasExternalRepositories && searchExternalFirst) {\n\n            Enumeration<URL> otherResourcePaths = super.findResources(name);\n\n            while (otherResourcePaths.hasMoreElements()) {\n                result.add(otherResourcePaths.nextElement());\n            }\n\n        }\n        // Looking at the repositories\n        for (i = 0; i < repositoriesLength; i++) {\n            try {\n                String fullPath = repositories[i] + name;\n                resources.lookup(fullPath);\n                // Note : Not getting an exception here means the resource was\n                // found\n                try {\n                    result.add(getURI(new File(files[i], name)));\n                } catch (MalformedURLException e) {\n                    // Ignore\n                }\n            } catch (NamingException e) {\n                // Ignore\n            }\n        }\n\n        // Looking at the JAR files\n        synchronized (jarFiles) {\n            if (openJARs()) {\n                for (i = 0; i < jarFilesLength; i++) {\n                    JarEntry jarEntry = jarFiles[i].getJarEntry(name);\n                    if (jarEntry != null) {\n                        try {\n                            String jarFakeUrl = getURI(jarRealFiles[i]).toString();\n                            jarFakeUrl = \"jar:\" + jarFakeUrl + \"!/\" + name;\n                            result.add(new URL(jarFakeUrl));\n                        } catch (MalformedURLException e) {\n                            // Ignore\n                        }\n                    }\n                }\n            }\n        }\n\n        // Adding the results of a call to the superclass\n        if (hasExternalRepositories && !searchExternalFirst) {\n\n            Enumeration<URL> otherResourcePaths = super.findResources(name);\n\n            while (otherResourcePaths.hasMoreElements()) {\n                result.add(otherResourcePaths.nextElement());\n            }\n\n        }\n\n        return Collections.enumeration(result);\n    }",
                "    public Class<?> loadClass(String name) throws ClassNotFoundException {\n\n        return (loadClass(name, false));\n\n    }\n\n    public void start() throws LifecycleException {\n\n        started = true;\n        String encoding = null;\n        try {\n            encoding = System.getProperty(\"file.encoding\");\n        } catch (SecurityException e) {\n            return;\n        }\n        if (encoding.indexOf(\"EBCDIC\")!=-1) {\n            needConvert = true;\n        }\n\n    }",
                "    public void stop() throws LifecycleException {\n\n        // Clearing references should be done before setting started to\n        // false, due to possible side effects\n        clearReferences();\n\n        started = false;\n\n        int length = files.length;\n        for (int i = 0; i < length; i++) {\n            files[i] = null;\n        }\n\n        length = jarFiles.length;\n        for (int i = 0; i < length; i++) {\n            try {\n                if (jarFiles[i] != null) {\n                    jarFiles[i].close();\n                }\n            } catch (IOException e) {\n                // Ignore\n            }\n            jarFiles[i] = null;\n        }\n\n        notFoundResources.clear();\n        resourceEntries.clear();\n        resources = null;\n        repositories = null;\n        repositoryURLs = null;\n        files = null;\n        jarFiles = null;\n        jarRealFiles = null;\n        jarPath = null;\n        jarNames = null;\n        lastModifiedDates = null;\n        paths = null;\n        hasExternalRepositories = false;\n        parent = null;\n\n        permissionList.clear();\n        loaderPC.clear();\n\n        if (loaderDir != null) {\n            deleteDir(loaderDir);\n        }\n\n    }",
                "    public void closeJARs(boolean force) {\n        if (jarFiles.length > 0) {\n                synchronized (jarFiles) {\n                    if (force || (System.currentTimeMillis()\n                                  > (lastJarAccessed + 90000))) {\n                        for (int i = 0; i < jarFiles.length; i++) {\n                            try {\n                                if (jarFiles[i] != null) {\n                                    jarFiles[i].close();\n                                    jarFiles[i] = null;\n                                }\n                            } catch (IOException e) {\n                                if (log.isDebugEnabled()) {\n                                    log.debug(\"Failed to close JAR\", e);\n                                }\n                            }\n                        }\n                    }\n                }\n        }\n    }",
                "    protected void clearReferences() {\n\n        // De-register any remaining JDBC drivers\n        clearReferencesJdbc();\n\n        // Stop any threads the web application started\n        clearReferencesThreads();\n\n        // Check for leaks triggered by ThreadLocals loaded by this class loader\n        checkThreadLocalsForLeaks();\n\n        // Clear RMI Targets loaded by this class loader\n        clearReferencesRmiTargets();\n\n        // Null out any static or final fields from loaded classes,\n        // as a workaround for apparent garbage collection bugs\n        if (clearReferencesStatic) {\n            clearReferencesStaticFinal();\n        }\n\n         // Clear the IntrospectionUtils cache.\n        IntrospectionUtils.clear();\n\n        // Clear the classloader reference in common-logging\n        if (clearReferencesLogFactoryRelease) {\n            org.apache.juli.logging.LogFactory.release(this);\n        }\n\n        // Clear the resource bundle cache\n        // This shouldn't be necessary, the cache uses weak references but\n        // it has caused leaks. Oddly, using the leak detection code in\n        // standard host allows the class loader to be GC'd. This has been seen\n        // on Sun but not IBM JREs. Maybe a bug in Sun's GC impl?\n        clearReferencesResourceBundles();\n\n        // Clear the classloader reference in the VM's bean introspector\n        java.beans.Introspector.flushCaches();\n\n    }",
                "    private final void clearReferencesJdbc() {\n        InputStream is = getResourceAsStream(\n                \"org/apache/catalina/loader/JdbcLeakPrevention.class\");\n        // We know roughly how big the class will be (~ 1K) so allow 2k as a\n        // starting point\n        byte[] classBytes = new byte[2048];\n        int offset = 0;\n        try {\n            int read = is.read(classBytes, offset, classBytes.length-offset);\n            while (read > -1) {\n                offset += read;\n                if (offset == classBytes.length) {\n                    // Buffer full - double size\n                    byte[] tmp = new byte[classBytes.length * 2];\n                    System.arraycopy(classBytes, 0, tmp, 0, classBytes.length);\n                    classBytes = tmp;\n                }\n                read = is.read(classBytes, offset, classBytes.length-offset);\n            }\n            Class<?> lpClass =\n                defineClass(\"org.apache.catalina.loader.JdbcLeakPrevention\",\n                    classBytes, 0, offset, this.getClass().getProtectionDomain());\n            Object obj = lpClass.newInstance();\n            @SuppressWarnings(\"unchecked\") // clearJdbcDriverRegistrations() returns List<String>\n            List<String> driverNames = (List<String>) obj.getClass().getMethod(\n                    \"clearJdbcDriverRegistrations\").invoke(obj);\n            for (String name : driverNames) {\n                log.error(sm.getString(\"webappClassLoader.clearJdbc\",\n                        contextName, name));\n            }\n        } catch (Exception e) {\n            // So many things to go wrong above...\n            Throwable t = ExceptionUtils.unwrapInvocationTargetException(e);\n            ExceptionUtils.handleThrowable(t);\n            log.warn(sm.getString(\n                    \"webappClassLoader.jdbcRemoveFailed\", contextName), t);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException ioe) {\n                    log.warn(sm.getString(\n                            \"webappClassLoader.jdbcRemoveStreamError\",\n                            contextName), ioe);\n                }\n            }\n        }\n    }",
                "    private final void clearReferencesStaticFinal() {\n\n        @SuppressWarnings(\"unchecked\") // resourceEntries is HashMap<String, ResourceEntry>\n        Collection<ResourceEntry> values =\n            ((HashMap<String,ResourceEntry>) resourceEntries.clone()).values();\n        Iterator<ResourceEntry> loadedClasses = values.iterator();\n        //\n        // walk through all loaded class to trigger initialization for\n        //    any uninitialized classes, otherwise initialization of\n        //    one class may call a previously cleared class.\n        while(loadedClasses.hasNext()) {\n            ResourceEntry entry = loadedClasses.next();\n            if (entry.loadedClass != null) {\n                Class<?> clazz = entry.loadedClass;\n                try {\n                    Field[] fields = clazz.getDeclaredFields();\n                    for (int i = 0; i < fields.length; i++) {\n                        if(Modifier.isStatic(fields[i].getModifiers())) {\n                            fields[i].get(null);\n                            break;\n                        }\n                    }\n                } catch(Throwable t) {\n                    // Ignore\n                }\n            }\n        }\n        loadedClasses = values.iterator();\n        while (loadedClasses.hasNext()) {\n            ResourceEntry entry = loadedClasses.next();\n            if (entry.loadedClass != null) {\n                Class<?> clazz = entry.loadedClass;\n                try {\n                    Field[] fields = clazz.getDeclaredFields();\n                    for (int i = 0; i < fields.length; i++) {\n                        Field field = fields[i];\n                        int mods = field.getModifiers();\n                        if (field.getType().isPrimitive()\n                                || (field.getName().indexOf(\"$\") != -1)) {\n                            continue;\n                        }\n                        if (Modifier.isStatic(mods)) {\n                            try {\n                                field.setAccessible(true);\n                                if (Modifier.isFinal(mods)) {\n                                    if (!((field.getType().getName().startsWith(\"java.\"))\n                                            || (field.getType().getName().startsWith(\"javax.\")))) {\n                                        nullInstance(field.get(null));\n                                    }\n                                } else {\n                                    field.set(null, null);\n                                    if (log.isDebugEnabled()) {\n                                        log.debug(\"Set field \" + field.getName()\n                                                + \" to null in class \" + clazz.getName());\n                                    }\n                                }\n                            } catch (Throwable t) {\n                                ExceptionUtils.handleThrowable(t);\n                                if (log.isDebugEnabled()) {\n                                    log.debug(\"Could not set field \" + field.getName()\n                                            + \" to null in class \" + clazz.getName(), t);\n                                }\n                            }\n                        }\n                    }\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Could not clean fields for class \" + clazz.getName(), t);\n                    }\n                }\n            }\n        }\n\n    }",
                "    private void nullInstance(Object instance) {\n        if (instance == null) {\n            return;\n        }\n        Field[] fields = instance.getClass().getDeclaredFields();\n        for (int i = 0; i < fields.length; i++) {\n            Field field = fields[i];\n            int mods = field.getModifiers();\n            if (field.getType().isPrimitive()\n                    || (field.getName().indexOf(\"$\") != -1)) {\n                continue;\n            }\n            try {\n                field.setAccessible(true);\n                if (Modifier.isStatic(mods) && Modifier.isFinal(mods)) {\n                    // Doing something recursively is too risky\n                    continue;\n                }\n                Object value = field.get(instance);\n                if (null != value) {\n                    Class<? extends Object> valueClass = value.getClass();\n                    if (!loadedByThisOrChild(valueClass)) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Not setting field \" + field.getName() +\n                                    \" to null in object of class \" +\n                                    instance.getClass().getName() +\n                                    \" because the referenced object was of type \" +\n                                    valueClass.getName() +\n                                    \" which was not loaded by this WebappClassLoader.\");\n                        }\n                    } else {\n                        field.set(instance, null);\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Set field \" + field.getName()\n                                    + \" to null in class \" + instance.getClass().getName());\n                        }\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Could not set field \" + field.getName()\n                            + \" to null in object instance of class \"\n                            + instance.getClass().getName(), t);\n                }\n            }\n        }\n    }",
                "    private void clearReferencesThreads() {\n        Thread[] threads = getThreads();\n        List<Thread> executorThreadsToStop = new ArrayList<Thread>();\n\n        // Iterate over the set of threads\n        for (Thread thread : threads) {\n            if (thread != null) {\n                ClassLoader ccl = thread.getContextClassLoader();\n                if (ccl == this) {\n                    // Don't warn about this thread\n                    if (thread == Thread.currentThread()) {\n                        continue;\n                    }\n\n                    // JVM controlled threads\n                    ThreadGroup tg = thread.getThreadGroup();\n                    if (tg != null &&\n                            JVM_THREAD_GROUP_NAMES.contains(tg.getName())) {\n\n                        // HttpClient keep-alive threads\n                        if (clearReferencesHttpClientKeepAliveThread &&\n                                thread.getName().equals(\"Keep-Alive-Timer\")) {\n                            thread.setContextClassLoader(parent);\n                            log.debug(sm.getString(\n                                    \"webappClassLoader.checkThreadsHttpClient\"));\n                        }\n\n                        // Don't warn about remaining JVM controlled threads\n                        continue;\n                    }\n\n                    // Skip threads that have already died\n                    if (!thread.isAlive()) {\n                        continue;\n                    }\n\n                    // TimerThread can be stopped safely so treat separately\n                    // \"java.util.TimerThread\" in Sun/Oracle JDK\n                    // \"java.util.Timer$TimerImpl\" in Apache Harmony and in IBM JDK\n                    if (thread.getClass().getName().startsWith(\"java.util.Timer\") &&\n                            clearReferencesStopTimerThreads) {\n                        clearReferencesStopTimerThread(thread);\n                        continue;\n                    }\n\n                    if (isRequestThread(thread)) {\n                        log.error(sm.getString(\"webappClassLoader.warnRequestThread\",\n                                contextName, thread.getName()));\n                    } else {\n                        log.error(sm.getString(\"webappClassLoader.warnThread\",\n                                contextName, thread.getName()));\n                    }\n\n                    // Don't try an stop the threads unless explicitly\n                    // configured to do so\n                    if (!clearReferencesStopThreads) {\n                        continue;\n                    }\n\n                    // If the thread has been started via an executor, try\n                    // shutting down the executor\n                    boolean usingExecutor = false;\n                    try {\n\n                        // Runnable wrapped by Thread\n                        // \"target\" in Sun/Oracle JDK\n                        // \"runnable\" in IBM JDK\n                        // \"action\" in Apache Harmony\n                        Object target = null;\n                        for (String fieldName : new String[] { \"target\",\n                                \"runnable\", \"action\" }) {\n                            try {\n                                Field targetField = thread.getClass()\n                                        .getDeclaredField(fieldName);\n                                targetField.setAccessible(true);\n                                target = targetField.get(thread);\n                                break;\n                            } catch (NoSuchFieldException nfe) {\n                                continue;\n                            }\n                        }\n\n                        // \"java.util.concurrent\" code is in public domain,\n                        // so all implementations are similar\n                        if (target != null &&\n                                target.getClass().getCanonicalName() != null\n                                && target.getClass().getCanonicalName().equals(\n                                \"java.util.concurrent.ThreadPoolExecutor.Worker\")) {\n                            Field executorField =\n                                target.getClass().getDeclaredField(\"this$0\");\n                            executorField.setAccessible(true);\n                            Object executor = executorField.get(target);\n                            if (executor instanceof ThreadPoolExecutor) {\n                                ((ThreadPoolExecutor) executor).shutdownNow();\n                                usingExecutor = true;\n                            }\n                        }\n                    } catch (SecurityException e) {\n                        log.warn(sm.getString(\n                                \"webappClassLoader.stopThreadFail\",\n                                thread.getName(), contextName), e);\n                    } catch (NoSuchFieldException e) {\n                        log.warn(sm.getString(\n                                \"webappClassLoader.stopThreadFail\",\n                                thread.getName(), contextName), e);\n                    } catch (IllegalArgumentException e) {\n                        log.warn(sm.getString(\n                                \"webappClassLoader.stopThreadFail\",\n                                thread.getName(), contextName), e);\n                    } catch (IllegalAccessException e) {\n                        log.warn(sm.getString(\n                                \"webappClassLoader.stopThreadFail\",\n                                thread.getName(), contextName), e);\n                    }\n\n                    if (usingExecutor) {\n                        // Executor may take a short time to stop all the\n                        // threads. Make a note of threads that should be\n                        // stopped and check them at the end of the method.\n                        executorThreadsToStop.add(thread);\n                    } else {\n                        // This method is deprecated and for good reason. This\n                        // is very risky code but is the only option at this\n                        // point. A *very* good reason for apps to do this\n                        // clean-up themselves.\n                        thread.stop();\n                    }\n                }\n            }\n        }\n\n        // If thread stopping is enabled, executor threads should have been\n        // stopped above when the executor was shut down but that depends on the\n        // thread correctly handling the interrupt. Give all the executor\n        // threads a few seconds shutdown and if they are still running\n        // Give threads up to 2 seconds to shutdown\n        int count = 0;\n        for (Thread t : executorThreadsToStop) {\n            while (t.isAlive() && count < 100) {\n                try {\n                    Thread.sleep(20);\n                } catch (InterruptedException e) {\n                    // Quit the while loop\n                    break;\n                }\n                count++;\n            }\n            if (t.isAlive()) {\n                // This method is deprecated and for good reason. This is\n                // very risky code but is the only option at this point.\n                // A *very* good reason for apps to do this clean-up\n                // themselves.\n                t.stop();\n            }\n        }\n    }",
                "    private boolean isRequestThread(Thread thread) {\n\n        StackTraceElement[] elements = thread.getStackTrace();\n\n        if (elements == null || elements.length == 0) {\n            // Must have stopped already. Too late to ignore it. Assume not a\n            // request processing thread.\n            return false;\n        }\n\n        // Step through the methods in reverse order looking for calls to any\n        // CoyoteAdapter method. All request threads will have this unless\n        // Tomcat has been heavily modified - in which case there isn't much we\n        // can do.\n        for (int i = 0; i < elements.length; i++) {\n            StackTraceElement element = elements[elements.length - (i+1)];\n            if (\"org.apache.catalina.connector.CoyoteAdapter\".equals(\n                    element.getClassName())) {\n                return true;\n            }\n        }\n        return false;\n    }",
                "    private void clearReferencesStopTimerThread(Thread thread) {\n\n        // Need to get references to:\n        // in Sun/Oracle JDK:\n        // - newTasksMayBeScheduled field (in java.util.TimerThread)\n        // - queue field\n        // - queue.clear()\n        // in IBM JDK, Apache Harmony:\n        // - cancel() method (in java.util.Timer$TimerImpl)\n\n        try {\n\n            try {\n                Field newTasksMayBeScheduledField =\n                    thread.getClass().getDeclaredField(\"newTasksMayBeScheduled\");\n                newTasksMayBeScheduledField.setAccessible(true);\n                Field queueField = thread.getClass().getDeclaredField(\"queue\");\n                queueField.setAccessible(true);\n\n                Object queue = queueField.get(thread);\n\n                Method clearMethod = queue.getClass().getDeclaredMethod(\"clear\");\n                clearMethod.setAccessible(true);\n\n                synchronized(queue) {\n                    newTasksMayBeScheduledField.setBoolean(thread, false);\n                    clearMethod.invoke(queue);\n                    queue.notify();  // In case queue was already empty.\n                }\n\n            }catch (NoSuchFieldException nfe){\n                Method cancelMethod = thread.getClass().getDeclaredMethod(\"cancel\");\n                synchronized(thread) {\n                    cancelMethod.setAccessible(true);\n                    cancelMethod.invoke(thread);\n                }\n            }\n\n            log.error(sm.getString(\"webappClassLoader.warnTimerThread\",\n                    contextName, thread.getName()));\n\n        } catch (Exception e) {\n            // So many things to go wrong above...\n            Throwable t = ExceptionUtils.unwrapInvocationTargetException(e);\n            ExceptionUtils.handleThrowable(t);\n            log.warn(sm.getString(\n                    \"webappClassLoader.stopTimerThreadFail\",\n                    thread.getName(), contextName), t);\n        }\n    }",
                "    private void checkThreadLocalsForLeaks() {\n        Thread[] threads = getThreads();\n\n        try {\n            // Make the fields in the Thread class that store ThreadLocals\n            // accessible\n            Field threadLocalsField =\n                Thread.class.getDeclaredField(\"threadLocals\");\n            threadLocalsField.setAccessible(true);\n            Field inheritableThreadLocalsField =\n                Thread.class.getDeclaredField(\"inheritableThreadLocals\");\n            inheritableThreadLocalsField.setAccessible(true);\n            // Make the underlying array of ThreadLoad.ThreadLocalMap.Entry objects\n            // accessible\n            Class<?> tlmClass = Class.forName(\"java.lang.ThreadLocal$ThreadLocalMap\");\n            Field tableField = tlmClass.getDeclaredField(\"table\");\n            tableField.setAccessible(true);\n            Method expungeStaleEntriesMethod = tlmClass.getDeclaredMethod(\"expungeStaleEntries\");\n            expungeStaleEntriesMethod.setAccessible(true);\n\n            for (int i = 0; i < threads.length; i++) {\n                Object threadLocalMap;\n                if (threads[i] != null) {\n\n                    // Clear the first map\n                    threadLocalMap = threadLocalsField.get(threads[i]);\n                    if (null != threadLocalMap){\n                        expungeStaleEntriesMethod.invoke(threadLocalMap);\n                        checkThreadLocalMapForLeaks(threadLocalMap, tableField);\n                    }\n\n                    // Clear the second map\n                    threadLocalMap =inheritableThreadLocalsField.get(threads[i]);\n                    if (null != threadLocalMap){\n                        expungeStaleEntriesMethod.invoke(threadLocalMap);\n                        checkThreadLocalMapForLeaks(threadLocalMap, tableField);\n                    }\n                }\n            }\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log.warn(sm.getString(\n                    \"webappClassLoader.checkThreadLocalsForLeaksFail\",\n                    getContextName()), t);\n        }\n    }",
                "    private boolean loadedByThisOrChild(Object o) {\n        if (o == null) {\n            return false;\n        }\n\n        Class<?> clazz;\n        if (o instanceof Class) {\n            clazz = (Class<?>) o;\n        } else {\n            clazz = o.getClass();\n        }\n\n        ClassLoader cl = clazz.getClassLoader();\n        while (cl != null) {\n            if (cl == this) {\n                return true;\n            }\n            cl = cl.getParent();\n        }\n\n        if (o instanceof Collection<?>) {\n            Iterator<?> iter = ((Collection<?>) o).iterator();\n            try {\n                while (iter.hasNext()) {\n                    Object entry = iter.next();\n                    if (loadedByThisOrChild(entry)) {\n                        return true;\n                    }\n                }\n            } catch (ConcurrentModificationException e) {\n                log.warn(sm.getString(\n                        \"webappClassLoader\", clazz.getName(), getContextName()),\n                        e);\n            }\n        }\n        return false;\n    }",
                "    private void clearReferencesRmiTargets() {\n        try {\n            // Need access to the ccl field of sun.rmi.transport.Target\n            Class<?> objectTargetClass =\n                Class.forName(\"sun.rmi.transport.Target\");\n            Field cclField = objectTargetClass.getDeclaredField(\"ccl\");\n            cclField.setAccessible(true);\n\n            // Clear the objTable map\n            Class<?> objectTableClass =\n                Class.forName(\"sun.rmi.transport.ObjectTable\");\n            Field objTableField = objectTableClass.getDeclaredField(\"objTable\");\n            objTableField.setAccessible(true);\n            Object objTable = objTableField.get(null);\n            if (objTable == null) {\n                return;\n            }\n\n            // Iterate over the values in the table\n            if (objTable instanceof Map<?,?>) {\n                Iterator<?> iter = ((Map<?,?>) objTable).values().iterator();\n                while (iter.hasNext()) {\n                    Object obj = iter.next();\n                    Object cclObject = cclField.get(obj);\n                    if (this == cclObject) {\n                        iter.remove();\n                    }\n                }\n            }\n\n            // Clear the implTable map\n            Field implTableField = objectTableClass.getDeclaredField(\"implTable\");\n            implTableField.setAccessible(true);\n            Object implTable = implTableField.get(null);\n            if (implTable == null) {\n                return;\n            }\n\n            // Iterate over the values in the table\n            if (implTable instanceof Map<?,?>) {\n                Iterator<?> iter = ((Map<?,?>) implTable).values().iterator();\n                while (iter.hasNext()) {\n                    Object obj = iter.next();\n                    Object cclObject = cclField.get(obj);\n                    if (this == cclObject) {\n                        iter.remove();\n                    }\n                }\n            }\n        } catch (ClassNotFoundException e) {\n            log.info(sm.getString(\"webappClassLoader.clearRmiInfo\",\n                    contextName), e);\n        } catch (SecurityException e) {\n            log.warn(sm.getString(\"webappClassLoader.clearRmiFail\",\n                    contextName), e);\n        } catch (NoSuchFieldException e) {\n            log.warn(sm.getString(\"webappClassLoader.clearRmiFail\",\n                    contextName), e);\n        } catch (IllegalArgumentException e) {\n            log.warn(sm.getString(\"webappClassLoader.clearRmiFail\",\n                    contextName), e);\n        } catch (IllegalAccessException e) {\n            log.warn(sm.getString(\"webappClassLoader.clearRmiFail\",\n                    contextName), e);\n        }\n    }",
                "    private void clearReferencesResourceBundles() {\n        // Get a reference to the cache\n        try {\n            Field cacheListField =\n                ResourceBundle.class.getDeclaredField(\"cacheList\");\n            cacheListField.setAccessible(true);\n\n            // Java 6 uses ConcurrentMap\n            // Java 5 uses SoftCache extends Abstract Map\n            // So use Map and it *should* work with both\n            Map<?,?> cacheList = (Map<?,?>) cacheListField.get(null);\n\n            // Get the keys (loader references are in the key)\n            Set<?> keys = cacheList.keySet();\n\n            Field loaderRefField = null;\n\n            // Iterate over the keys looking at the loader instances\n            Iterator<?> keysIter = keys.iterator();\n\n            int countRemoved = 0;\n\n            while (keysIter.hasNext()) {\n                Object key = keysIter.next();\n\n                if (loaderRefField == null) {\n                    loaderRefField =\n                        key.getClass().getDeclaredField(\"loaderRef\");\n                    loaderRefField.setAccessible(true);\n                }\n                WeakReference<?> loaderRef =\n                    (WeakReference<?>) loaderRefField.get(key);\n\n                ClassLoader loader = (ClassLoader) loaderRef.get();\n\n                while (loader != null && loader != this) {\n                    loader = loader.getParent();\n                }\n\n                if (loader != null) {\n                    keysIter.remove();\n                    countRemoved++;\n                }\n            }\n\n            if (countRemoved > 0 && log.isDebugEnabled()) {\n                log.debug(sm.getString(\n                        \"webappClassLoader.clearReferencesResourceBundlesCount\",\n                        Integer.valueOf(countRemoved), contextName));\n            }\n        } catch (SecurityException e) {\n            log.error(sm.getString(\n                    \"webappClassLoader.clearReferencesResourceBundlesFail\",\n                    contextName), e);\n        } catch (NoSuchFieldException e) {\n            if (Globals.IS_ORACLE_JVM) {\n                log.error(sm.getString(\n                        \"webappClassLoader.clearReferencesResourceBundlesFail\",\n                        getContextName()), e);\n            } else {\n                log.debug(sm.getString(\n                        \"webappClassLoader.clearReferencesResourceBundlesFail\",\n                        getContextName()), e);\n            }\n        } catch (IllegalArgumentException e) {\n            log.error(sm.getString(\n                    \"webappClassLoader.clearReferencesResourceBundlesFail\",\n                    contextName), e);\n        } catch (IllegalAccessException e) {\n            log.error(sm.getString(\n                    \"webappClassLoader.clearReferencesResourceBundlesFail\",\n                    contextName), e);\n        }\n    }",
                "    protected boolean openJARs() {\n        if (started && (jarFiles.length > 0)) {\n            lastJarAccessed = System.currentTimeMillis();\n            if (jarFiles[0] == null) {\n                for (int i = 0; i < jarFiles.length; i++) {\n                    try {\n                        jarFiles[i] = new JarFile(jarRealFiles[i]);\n                    } catch (IOException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Failed to open JAR\", e);\n                        }\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    protected ResourceEntry findResourceInternal(File file, String path){\n        ResourceEntry entry = new ResourceEntry();\n        try {\n            entry.source = getURI(new File(file, path));\n            entry.codeBase = entry.source;\n        } catch (MalformedURLException e) {\n            return null;\n        }\n        return entry;\n    }",
                "    protected ResourceEntry findResourceInternal(String name, String path) {\n\n        if (!started) {\n            log.info(sm.getString(\"webappClassLoader.stopped\", name));\n            return null;\n        }\n\n        if ((name == null) || (path == null))\n            return null;\n\n        ResourceEntry entry = resourceEntries.get(name);\n        if (entry != null)\n            return entry;\n\n        int contentLength = -1;\n        InputStream binaryStream = null;\n        boolean isClassResource = path.endsWith(\".class\");\n\n        int jarFilesLength = jarFiles.length;\n        int repositoriesLength = repositories.length;\n\n        int i;\n\n        Resource resource = null;\n\n        boolean fileNeedConvert = false;\n\n        for (i = 0; (entry == null) && (i < repositoriesLength); i++) {\n            try {\n\n                String fullPath = repositories[i] + path;\n\n                Object lookupResult = resources.lookup(fullPath);\n                if (lookupResult instanceof Resource) {\n                    resource = (Resource) lookupResult;\n                }\n\n                // Note : Not getting an exception here means the resource was\n                // found\n\n                ResourceAttributes attributes =\n                    (ResourceAttributes) resources.getAttributes(fullPath);\n                contentLength = (int) attributes.getContentLength();\n                String canonicalPath = attributes.getCanonicalPath();\n                if (canonicalPath != null) {\n                    // we create the ResourceEntry based on the information returned\n                    // by the DirContext rather than just using the path to the\n                    // repository. This allows to have smart DirContext implementations\n                    // that \"virtualize\" the docbase (e.g. Eclipse WTP)\n                    entry = findResourceInternal(new File(canonicalPath), \"\");\n                } else {\n                    // probably a resource not in the filesystem (e.g. in a\n                    // packaged war)\n                    entry = findResourceInternal(files[i], path);\n                }\n                entry.lastModified = attributes.getLastModified();\n\n                if (resource != null) {\n\n\n                    try {\n                        binaryStream = resource.streamContent();\n                    } catch (IOException e) {\n                        return null;\n                    }\n\n                    if (needConvert) {\n                        if (path.endsWith(\".properties\")) {\n                            fileNeedConvert = true;\n                        }\n                    }\n\n                    // Register the full path for modification checking\n                    // Note: Only syncing on a 'constant' object is needed\n                    synchronized (allPermission) {\n\n                        int j;\n\n                        long[] result2 =\n                            new long[lastModifiedDates.length + 1];\n                        for (j = 0; j < lastModifiedDates.length; j++) {\n                            result2[j] = lastModifiedDates[j];\n                        }\n                        result2[lastModifiedDates.length] = entry.lastModified;\n                        lastModifiedDates = result2;\n\n                        String[] result = new String[paths.length + 1];\n                        for (j = 0; j < paths.length; j++) {\n                            result[j] = paths[j];\n                        }\n                        result[paths.length] = fullPath;\n                        paths = result;\n\n                    }\n\n                }\n\n            } catch (NamingException e) {\n                // Ignore\n            }\n        }\n\n        if ((entry == null) && (notFoundResources.containsKey(name)))\n            return null;\n\n        JarEntry jarEntry = null;\n\n        synchronized (jarFiles) {\n\n            try {\n                if (!openJARs()) {\n                    return null;\n                }\n                for (i = 0; (entry == null) && (i < jarFilesLength); i++) {\n\n                    jarEntry = jarFiles[i].getJarEntry(path);\n\n                    if (jarEntry != null) {\n\n                        entry = new ResourceEntry();\n                        try {\n                            entry.codeBase = getURI(jarRealFiles[i]);\n                            String jarFakeUrl = entry.codeBase.toString();\n                            jarFakeUrl = \"jar:\" + jarFakeUrl + \"!/\" + path;\n                            entry.source = new URL(jarFakeUrl);\n                            entry.lastModified = jarRealFiles[i].lastModified();\n                        } catch (MalformedURLException e) {\n                            return null;\n                        }\n                        contentLength = (int) jarEntry.getSize();\n                        try {\n                            entry.manifest = jarFiles[i].getManifest();\n                            binaryStream = jarFiles[i].getInputStream(jarEntry);\n                        } catch (IOException e) {\n                            return null;\n                        }\n\n                        // Extract resources contained in JAR to the workdir\n                        if (antiJARLocking && !(path.endsWith(\".class\"))) {\n                            byte[] buf = new byte[1024];\n                            File resourceFile = new File\n                                (loaderDir, jarEntry.getName());\n                            if (!resourceFile.exists()) {\n                                Enumeration<JarEntry> entries =\n                                    jarFiles[i].entries();\n                                while (entries.hasMoreElements()) {\n                                    JarEntry jarEntry2 =  entries.nextElement();\n                                    if (!(jarEntry2.isDirectory())\n                                        && (!jarEntry2.getName().endsWith\n                                            (\".class\"))) {\n                                        resourceFile = new File\n                                            (loaderDir, jarEntry2.getName());\n                                        try {\n                                            if (!resourceFile.getCanonicalPath().startsWith(\n                                                    canonicalLoaderDir)) {\n                                                throw new IllegalArgumentException(\n                                                        sm.getString(\"webappClassLoader.illegalJarPath\",\n                                                    jarEntry2.getName()));\n                                            }\n                                        } catch (IOException ioe) {\n                                            throw new IllegalArgumentException(\n                                                    sm.getString(\"webappClassLoader.validationErrorJarPath\",\n                                                            jarEntry2.getName()), ioe);\n                                        }\n                                        File parentFile = resourceFile.getParentFile();\n                                        if (!parentFile.mkdirs() && !parentFile.exists()) {\n                                            // Ignore the error (like the IOExceptions below)\n                                        }\n                                        FileOutputStream os = null;\n                                        InputStream is = null;\n                                        try {\n                                            is = jarFiles[i].getInputStream\n                                                (jarEntry2);\n                                            os = new FileOutputStream\n                                                (resourceFile);\n                                            while (true) {\n                                                int n = is.read(buf);\n                                                if (n <= 0) {\n                                                    break;\n                                                }\n                                                os.write(buf, 0, n);\n                                            }\n                                            resourceFile.setLastModified(\n                                                    jarEntry2.getTime());\n                                        } catch (IOException e) {\n                                            // Ignore\n                                        } finally {\n                                            try {\n                                                if (is != null) {\n                                                    is.close();\n                                                }\n                                            } catch (IOException e) {\n                                                // Ignore\n                                            }\n                                            try {\n                                                if (os != null) {\n                                                    os.close();\n                                                }\n                                            } catch (IOException e) {\n                                                // Ignore\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                    }\n\n                }\n\n                if (entry == null) {\n                    synchronized (notFoundResources) {\n                        notFoundResources.put(name, name);\n                    }\n                    return null;\n                }\n\n                /* Only cache the binary content if there is some content\n                 * available and either:\n                 * a) It is a class file since the binary content is only cached\n                 *    until the class has been loaded\n                 *    or\n                 * b) The file needs conversion to address encoding issues (see\n                 *    below)\n                 *\n                 * In all other cases do not cache the content to prevent\n                 * excessive memory usage if large resources are present (see\n                 * https://issues.apache.org/bugzilla/show_bug.cgi?id=53081).\n                 */\n                if (binaryStream != null &&\n                        (isClassResource || fileNeedConvert)) {\n\n                    byte[] binaryContent = new byte[contentLength];\n\n                    int pos = 0;\n                    try {\n\n                        while (true) {\n                            int n = binaryStream.read(binaryContent, pos,\n                                                      binaryContent.length - pos);\n                            if (n <= 0)\n                                break;\n                            pos += n;\n                        }\n                    } catch (IOException e) {\n                        log.error(sm.getString(\"webappClassLoader.readError\", name), e);\n                        return null;\n                    }\n                    if (fileNeedConvert) {\n                        // Workaround for certain files on platforms that use\n                        // EBCDIC encoding, when they are read through FileInputStream.\n                        // See commit message of rev.303915 for details\n                        // http://svn.apache.org/viewvc?view=revision&revision=303915\n                        String str = new String(binaryContent,0,pos);\n                        try {\n                            binaryContent = str.getBytes(CHARSET_UTF8);\n                        } catch (Exception e) {\n                            return null;\n                        }\n                    }\n                    entry.binaryContent = binaryContent;\n\n                    // The certificates are only available after the JarEntry\n                    // associated input stream has been fully read\n                    if (jarEntry != null) {\n                        entry.certificates = jarEntry.getCertificates();\n                    }\n\n                }\n            } finally {\n                if (binaryStream != null) {\n                    try {\n                        binaryStream.close();\n                    } catch (IOException e) { /* Ignore */}\n                }\n            }\n        }\n\n        // Add the entry in the local resource repository\n        synchronized (resourceEntries) {\n            // Ensures that all the threads which may be in a race to load\n            // a particular class all end up with the same ResourceEntry\n            // instance\n            ResourceEntry entry2 = resourceEntries.get(name);\n            if (entry2 == null) {\n                resourceEntries.put(name, entry);\n            } else {\n                entry = entry2;\n            }\n        }\n\n        return entry;\n\n    }",
                "    protected boolean isPackageSealed(String name, Manifest man) {\n\n        String path = name.replace('.', '/') + '/';\n        Attributes attr = man.getAttributes(path);\n        String sealed = null;\n        if (attr != null) {\n            sealed = attr.getValue(Name.SEALED);\n        }\n        if (sealed == null) {\n            if ((attr = man.getMainAttributes()) != null) {\n                sealed = attr.getValue(Name.SEALED);\n            }\n        }\n        return \"true\".equalsIgnoreCase(sealed);\n\n    }\n\n    protected InputStream findLoadedResource(String name) {\n\n        ResourceEntry entry = resourceEntries.get(name);\n        if (entry != null) {\n            if (entry.binaryContent != null)\n                return new ByteArrayInputStream(entry.binaryContent);\n            else {\n                try {\n                    return entry.source.openStream();\n                } catch (IOException ioe) {\n                    // Ignore\n                }\n            }\n        }\n        return null;\n\n    }",
                "    protected Class<?> findLoadedClass0(String name) {\n\n        ResourceEntry entry = resourceEntries.get(name);\n        if (entry != null) {\n            return entry.loadedClass;\n        }\n        return (null);  // FIXME - findLoadedResource()\n\n    }\n\n    protected void refreshPolicy() {\n\n        try {\n            // The policy file may have been modified to adjust\n            // permissions, so we're reloading it when loading or\n            // reloading a Context\n            Policy policy = Policy.getPolicy();\n            policy.refresh();\n        } catch (AccessControlException e) {\n            // Some policy files may restrict this, even for the core,\n            // so this exception is ignored\n        }\n\n    }",
                "    protected boolean filter(String name) {\n\n        if (name == null)\n            return false;\n\n        // Looking up the package\n        String packageName = null;\n        int pos = name.lastIndexOf('.');\n        if (pos != -1)\n            packageName = name.substring(0, pos);\n        else\n            return false;\n\n        for (int i = 0; i < packageTriggers.length; i++) {\n            if (packageName.startsWith(packageTriggers[i]))\n                return true;\n        }\n\n        return false;\n\n    }",
                "    protected boolean validate(String name) {\n\n        // Need to be careful with order here\n        if (name == null) {\n            // Can't load a class without a name\n            return false;\n        }\n        if (name.startsWith(\"java.\")) {\n            // Must never load java.* classes\n            return false;\n        }\n        if (name.startsWith(\"javax.servlet.jsp.jstl\")) {\n            // OK for web apps to package JSTL\n            return true;\n        }\n        if (name.startsWith(\"javax.servlet.\")) {\n            // Web apps should never package any other Servlet or JSP classes\n            return false;\n        }\n        if (name.startsWith(\"javax.el\")) {\n            // Must never load javax.el.* classes\n            return false;\n        }\n\n        // Assume everything else is OK\n        return true;\n\n    }",
                "    protected static void deleteDir(File dir) {\n\n        String files[] = dir.list();\n        if (files == null) {\n            files = new String[0];\n        }\n        for (int i = 0; i < files.length; i++) {\n            File file = new File(dir, files[i]);\n            if (file.isDirectory()) {\n                deleteDir(file);\n            } else {\n                file.delete();\n            }\n        }\n        dir.delete();\n\n    }"
            ],
            "java\\org\\apache\\tomcat\\util\\scan\\JarFactory.java": [
                "    public static Jar newInstance(URL url) throws IOException {\n        String jarUrl = url.toString();\n        if (jarUrl.startsWith(\"jar:file:\")) {\n            return new FileUrlJar(url);\n        } else {\n            return new UrlJar(url);\n        }\n    }"
            ],
            "java\\org\\apache\\tomcat\\util\\net\\NioSelectorPool.java": [
                "    public void put(Selector s) throws IOException {\n        if ( SHARED ) return;\n        if ( enabled ) active.decrementAndGet();\n        if ( enabled && (maxSpareSelectors==-1 || spare.get() < Math.min(maxSpareSelectors,maxSelectors)) ) {\n            spare.incrementAndGet();\n            selectors.offer(s);\n        }\n        else s.close();\n    }\n\n    public void close() throws IOException {\n        enabled = false;\n        Selector s;\n        while ( (s = selectors.poll()) != null ) s.close();\n        spare.set(0);\n        active.set(0);\n        if (blockingSelector!=null) {\n            blockingSelector.close();\n        }\n        if ( SHARED && getSharedSelector()!=null ) {\n            getSharedSelector().close();\n            SHARED_SELECTOR = null;\n        }\n    }\n\n    public void open() throws IOException {\n        enabled = true;\n        getSharedSelector();\n        if (SHARED) {\n            blockingSelector = new NioBlockingSelector();\n            blockingSelector.open(getSharedSelector());\n        }\n\n    }",
                "    public int write(ByteBuffer buf, NioChannel socket, Selector selector, long writeTimeout) throws IOException {\n        return write(buf,socket,selector,writeTimeout,true);\n    }\n\n    public int read(ByteBuffer buf, NioChannel socket, Selector selector, long readTimeout) throws IOException {\n        return read(buf,socket,selector,readTimeout,true);\n    }",
                "    public int read(ByteBuffer buf, NioChannel socket, Selector selector, long readTimeout, boolean block) throws IOException {\n        if ( SHARED && block ) {\n            return blockingSelector.read(buf,socket,readTimeout);\n        }\n        SelectionKey key = null;\n        int read = 0;\n        boolean timedout = false;\n        int keycount = 1; //assume we can write\n        long time = System.currentTimeMillis(); //start the timeout timer\n        try {\n            while ( (!timedout) ) {\n                int cnt = 0;\n                if ( keycount > 0 ) { //only read if we were registered for a read\n                    cnt = socket.read(buf);\n                    if (cnt == -1) throw new EOFException();\n                    read += cnt;\n                    if (cnt > 0) continue; //read some more\n                    if (cnt==0 && (read>0 || (!block) ) ) break; //we are done reading\n                }\n                if ( selector != null ) {//perform a blocking read\n                    //register OP_WRITE to the selector\n                    if (key==null) key = socket.getIOChannel().register(selector, SelectionKey.OP_READ);\n                    else key.interestOps(SelectionKey.OP_READ);\n                    keycount = selector.select(readTimeout);\n                }\n                if (readTimeout > 0 && (selector == null || keycount == 0) ) timedout = (System.currentTimeMillis()-time)>=readTimeout;\n            }//while\n            if ( timedout ) throw new SocketTimeoutException();\n        } finally {\n            if (key != null) {\n                key.cancel();\n                if (selector != null) selector.selectNow();//removes the key from this selector\n            }\n        }\n        return read;\n    }"
            ],
            "java\\org\\apache\\catalina\\filters\\CsrfPreventionFilter.java": [
                "    public void init(FilterConfig filterConfig) throws ServletException {\n        // Set the parameters\n        super.init(filterConfig);\n\n        try {\n            Class<?> clazz = Class.forName(randomClass);\n            randomSource = (Random) clazz.newInstance();\n        } catch (ClassNotFoundException e) {\n            ServletException se = new ServletException(sm.getString(\n                    \"csrfPrevention.invalidRandomClass\", randomClass), e);\n            throw se;\n        } catch (InstantiationException e) {\n            ServletException se = new ServletException(sm.getString(\n                    \"csrfPrevention.invalidRandomClass\", randomClass), e);\n            throw se;\n        } catch (IllegalAccessException e) {\n            ServletException se = new ServletException(sm.getString(\n                    \"csrfPrevention.invalidRandomClass\", randomClass), e);\n            throw se;\n        }\n    }",
                "    protected String generateNonce() {\n        byte random[] = new byte[16];\n\n        // Render the result as a String of hexadecimal digits\n        StringBuilder buffer = new StringBuilder();\n\n        randomSource.nextBytes(random);\n\n        for (int j = 0; j < random.length; j++) {\n            byte b1 = (byte) ((random[j] & 0xf0) >> 4);\n            byte b2 = (byte) (random[j] & 0x0f);\n            if (b1 < 10) {\n                buffer.append((char) ('0' + b1));\n            } else {\n                buffer.append((char) ('A' + (b1 - 10)));\n            }\n            if (b2 < 10) {\n                buffer.append((char) ('0' + b2));\n            } else {\n                buffer.append((char) ('A' + (b2 - 10)));\n            }\n        }\n\n        return buffer.toString();\n    }"
            ],
            "test\\org\\apache\\catalina\\ha\\session\\TestSerializablePrincipal.java": [
                "    public void testWriteReadPrincipal() {\n        // Get a temporary file to use for the serialization test\n        File file = null;\n        try {\n            file = File.createTempFile(\"ser\", null);\n            file.deleteOnExit();\n        } catch (IOException e) {\n            e.printStackTrace();\n            fail(\"ioe creating temporary file\");\n        }\n\n        // Create the Principal to serialize\n        List<String> roles = new ArrayList<String>();\n        roles.add(\"RoleA\");\n        roles.add(\"RoleB\");\n        TesterPrincipal tpOriginal = new TesterPrincipal(\"inner\");\n        GenericPrincipal gpOriginal =\n            new GenericPrincipal(\"usr\", \"pwd\", roles, tpOriginal);\n\n        // Do the serialization\n        try {\n            FileOutputStream fos = new FileOutputStream(file);\n            ObjectOutputStream oos = new ObjectOutputStream(fos);\n            SerializablePrincipal.writePrincipal(gpOriginal, oos);\n            oos.close();\n            fos.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            fail(\"fnfe creating object output stream\");\n        } catch (IOException e) {\n            e.printStackTrace();\n            fail(\"ioe serializing principal\");\n        }\n\n        // De-serialize the Principal\n        GenericPrincipal gpNew = null;\n        try {\n            FileInputStream fis = new FileInputStream(file);\n            ObjectInputStream ois = new ObjectInputStream(fis);\n            gpNew = SerializablePrincipal.readPrincipal(ois);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            fail(\"fnfe reading object output stream\");\n        } catch (IOException e) {\n            e.printStackTrace();\n            fail(\"ioe de-serializing principal\");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            fail(\"cnfe de-serializing principal\");\n        }\n\n        // Now test how similar original and de-serialized versions are\n        assertEquals(\"User names different\", gpOriginal.getName(),\n                gpNew.getName());\n        assertEquals(\"Passwords different\", gpOriginal.getPassword(),\n                gpNew.getPassword());\n        assertEquals(\"Number of roles different\", gpOriginal.getRoles().length,\n                gpNew.getRoles().length);\n        for (int i = 0; i < gpOriginal.getRoles().length; i++) {\n            assertEquals(\"Role name index \" + i + \"different\",\n                    gpOriginal.getRoles()[i], gpNew.getRoles()[i]);\n        }\n        // These are the key tests for bug 43840\n        assertNotSame(\"Inner principal not present\", gpNew,\n                gpNew.getUserPrincipal());\n        assertEquals(\"Inner user names are different\", tpOriginal.getName(),\n                gpNew.getUserPrincipal().getName());\n    }"
            ],
            "modules\\jdbc-pool\\src\\test\\java\\org\\apache\\tomcat\\jdbc\\test\\TestSizePreservation.java": [
                "    private void initSimplePoolProperties() {\n        PoolConfiguration p = new DefaultProperties();\n        ds = new org.apache.tomcat.jdbc.pool.DataSource();\n        ds.setPoolProperties(p);\n\n        ds.getPoolProperties().setDriverClassName(Driver.class.getName());\n        ds.getPoolProperties().setUrl(Driver.url);\n        ds.getPoolProperties().setFairQueue(true);\n        ds.getPoolProperties().setJmxEnabled(false);\n        ds.getPoolProperties().setTestWhileIdle(true);\n        ds.getPoolProperties().setTestOnBorrow(false);\n        ds.getPoolProperties().setTestOnReturn(false);\n        ds.getPoolProperties().setValidationInterval(30000);\n        ds.getPoolProperties().setTimeBetweenEvictionRunsMillis(30000);\n        ds.getPoolProperties().setInitialSize(100);\n        ds.getPoolProperties().setMaxActive(100);\n        ds.getPoolProperties().setMinIdle(0);\n        ds.getPoolProperties().setMaxIdle(0);\n        ds.getPoolProperties().setMaxWait(10000);\n        ds.getPoolProperties().setRemoveAbandonedTimeout(10);\n        ds.getPoolProperties().setMinEvictableIdleTimeMillis(10000);\n        ds.getPoolProperties().setLogAbandoned(false);\n        ds.getPoolProperties().setRemoveAbandoned(false);\n        ds.getPoolProperties().setUseLock(true);\n    }\n\n    public void testSimple() throws Exception {\n        initSimplePoolProperties();\n        common();\n        ds.close(true);\n        Driver.reset();\n    }\n\n    public void testEvicting() throws Exception {\n        initEvictingPool();\n        common();\n        ds.close(true);\n        Driver.reset();\n    }",
                "    private void common() throws Exception {\n        ds.getConnection().close();\n        final int iterations = 1000;\n        final AtomicInteger loopcount = new AtomicInteger(0);\n        final Runnable run = new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    while (loopcount.incrementAndGet() < iterations) {\n                        Connection c = ds.getConnection();\n                        Thread.sleep(1000);\n                        c.close();\n                    }\n                } catch (Exception x) {\n                    x.printStackTrace();\n                }\n            }\n        };\n        Thread[] threads = new Thread[200];\n        for (int i = 0; i < threads.length; i++) {\n            threads[i] = new Thread(run);\n        }\n        for (int i = 0; i < threads.length; i++) {\n            threads[i].start();\n        }\n        try {\n            while (loopcount.get() < iterations) {\n                Thread.sleep(250);\n            }\n        } catch (Exception x) {\n            loopcount.set(iterations); // stops the test\n            x.printStackTrace();\n        }\n        for (int i = 0; i < threads.length; i++) {\n            threads[i].join();\n        }\n        System.out.println(\"Pool size:\"+ds.getPool().getSize());\n        Assert.assertTrue(\"Size validity check: \", ds.getPool().getSize() >= 0);\n    }"
            ],
            "test\\org\\apache\\catalina\\tribes\\group\\interceptors\\TestOrderInterceptor.java": [
                "    public void testOrder1() throws Exception {\n        Member[] dest = channels[0].getMembers();\n        final AtomicInteger value = new AtomicInteger(0);\n        for ( int i=0; i<100; i++ ) {\n            channels[0].send(dest,Integer.valueOf(value.getAndAdd(1)),0);\n        }\n        Thread.sleep(5000);\n        for ( int i=0; i<test.length; i++ ) {\n            assertFalse(test[i].fail);\n        }\n    }",
                "    public void testOrder2() throws Exception {\n        final Member[] dest = channels[0].getMembers();\n        final AtomicInteger value = new AtomicInteger(0);\n        final Queue<Exception> exceptionQueue = new ConcurrentLinkedQueue<Exception>();\n        Runnable run = new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 100; i++) {\n                    try {\n                        synchronized (channels[0]) {\n                            channels[0].send(dest, Integer.valueOf(value.getAndAdd(1)), 0);\n                        }\n                    }catch ( Exception x ) {\n                        exceptionQueue.add(x);\n                    }\n                }\n            }\n        };\n        Thread[] threads = new Thread[5];\n        for (int i=0;i<threads.length;i++) {\n            threads[i] = new Thread(run);\n        }\n        for (int i=0;i<threads.length;i++) {\n            threads[i].start();\n        }\n        for (int i=0;i<threads.length;i++) {\n            threads[i].join();\n        }\n        if (!exceptionQueue.isEmpty()) {\n            fail(\"Exception while sending in threads: \"\n                    + exceptionQueue.remove().toString());\n        }\n        Thread.sleep(5000);\n        for ( int i=0; i<test.length; i++ ) {\n            assertFalse(test[i].fail);\n        }\n    }",
                "    public void tearDown() throws Exception {\n        System.out.println(\"tearDown\");\n        for ( int i=0; i<channelCount; i++ ) {\n            channels[i].stop(Channel.DEFAULT);\n        }\n    }"
            ],
            "java\\org\\apache\\tomcat\\util\\scan\\Jar.java": [
                "    boolean entryExists(String name) throws IOException;"
            ],
            "test\\javax\\el\\TestBeanELResolverVarargsInvocation.java": [
                "    public void testJoinDelimited() {\n        Assert.assertEquals(foo.joinDelimited(\"-\", \"foo\", \"bar\", \"baz\"),\n            beanELResolver.invoke(elContext, foo, \"joinDelimited\", null,\n                    new Object[] { \"-\", \"foo\", \"bar\", \"baz\" }));\n    }\n\n    public void testJoin() {\n        Assert.assertEquals(foo.join(\"foo\", \"bar\", \"baz\"),\n            beanELResolver.invoke(elContext, foo, \"join\", null,\n                    new Object[] { \"foo\", \"bar\", \"baz\" }));\n    }"
            ],
            "webapps\\examples\\WEB-INF\\classes\\cal\\TableBean.java": [
                "    public void processRequest(HttpServletRequest request) {\n\n        // Get the name and e-mail.\n        this.processError = false;\n        if (name == null || name.equals(\"\"))\n            setName(request.getParameter(\"name\"));\n        if (email == null || email.equals(\"\"))\n            setEmail(request.getParameter(\"email\"));\n        if (name == null || email == null || name.equals(\"\")\n                || email.equals(\"\")) {\n            this.processError = true;\n            return;\n        }\n\n        // Get the date.\n        String dateR = request.getParameter(\"date\");\n        if (dateR == null)\n            date = JspCal.getCurrentDate();\n        else if (dateR.equalsIgnoreCase(\"next\"))\n            date = JspCal.getNextDate();\n        else if (dateR.equalsIgnoreCase(\"prev\"))\n            date = JspCal.getPrevDate();\n\n        entries = table.get(date);\n        if (entries == null) {\n            entries = new Entries();\n            table.put(date, entries);\n        }\n\n        // If time is provided add the event.\n        String time = request.getParameter(\"time\");\n        if (time != null)\n            entries.processRequest(request, time);\n    }"
            ],
            "java\\org\\apache\\tomcat\\util\\http\\parser\\MediaTypeCache.java": [
                "    public String[] parse(String input) {\n        String[] result = cache.get(input);\n\n        if (result != null) {\n            return result;\n        }\n\n        MediaType m = null;\n        try {\n            m = HttpParser.parseMediaType(new StringReader(input));\n        } catch (IOException e) {\n            // Ignore - return null\n        }\n        if (m != null) {\n            result = new String[] {m.toStringNoCharset(), m.getCharset()};\n            cache.put(input, result);\n        }\n\n        return result;\n    }"
            ]
        }
    },
    "56025": {
        "summary": "Bug 56025 Order of invocation of method of ServerEndpointConfig.Configurator",
        "code_segments": {
            "java\\org\\apache\\tomcat\\websocket\\server\\WsServerContainer.java": [
                "    public void addEndpoint(Class<?> pojo) throws DeploymentException {\n\n        ServerEndpoint annotation = pojo.getAnnotation(ServerEndpoint.class);\n        if (annotation == null) {\n            throw new DeploymentException(\n                    sm.getString(\"serverContainer.missingAnnotation\",\n                            pojo.getName()));\n        }\n        String path = annotation.value();\n\n        // Validate encoders\n        validateEncoders(annotation.encoders());\n\n        // Method mapping\n        PojoMethodMapping methodMapping = new PojoMethodMapping(pojo,\n                annotation.decoders(), path);\n\n        // ServerEndpointConfig\n        ServerEndpointConfig sec;\n        Class<? extends Configurator> configuratorClazz =\n                annotation.configurator();\n        Configurator configurator = null;\n        if (!configuratorClazz.equals(Configurator.class)) {\n            try {\n                configurator = annotation.configurator().newInstance();\n            } catch (InstantiationException e) {\n                throw new DeploymentException(sm.getString(\n                        \"serverContainer.configuratorFail\",\n                        annotation.configurator().getName(),\n                        pojo.getClass().getName()), e);\n            } catch (IllegalAccessException e) {\n                throw new DeploymentException(sm.getString(\n                        \"serverContainer.configuratorFail\",\n                        annotation.configurator().getName(),\n                        pojo.getClass().getName()), e);\n            }\n        }\n        sec = ServerEndpointConfig.Builder.create(pojo, path).\n                decoders(Arrays.asList(annotation.decoders())).\n                encoders(Arrays.asList(annotation.encoders())).\n                subprotocols(Arrays.asList(annotation.subprotocols())).\n                configurator(configurator).\n                build();\n        sec.getUserProperties().put(\n                PojoEndpointServer.POJO_METHOD_MAPPING_KEY,\n                methodMapping);\n\n        addEndpoint(sec);\n    }",
                "    public WsMappingResult findMapping(String path) {\n\n        // Prevent registering additional endpoints once the first attempt has\n        // been made to use one\n        if (addAllowed) {\n            addAllowed = false;\n        }\n\n        // Check an exact match. Simple case as there are no templates.\n        ServerEndpointConfig sec = configExactMatchMap.get(path);\n        if (sec != null) {\n            return new WsMappingResult(sec,\n                    Collections.<String, String> emptyMap());\n        }\n\n        // No exact match. Need to look for template matches.\n        UriTemplate pathUriTemplate = null;\n        try {\n            pathUriTemplate = new UriTemplate(path);\n        } catch (DeploymentException e) {\n            // Path is not valid so can't be matched to a WebSocketEndpoint\n            return null;\n        }\n\n        // Number of segments has to match\n        Integer key = Integer.valueOf(pathUriTemplate.getSegmentCount());\n        SortedSet<TemplatePathMatch> templateMatches =\n                configTemplateMatchMap.get(key);\n\n        if (templateMatches == null) {\n            // No templates with an equal number of segments so there will be\n            // no matches\n            return null;\n        }\n\n        // List is in alphabetical order of normalised templates.\n        // Correct match is the first one that matches.\n        Map<String,String> pathParams = null;\n        for (TemplatePathMatch templateMatch : templateMatches) {\n            pathParams = templateMatch.getUriTemplate().match(pathUriTemplate);\n            if (pathParams != null) {\n                sec = templateMatch.getConfig();\n                break;\n            }\n        }\n\n        if (sec == null) {\n            // No match\n            return null;\n        }\n\n        if (!PojoEndpointServer.class.isAssignableFrom(sec.getEndpointClass())) {\n            // Need to make path params available to POJO\n            sec.getUserProperties().put(\n                    PojoEndpointServer.POJO_PATH_PARAM_KEY,\n                    pathParams);\n        }\n\n        return new WsMappingResult(sec, pathParams);\n    }",
                "    protected void registerSession(Endpoint endpoint, WsSession wsSession) {\n        super.registerSession(endpoint, wsSession);\n        if (wsSession.isOpen() &&\n                wsSession.getUserPrincipal() != null &&\n                wsSession.getHttpSessionId() != null) {\n            registerAuthenticatedSession(wsSession,\n                    wsSession.getHttpSessionId());\n        }\n    }\n\n    protected void unregisterSession(Endpoint endpoint, WsSession wsSession) {\n        if (wsSession.getUserPrincipal() != null &&\n                wsSession.getHttpSessionId() != null) {\n            unregisterAuthenticatedSession(wsSession,\n                    wsSession.getHttpSessionId());\n        }\n        super.unregisterSession(endpoint, wsSession);\n    }\n\n    public void closeAuthenticatedSession(String httpSessionId) {\n        Set<WsSession> wsSessions = authenticatedSessions.remove(httpSessionId);\n\n        if (wsSessions != null && !wsSessions.isEmpty()) {\n            for (WsSession wsSession : wsSessions) {\n                try {\n                    wsSession.close(AUTHENTICATED_HTTP_SESSION_CLOSED);\n                } catch (IOException e) {\n                    // Any IOExceptions during close will have been caught and the\n                    // onError method called.\n                }\n            }\n        }\n    }",
                "    void shutdownExecutor() {\n        if (executorService == null) {\n            return;\n        }\n        executorService.shutdown();\n        try {\n            executorService.awaitTermination(10, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            // Ignore the interruption and carry on\n        }\n    }"
            ],
            "java\\org\\apache\\coyote\\http11\\upgrade\\UpgradeBioProcessor.java": [
                "    public void flush() throws IOException {\n        outputStream.flush();\n    }\n\n    public void write(int b) throws IOException {\n        outputStream.write(b);\n    }\n\n    public void write(byte[]b, int off, int len) throws IOException {\n        outputStream.write(b, off, len);\n    }",
                "    public int read() throws IOException {\n        return inputStream.read();\n    }"
            ],
            "java\\org\\apache\\coyote\\http11\\AbstractHttp11JsseProtocol.java": [
                "    public void init() throws Exception {\n        // SSL implementation needs to be in place before end point is\n        // initialized\n        sslImplementation = SSLImplementation.getInstance(sslImplementationName);\n        super.init();\n    }"
            ],
            "java\\org\\apache\\tomcat\\websocket\\server\\WsRemoteEndpointImplServer.java": [
                "    protected void doWrite(SendHandler handler, ByteBuffer... buffers) {\n        this.handler = handler;\n        this.buffers = buffers;\n        // This is definitely the same thread that triggered the write so a\n        // dispatch will be required.\n        onWritePossible(true);\n    }",
                "    public void onWritePossible(boolean useDispatch) {\n        boolean complete = true;\n        try {\n            // If this is false there will be a call back when it is true\n            while (sos.isReady()) {\n                complete = true;\n                for (ByteBuffer buffer : buffers) {\n                    if (buffer.hasRemaining()) {\n                        complete = false;\n                        sos.write(buffer.array(), buffer.arrayOffset(),\n                                buffer.limit());\n                        buffer.position(buffer.limit());\n                        break;\n                    }\n                }\n                if (complete) {\n                    wsWriteTimeout.unregister(this);\n                    clearHandler(null, useDispatch);\n                    if (close) {\n                        close();\n                    }\n                    break;\n                }\n            }\n\n        } catch (IOException ioe) {\n            wsWriteTimeout.unregister(this);\n            clearHandler(ioe, useDispatch);\n            close();\n        }\n        if (!complete) {\n            // Async write is in progress\n\n            long timeout = getSendTimeout();\n            if (timeout > 0) {\n                // Register with timeout thread\n                timeoutExpiry = timeout + System.currentTimeMillis();\n                wsWriteTimeout.register(this);\n            }\n        }\n    }",
                "    protected void doClose() {\n        if (handler != null) {\n            // close() can be triggered by a wide range of scenarios. It is far\n            // simpler just to always use a dispatch than it is to try and track\n            // whether or not this method was called by the same thread that\n            // triggered the write\n            clearHandler(new EOFException(), true);\n        }\n        try {\n            sos.close();\n        } catch (IOException e) {\n            if (log.isInfoEnabled()) {\n                log.info(sm.getString(\"wsRemoteEndpointServer.closeFailed\"), e);\n            }\n        }\n        wsWriteTimeout.unregister(this);\n    }\n\n    protected void onTimeout(boolean useDispatch) {\n        if (handler != null) {\n            clearHandler(new SocketTimeoutException(), useDispatch);\n        }\n        close();\n    }",
                "    private void clearHandler(Throwable t, boolean useDispatch) {\n        // Setting the result marks this (partial) message as\n        // complete which means the next one may be sent which\n        // could update the value of the handler. Therefore, keep a\n        // local copy before signalling the end of the (partial)\n        // message.\n        SendHandler sh = handler;\n        handler = null;\n        if (sh != null) {\n            if (useDispatch) {\n                OnResultRunnable r = onResultRunnables.poll();\n                if (r == null) {\n                    r = new OnResultRunnable(onResultRunnables);\n                }\n                r.init(sh, t);\n                if (executorService == null || executorService.isShutdown()) {\n                    // Can't use the executor so call the runnable directly.\n                    // This may not be strictly specification compliant in all\n                    // cases but during shutdown only close messages are going\n                    // to be sent so there should not be the issue of nested\n                    // calls leading to stack overflow as described in bug\n                    // 55715. The issues with nested calls was the reason for\n                    // the separate thread requirement in the specification.\n                    r.run();\n                } else {\n                    executorService.execute(r);\n                }\n            } else {\n                if (t == null) {\n                    sh.onResult(new SendResult());\n                } else {\n                    sh.onResult(new SendResult(t));\n                }\n            }\n        }\n    }"
            ],
            "java\\org\\apache\\tomcat\\websocket\\pojo\\PojoEndpointServer.java": [
                "    public void onOpen(Session session, EndpointConfig endpointConfig) {\n\n        ServerEndpointConfig sec = (ServerEndpointConfig) endpointConfig;\n\n        Object pojo;\n        try {\n            pojo = sec.getConfigurator().getEndpointInstance(\n                    sec.getEndpointClass());\n        } catch (InstantiationException e) {\n            throw new IllegalArgumentException(sm.getString(\n                    \"pojoEndpointServer.getPojoInstanceFail\",\n                    sec.getEndpointClass().getName()), e);\n        }\n        setPojo(pojo);\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String,String> pathParameters =\n                (Map<String, String>) sec.getUserProperties().get(\n                        POJO_PATH_PARAM_KEY);\n        setPathParameters(pathParameters);\n\n        PojoMethodMapping methodMapping =\n                (PojoMethodMapping) sec.getUserProperties().get(\n                        POJO_METHOD_MAPPING_KEY);\n        setMethodMapping(methodMapping);\n\n        doOnOpen(session, endpointConfig);\n    }"
            ],
            "java\\org\\apache\\tomcat\\websocket\\pojo\\PojoEndpointBase.java": [
                "    protected final void doOnOpen(Session session, EndpointConfig config) {\n        PojoMethodMapping methodMapping = getMethodMapping();\n        Object pojo = getPojo();\n        Map<String,String> pathParameters = getPathParameters();\n\n        if (methodMapping.getOnOpen() != null) {\n            try {\n                methodMapping.getOnOpen().invoke(pojo,\n                        methodMapping.getOnOpenArgs(\n                                pathParameters, session, config));\n\n            } catch (IllegalAccessException e) {\n                // Reflection related problems\n                log.error(sm.getString(\n                        \"pojoEndpointBase.onOpenFail\",\n                        pojo.getClass().getName()), e);\n                handleOnOpenError(session, e);\n                return;\n            } catch (InvocationTargetException e) {\n                Throwable cause = e.getCause();\n                handleOnOpenError(session, cause);\n                return;\n            } catch (Throwable t) {\n                handleOnOpenError(session, t);\n                return;\n            }\n        }\n\n        for (MessageHandler mh : methodMapping.getMessageHandlers(pojo,\n                pathParameters, session, config)) {\n            session.addMessageHandler(mh);\n        }\n    }",
                "    private void handleOnOpenError(Session session, Throwable t) {\n        // If really fatal - re-throw\n        ExceptionUtils.handleThrowable(t);\n\n        // Trigger the error handler and close the session\n        onError(session, t);\n        try {\n            session.close();\n        } catch (IOException ioe) {\n            log.warn(sm.getString(\"pojoEndpointBase.closeSessionFail\"), ioe);\n        }\n    }\n\n    public final void onClose(Session session, CloseReason closeReason) {\n\n        if (methodMapping.getOnClose() != null) {\n            try {\n                methodMapping.getOnClose().invoke(pojo,\n                        methodMapping.getOnCloseArgs(pathParameters, session, closeReason));\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.error(sm.getString(\"pojoEndpointBase.onCloseFail\",\n                        pojo.getClass().getName()), t);\n            }\n        }\n\n        // Trigger the destroy method for any associated decoders\n        Set<MessageHandler> messageHandlers = session.getMessageHandlers();\n        for (MessageHandler messageHandler : messageHandlers) {\n            if (messageHandler instanceof PojoMessageHandlerWholeBase<?>) {\n                ((PojoMessageHandlerWholeBase<?>) messageHandler).onClose();\n            }\n        }\n    }",
                "    public final void onError(Session session, Throwable throwable) {\n\n        if (methodMapping.getOnError() == null) {\n            log.error(sm.getString(\"pojoEndpointBase.onError\",\n                    pojo.getClass().getName()), throwable);\n        } else {\n            try {\n                methodMapping.getOnError().invoke(\n                        pojo,\n                        methodMapping.getOnErrorArgs(pathParameters, session,\n                                throwable));\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.error(sm.getString(\"pojoEndpointBase.onErrorFail\",\n                        pojo.getClass().getName()), t);\n            }\n        }\n    }"
            ],
            "java\\org\\apache\\tomcat\\websocket\\server\\WsWriteTimeout.java": [
                "    public void backgroundProcess() {\n        // This method gets called once a second.\n        backgroundProcessCount ++;\n\n        if (backgroundProcessCount >= processPeriod) {\n            backgroundProcessCount = 0;\n\n            long now = System.currentTimeMillis();\n            Iterator<WsRemoteEndpointImplServer> iter = endpoints.iterator();\n            while (iter.hasNext()) {\n                WsRemoteEndpointImplServer endpoint = iter.next();\n                if (endpoint.getTimeoutExpiry() < now) {\n                    // Background thread, not the thread that triggered the\n                    // write so no need to use a dispatch\n                    endpoint.onTimeout(false);\n                } else {\n                    // Endpoints are ordered by timeout expiry so if this point\n                    // is reached there is no need to check the remaining\n                    // endpoints\n                    break;\n                }\n            }\n        }\n    }\n\n    public void register(WsRemoteEndpointImplServer endpoint) {\n        boolean result = endpoints.add(endpoint);\n        if (result) {\n            int newCount = count.incrementAndGet();\n            if (newCount == 1) {\n                BackgroundProcessManager.getInstance().register(this);\n            }\n        }\n    }",
                "    public void unregister(WsRemoteEndpointImplServer endpoint) {\n        boolean result = endpoints.remove(endpoint);\n        if (result) {\n            int newCount = count.decrementAndGet();\n            if (newCount == 0) {\n                BackgroundProcessManager.getInstance().unregister(this);\n            }\n        }\n    }"
            ],
            "test\\org\\apache\\catalina\\core\\TestApplicationContext.java": [
                "    public void testBug53257() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        File appDir = new File(\"test/webapp-3.0\");\n        // app dir is relative to server home\n        tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());\n\n        tomcat.start();\n\n        ByteChunk res = getUrl(\"http://localhost:\" + getPort() +\n                \"/test/bug53257/index.jsp\");\n\n        String result = res.toString();\n        String[] lines = result.split(\"\\n\");\n        for (String line : lines) {\n            if (line.startsWith(\"FAIL\")) {\n                Assert.fail(line);\n            }\n        }\n    }\n\n    public void testBug53467() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        File appDir = new File(\"test/webapp-3.0\");\n        // app dir is relative to server home\n        tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());\n\n        tomcat.start();\n\n        ByteChunk res = new ByteChunk();\n        int rc = getUrl(\"http://localhost:\" + getPort() +\n                \"/test/bug5nnnn/bug53467].jsp\", res, null);\n\n        Assert.assertEquals(HttpServletResponse.SC_OK, rc);\n        Assert.assertTrue(res.toString().contains(\"<p>OK</p>\"));\n    }",
                "    public void testGetJspConfigDescriptor() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        File appDir = new File(\"test/webapp-3.0\");\n        // app dir is relative to server home\n        StandardContext standardContext = (StandardContext) tomcat.addWebapp(\n                null, \"/test\", appDir.getAbsolutePath());\n\n        ServletContext servletContext = standardContext.getServletContext();\n\n        Assert.assertNull(servletContext.getJspConfigDescriptor());\n\n        tomcat.start();\n\n        Assert.assertNotNull(servletContext.getJspConfigDescriptor());\n    }"
            ],
            "java\\org\\apache\\catalina\\ssi\\SSIFilter.java": [
                "    public void init(FilterConfig config) throws ServletException {\n        this.config = config;\n        \n        if (config.getInitParameter(\"debug\") != null) {\n            debug = Integer.parseInt(config.getInitParameter(\"debug\"));\n        }\n\n        if (config.getInitParameter(\"contentType\") != null) {\n            contentTypeRegEx = Pattern.compile(config.getInitParameter(\"contentType\"));\n        } else {\n            contentTypeRegEx = shtmlRegEx;\n        }\n\n        isVirtualWebappRelative = \n            Boolean.parseBoolean(config.getInitParameter(\"isVirtualWebappRelative\"));\n\n        if (config.getInitParameter(\"expires\") != null)\n            expires = Long.valueOf(config.getInitParameter(\"expires\"));\n\n        allowExec = Boolean.parseBoolean(config.getInitParameter(\"allowExec\"));\n\n        if (debug > 0)\n            config.getServletContext().log(\n                    \"SSIFilter.init() SSI invoker started with 'debug'=\" + debug);\n    }"
            ],
            "java\\org\\apache\\tomcat\\websocket\\pojo\\PojoMethodMapping.java": [
                "    private void checkPublic(Method m) throws DeploymentException {\n        if (!Modifier.isPublic(m.getModifiers())) {\n            throw new DeploymentException(sm.getString(\n                    \"pojoMethodMapping.methodNotPublic\", m.getName()));\n        }\n    }"
            ],
            "test\\org\\apache\\tomcat\\util\\net\\TestCustomSsl.java": [
                "    public void testCustomSslImplementation() throws Exception {\n\n        TesterSupport.configureClientSsl();\n\n        Tomcat tomcat = getTomcatInstance();\n        Connector connector = tomcat.getConnector();\n        if (connector.getProtocolHandlerClassName().contains(\"Apr\")) {\n            // This test is only for JSSE based SSL connectors\n            return;\n        }\n\n        connector.setProperty(\"sslImplementationName\",\n                \"org.apache.tomcat.util.net.jsse.TesterBug50640SslImpl\");\n        connector.setProperty(TesterBug50640SslImpl.PROPERTY_NAME,\n                TesterBug50640SslImpl.PROPERTY_VALUE);\n\n        connector.setProperty(\"sslProtocol\", \"tls\");\n\n        File keystoreFile =\n            new File(\"test/org/apache/tomcat/util/net/localhost.jks\");\n        connector.setAttribute(\n                \"keystoreFile\", keystoreFile.getAbsolutePath());\n\n        connector.setSecure(true);\n        connector.setProperty(\"SSLEnabled\", \"true\");\n\n        File appDir = new File(getBuildDirectory(), \"webapps/examples\");\n        tomcat.addWebapp(null, \"/examples\", appDir.getAbsolutePath());\n\n        tomcat.start();\n        ByteChunk res = getUrl(\"https://localhost:\" + getPort() +\n            \"/examples/servlets/servlet/HelloWorldExample\");\n        assertTrue(res.toString().indexOf(\"<h1>Hello World!</h1>\") > 0);\n    }"
            ],
            "java\\org\\apache\\el\\util\\ReflectionUtil.java": [
                "    public static Class<?> forName(String name) throws ClassNotFoundException {\n        if (null == name || \"\".equals(name)) {\n            return null;\n        }\n        Class<?> c = forNamePrimitive(name);\n        if (c == null) {\n            if (name.endsWith(\"[]\")) {\n                String nc = name.substring(0, name.length() - 2);\n                c = Class.forName(nc, true, Thread.currentThread().getContextClassLoader());\n                c = Array.newInstance(c, 0).getClass();\n            } else {\n                c = Class.forName(name, true, Thread.currentThread().getContextClassLoader());\n            }\n        }\n        return c;\n    }\n\n    protected static Class<?> forNamePrimitive(String name) {\n        if (name.length() <= 8) {\n            int p = Arrays.binarySearch(PRIMITIVE_NAMES, name);\n            if (p >= 0) {\n                return PRIMITIVES[p];\n            }\n        }\n        return null;\n    }\n\n    public static Class<?>[] toTypeArray(String[] s) throws ClassNotFoundException {\n        if (s == null)\n            return null;\n        Class<?>[] c = new Class[s.length];\n        for (int i = 0; i < s.length; i++) {\n            c[i] = forName(s[i]);\n        }\n        return c;\n    }",
                "    public static String[] toTypeNameArray(Class<?>[] c) {\n        if (c == null)\n            return null;\n        String[] s = new String[c.length];\n        for (int i = 0; i < c.length; i++) {\n            s[i] = c[i].getName();\n        }\n        return s;\n    }\n\n    private static boolean isAssignableFrom(Class<?> src, Class<?> target) {\n        // Short-cut. null is always assignable to an object and in EL null\n        // can always be coerced to a valid value for a primitive\n        if (src == null) {\n            return true;\n        }\n\n        Class<?> targetClass;\n        if (target.isPrimitive()) {\n            if (target == Boolean.TYPE) {\n                targetClass = Boolean.class;\n            } else if (target == Character.TYPE) {\n                targetClass = Character.class;\n            } else if (target == Byte.TYPE) {\n                targetClass = Byte.class;\n            } else if (target == Short.TYPE) {\n                targetClass = Short.class;\n            } else if (target == Integer.TYPE) {\n                targetClass = Integer.class;\n            } else if (target == Long.TYPE) {\n                targetClass = Long.class;\n            } else if (target == Float.TYPE) {\n                targetClass = Float.class;\n            } else {\n                targetClass = Double.class;\n            }\n        } else {\n            targetClass = target;\n        }\n        return targetClass.isAssignableFrom(src);\n    }",
                "    private static boolean isCoercibleFrom(Object src, Class<?> target) {\n        // TODO: This isn't pretty but it works. Significant refactoring would\n        //       be required to avoid the exception.\n        try {\n            ELSupport.coerceToType(src, target);\n        } catch (ELException e) {\n            return false;\n        }\n        return true;\n    }\n\n    protected static final String paramString(Class<?>[] types) {\n        if (types != null) {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < types.length; i++) {\n                if (types[i] == null) {\n                    sb.append(\"null, \");\n                } else {\n                    sb.append(types[i].getName()).append(\", \");\n                }\n            }\n            if (sb.length() > 2) {\n                sb.setLength(sb.length() - 2);\n            }\n            return sb.toString();\n        }\n        return null;\n    }"
            ],
            "java\\org\\apache\\tomcat\\websocket\\server\\WsHttpUpgradeHandler.java": [
                "    public void init(WebConnection connection) {\n        if (ep == null) {\n            throw new IllegalStateException(\n                    sm.getString(\"wsHttpUpgradeHandler.noPreInit\"));\n        }\n\n        this.connection = connection;\n\n        AbstractServletInputStream sis;\n        AbstractServletOutputStream sos;\n        try {\n            sis = connection.getInputStream();\n            sos = connection.getOutputStream();\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n\n        String httpSessionId = null;\n        Object session = handshakeRequest.getHttpSession();\n        if (session != null ) {\n            httpSessionId = ((HttpSession) session).getId();\n        }\n\n        // Need to call onOpen using the web application's class loader\n        // Create the frame using the application's class loader so it can pick\n        // up application specific config from the ServerContainerImpl\n        Thread t = Thread.currentThread();\n        ClassLoader cl = t.getContextClassLoader();\n        t.setContextClassLoader(applicationClassLoader);\n        try {\n            WsRemoteEndpointImplServer wsRemoteEndpointServer =\n                    new WsRemoteEndpointImplServer(sos, webSocketContainer);\n            wsSession = new WsSession(ep, wsRemoteEndpointServer,\n                    webSocketContainer, handshakeRequest.getRequestURI(),\n                    handshakeRequest.getParameterMap(),\n                    handshakeRequest.getQueryString(),\n                    handshakeRequest.getUserPrincipal(), httpSessionId,\n                    subProtocol, pathParameters, secure, endpointConfig);\n            WsFrameServer wsFrame = new WsFrameServer(\n                    sis,\n                    wsSession);\n            sos.setWriteListener(\n                    new WsWriteListener(this, wsRemoteEndpointServer));\n            ep.onOpen(wsSession, endpointConfig);\n            webSocketContainer.registerSession(ep, wsSession);\n            sis.setReadListener(new WsReadListener(this, wsFrame));\n        } catch (DeploymentException e) {\n            throw new IllegalArgumentException(e);\n        } finally {\n            t.setContextClassLoader(cl);\n        }\n    }",
                "    public void destroy() {\n        if (connection != null) {\n            try {\n                connection.close();\n            } catch (Exception e) {\n                log.error(sm.getString(\"wsHttpUpgradeHandler.destroyFailed\"), e);\n            }\n        }\n    }\n\n    private void onError(Throwable throwable) {\n        // Need to call onError using the web application's class loader\n        Thread t = Thread.currentThread();\n        ClassLoader cl = t.getContextClassLoader();\n        t.setContextClassLoader(applicationClassLoader);\n        try {\n            ep.onError(wsSession, throwable);\n        } finally {\n            t.setContextClassLoader(cl);\n        }\n    }\n\n    private void close(CloseReason cr) {\n        /*\n         * Any call to this method is a result of a problem reading from the\n         * client. At this point that state of the connection is unknown.\n         * Attempt to send a close frame to the client and then close the socket\n         * immediately. There is no point in waiting for a close frame from the\n         * client because there is no guarantee that we can recover from\n         * whatever messed up state the client put the connection into.\n         */\n        wsSession.onClose(cr);\n    }"
            ]
        }
    },
    "56010": {
        "summary": "Bug 56010 JspFactory.getPageContext with JspWriter.DEFAULT_BUFFER throws IllegalArgumentException",
        "code_segments": {
            "java\\org\\apache\\catalina\\core\\JasperListener.java": [
                "    public void lifecycleEvent(LifecycleEvent event) {\n\n        if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {\n            try {\n                // Set JSP factory\n                Class.forName(\"org.apache.jasper.compiler.JspRuntimeContext\",\n                              true,\n                              this.getClass().getClassLoader());\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                // Should not occur, obviously\n                log.warn(\"Couldn't initialize Jasper\", t);\n            }\n            // Another possibility is to do directly:\n            // JspFactory.setDefaultFactory(new JspFactoryImpl());\n        }\n\n    }"
            ],
            "java\\org\\apache\\jasper\\runtime\\JspFactoryImpl.java": [
                "    public void releasePageContext(PageContext pc) {\n        if( pc == null )\n            return;\n        if( Constants.IS_SECURITY_ENABLED ) {\n            PrivilegedReleasePageContext dp = new PrivilegedReleasePageContext(\n                    this,pc);\n            AccessController.doPrivileged(dp);\n        } else {\n            internalReleasePageContext(pc);\n        }\n    }"
            ],
            "java\\org\\apache\\tomcat\\util\\net\\NioSelectorPool.java": [
                "    public void put(Selector s) throws IOException {\n        if ( SHARED ) return;\n        if ( enabled ) active.decrementAndGet();\n        if ( enabled && (maxSpareSelectors==-1 || spare.get() < Math.min(maxSpareSelectors,maxSelectors)) ) {\n            spare.incrementAndGet();\n            selectors.offer(s);\n        }\n        else s.close();\n    }\n\n    public void close() throws IOException {\n        enabled = false;\n        Selector s;\n        while ( (s = selectors.poll()) != null ) s.close();\n        spare.set(0);\n        active.set(0);\n        if (blockingSelector!=null) {\n            blockingSelector.close();\n        }\n        if ( SHARED && getSharedSelector()!=null ) {\n            getSharedSelector().close();\n            SHARED_SELECTOR = null;\n        }\n    }\n\n    public void open() throws IOException {\n        enabled = true;\n        getSharedSelector();\n        if (SHARED) {\n            blockingSelector = new NioBlockingSelector();\n            blockingSelector.open(getSharedSelector());\n        }\n\n    }",
                "    public int write(ByteBuffer buf, NioChannel socket, Selector selector, long writeTimeout) throws IOException {\n        return write(buf,socket,selector,writeTimeout,true);\n    }\n\n    public int read(ByteBuffer buf, NioChannel socket, Selector selector, long readTimeout) throws IOException {\n        return read(buf,socket,selector,readTimeout,true);\n    }",
                "    public int read(ByteBuffer buf, NioChannel socket, Selector selector, long readTimeout, boolean block) throws IOException {\n        if ( SHARED && block ) {\n            return blockingSelector.read(buf,socket,readTimeout);\n        }\n        SelectionKey key = null;\n        int read = 0;\n        boolean timedout = false;\n        int keycount = 1; //assume we can write\n        long time = System.currentTimeMillis(); //start the timeout timer\n        try {\n            while ( (!timedout) ) {\n                int cnt = 0;\n                if ( keycount > 0 ) { //only read if we were registered for a read\n                    cnt = socket.read(buf);\n                    if (cnt == -1) throw new EOFException();\n                    read += cnt;\n                    if (cnt > 0) continue; //read some more\n                    if (cnt==0 && (read>0 || (!block) ) ) break; //we are done reading\n                }\n                if ( selector != null ) {//perform a blocking read\n                    //register OP_WRITE to the selector\n                    if (key==null) key = socket.getIOChannel().register(selector, SelectionKey.OP_READ);\n                    else key.interestOps(SelectionKey.OP_READ);\n                    keycount = selector.select(readTimeout);\n                }\n                if (readTimeout > 0 && (selector == null || keycount == 0) ) timedout = (System.currentTimeMillis()-time)>=readTimeout;\n            }//while\n            if ( timedout ) throw new SocketTimeoutException();\n        } finally {\n            if (key != null) {\n                key.cancel();\n                if (selector != null) selector.selectNow();//removes the key from this selector\n            }\n        }\n        return read;\n    }"
            ],
            "java\\org\\apache\\jasper\\runtime\\ServletResponseWrapperInclude.java": [
                "    public void resetBuffer() {\n        try {\n            jspWriter.clearBuffer();\n        } catch (IOException ioe) {\n        }\n    }"
            ],
            "java\\org\\apache\\jasper\\runtime\\PageContextImpl.java": [
                "    public void release() {\n        out = baseOut;\n        try {\n            if (isIncluded) {\n                ((JspWriterImpl) out).flushBuffer();\n                // push it into the including jspWriter\n            } else {\n                // Old code:\n                // out.flush();\n                // Do not flush the buffer even if we're not included (i.e.\n                // we are the main page. The servlet will flush it and close\n                // the stream.\n                ((JspWriterImpl) out).flushBuffer();\n            }\n        } catch (IOException ex) {\n            IllegalStateException ise = new IllegalStateException(Localizer.getMessage(\"jsp.error.flush\"), ex);\n            throw ise;\n        } finally {\n            servlet = null;\n            config = null;\n            context = null;\n            applicationContext = null;\n            elContext = null;\n            errorPageURL = null;\n            request = null;\n            response = null;\n            depth = -1;\n            baseOut.recycle();\n            session = null;\n            attributes.clear();\n            for (BodyContentImpl body: outs) {\n                body.recycle();\n            }\n        }\n    }",
                "    private Object doGetAttribute(String name, int scope) {\n        switch (scope) {\n        case PAGE_SCOPE:\n            return attributes.get(name);\n\n        case REQUEST_SCOPE:\n            return request.getAttribute(name);\n\n        case SESSION_SCOPE:\n            if (session == null) {\n                throw new IllegalStateException(Localizer\n                        .getMessage(\"jsp.error.page.noSession\"));\n            }\n            return session.getAttribute(name);\n\n        case APPLICATION_SCOPE:\n            return context.getAttribute(name);\n\n        default:\n            throw new IllegalArgumentException(\"Invalid scope\");\n        }\n    }\n\n    private void doSetAttribute(String name, Object attribute) {\n        if (attribute != null) {\n            attributes.put(name, attribute);\n        } else {\n            removeAttribute(name, PAGE_SCOPE);\n        }\n    }",
                "    private void doSetAttribute(String name, Object o, int scope) {\n        if (o != null) {\n            switch (scope) {\n            case PAGE_SCOPE:\n                attributes.put(name, o);\n                break;\n\n            case REQUEST_SCOPE:\n                request.setAttribute(name, o);\n                break;\n\n            case SESSION_SCOPE:\n                if (session == null) {\n                    throw new IllegalStateException(Localizer\n                            .getMessage(\"jsp.error.page.noSession\"));\n                }\n                session.setAttribute(name, o);\n                break;\n\n            case APPLICATION_SCOPE:\n                context.setAttribute(name, o);\n                break;\n\n            default:\n                throw new IllegalArgumentException(\"Invalid scope\");\n            }\n        } else {\n            removeAttribute(name, scope);\n        }\n    }",
                "    public void removeAttribute(final String name, final int scope) {\n\n        if (name == null) {\n            throw new NullPointerException(Localizer\n                    .getMessage(\"jsp.error.attribute.null_name\"));\n        }\n        if (SecurityUtil.isPackageProtectionEnabled()) {\n            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                @Override\n                public Void run() {\n                    doRemoveAttribute(name, scope);\n                    return null;\n                }\n            });\n        } else {\n            doRemoveAttribute(name, scope);\n        }\n    }",
                "    private void doRemoveAttribute(String name, int scope) {\n        switch (scope) {\n        case PAGE_SCOPE:\n            attributes.remove(name);\n            break;\n\n        case REQUEST_SCOPE:\n            request.removeAttribute(name);\n            break;\n\n        case SESSION_SCOPE:\n            if (session == null) {\n                throw new IllegalStateException(Localizer\n                        .getMessage(\"jsp.error.page.noSession\"));\n            }\n            session.removeAttribute(name);\n            break;\n\n        case APPLICATION_SCOPE:\n            context.removeAttribute(name);\n            break;\n\n        default:\n            throw new IllegalArgumentException(\"Invalid scope\");\n        }\n    }",
                "    private int doGetAttributeScope(String name) {\n        if (attributes.get(name) != null)\n            return PAGE_SCOPE;\n\n        if (request.getAttribute(name) != null)\n            return REQUEST_SCOPE;\n\n        if (session != null) {\n            try {\n                if (session.getAttribute(name) != null)\n                    return SESSION_SCOPE;\n            } catch(IllegalStateException ise) {\n                // Session has been invalidated.\n                // Ignore and fall through to application scope.\n            }\n        }\n\n        if (context.getAttribute(name) != null)\n            return APPLICATION_SCOPE;\n\n        return 0;\n    }",
                "    public Object findAttribute(final String name) {\n        if (SecurityUtil.isPackageProtectionEnabled()) {\n            return AccessController.doPrivileged(\n                    new PrivilegedAction<Object>() {\n                @Override\n                public Object run() {\n                    if (name == null) {\n                        throw new NullPointerException(Localizer\n                                .getMessage(\"jsp.error.attribute.null_name\"));\n                    }\n\n                    return doFindAttribute(name);\n                }\n            });\n        } else {\n            if (name == null) {\n                throw new NullPointerException(Localizer\n                        .getMessage(\"jsp.error.attribute.null_name\"));\n            }\n\n            return doFindAttribute(name);\n        }\n    }",
                "    private Object doFindAttribute(String name) {\n\n        Object o = attributes.get(name);\n        if (o != null)\n            return o;\n\n        o = request.getAttribute(name);\n        if (o != null)\n            return o;\n\n        if (session != null) {\n            try {\n                o = session.getAttribute(name);\n            } catch(IllegalStateException ise) {\n                // Session has been invalidated.\n                // Ignore and fall through to application scope.\n            }\n            if (o != null)\n                return o;\n        }\n\n        return context.getAttribute(name);\n    }",
                "    private Enumeration<String> doGetAttributeNamesInScope(int scope) {\n        switch (scope) {\n        case PAGE_SCOPE:\n            return Collections.enumeration(attributes.keySet());\n\n        case REQUEST_SCOPE:\n            return request.getAttributeNames();\n\n        case SESSION_SCOPE:\n            if (session == null) {\n                throw new IllegalStateException(Localizer\n                        .getMessage(\"jsp.error.page.noSession\"));\n            }\n            return session.getAttributeNames();\n\n        case APPLICATION_SCOPE:\n            return context.getAttributeNames();\n\n        default:\n            throw new IllegalArgumentException(\"Invalid scope\");\n        }\n    }",
                "    public void removeAttribute(final String name) {\n\n        if (name == null) {\n            throw new NullPointerException(Localizer\n                    .getMessage(\"jsp.error.attribute.null_name\"));\n        }\n\n        if (SecurityUtil.isPackageProtectionEnabled()) {\n            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                @Override\n                public Void run() {\n                    doRemoveAttribute(name);\n                    return null;\n                }\n            });\n        } else {\n            doRemoveAttribute(name);\n        }\n    }\n\n    private void doRemoveAttribute(String name) {\n        removeAttribute(name, PAGE_SCOPE);\n        removeAttribute(name, REQUEST_SCOPE);\n        if( session != null ) {\n            try {\n                removeAttribute(name, SESSION_SCOPE);\n            } catch(IllegalStateException ise) {\n                // Session has been invalidated.\n                // Ignore and fall throw to application scope.\n            }\n        }\n        removeAttribute(name, APPLICATION_SCOPE);\n    }\n\n    private void doForward(String relativeUrlPath) throws ServletException,",
                "    public JspWriter pushBody(Writer writer) {\n        depth++;\n        if (depth >= outs.length) {\n            BodyContentImpl[] newOuts = new BodyContentImpl[depth + 1];\n            for (int i = 0; i < outs.length; i++) {\n                newOuts[i] = outs[i];\n            }\n            newOuts[depth] = new BodyContentImpl(out);\n            outs = newOuts;\n        }\n\n        outs[depth].setWriter(writer);\n        out = outs[depth];\n\n        // Update the value of the \"out\" attribute in the page scope\n        // attribute namespace of this PageContext\n        setAttribute(OUT, out);\n\n        return outs[depth];\n    }\n\n    public JspWriter popBody() {\n        depth--;\n        if (depth >= 0) {\n            out = outs[depth];\n        } else {\n            out = baseOut;\n        }\n\n        // Update the value of the \"out\" attribute in the page scope\n        // attribute namespace of this PageContext\n        setAttribute(OUT, out);\n\n        return out;\n    }\n\n    public void handlePageException(final Throwable t) throws IOException,",
                "    private void doHandlePageException(Throwable t) throws IOException,"
            ],
            "java\\org\\apache\\jasper\\runtime\\BodyContentImpl.java": [
                "    public void write(int c) throws IOException {\n        if (writer != null) {\n            writer.write(c);\n        } else {\n            ensureOpen();\n            if (nextChar >= bufferSize) {\n                reAllocBuff (1);\n            }\n            cb[nextChar++] = (char) c;\n        }\n    }\n\n    public void write(char[] cbuf, int off, int len) throws IOException {\n        if (writer != null) {\n            writer.write(cbuf, off, len);\n        } else {\n            ensureOpen();\n            \n            if ((off < 0) || (off > cbuf.length) || (len < 0) ||\n                    ((off + len) > cbuf.length) || ((off + len) < 0)) {\n                throw new IndexOutOfBoundsException();\n            } else if (len == 0) {\n                return;\n            } \n            \n            if (len >= bufferSize - nextChar)\n                reAllocBuff (len);\n            \n            System.arraycopy(cbuf, off, cb, nextChar, len);\n            nextChar+=len;\n        }\n    }\n\n    public void write(char[] buf) throws IOException {\n        if (writer != null) {\n            writer.write(buf);\n        } else {\n            write(buf, 0, buf.length);\n        }\n    }",
                "    public void write(String s, int off, int len) throws IOException {\n        if (writer != null) {\n            writer.write(s, off, len);\n        } else {\n            ensureOpen();\n            if (len >= bufferSize - nextChar)\n                reAllocBuff(len);\n            \n            s.getChars(off, off + len, cb, nextChar);\n            nextChar += len;\n        }\n    }\n\n    public void write(String s) throws IOException {\n        if (writer != null) {\n            writer.write(s);\n        } else {\n            write(s, 0, s.length());\n        }\n    }\n\n    public void newLine() throws IOException {\n        if (writer != null) {\n            writer.write(LINE_SEPARATOR);\n        } else {\n            write(LINE_SEPARATOR);\n        }\n    }",
                "    public void print(boolean b) throws IOException {\n        if (writer != null) {\n            writer.write(b ? \"true\" : \"false\");\n        } else {\n            write(b ? \"true\" : \"false\");\n        }\n    }\n\n    public void print(char c) throws IOException {\n        if (writer != null) {\n            writer.write(String.valueOf(c));\n        } else {\n            write(String.valueOf(c));\n        }\n    }\n\n    public void print(int i) throws IOException {\n        if (writer != null) {\n            writer.write(String.valueOf(i));\n        } else {\n            write(String.valueOf(i));\n        }\n    }",
                "    public void print(long l) throws IOException {\n        if (writer != null) {\n            writer.write(String.valueOf(l));\n        } else {\n            write(String.valueOf(l));\n        }\n    }\n\n    public void print(float f) throws IOException {\n        if (writer != null) {\n            writer.write(String.valueOf(f));\n        } else {\n            write(String.valueOf(f));\n        }\n    }\n\n    public void print(double d) throws IOException {\n        if (writer != null) {\n            writer.write(String.valueOf(d));\n        } else {\n            write(String.valueOf(d));\n        }\n    }",
                "    public void print(char[] s) throws IOException {\n        if (writer != null) {\n            writer.write(s);\n        } else {\n            write(s);\n        }\n    }\n\n    public void print(String s) throws IOException {\n        if (s == null) s = \"null\";\n        if (writer != null) {\n            writer.write(s);\n        } else {\n            write(s);\n        }\n    }\n\n    public void print(Object obj) throws IOException {\n        if (writer != null) {\n            writer.write(String.valueOf(obj));\n        } else {\n            write(String.valueOf(obj));\n        }\n    }",
                "    public void println(double x) throws IOException{\n        print(x);\n        println();\n    }\n\n    public void clear() throws IOException {\n        if (writer != null) {\n            throw new IOException();\n        } else {\n            nextChar = 0;\n            if (LIMIT_BUFFER && (cb.length > Constants.DEFAULT_TAG_BUFFER_SIZE)) {\n                cb = new char[Constants.DEFAULT_TAG_BUFFER_SIZE];\n                bufferSize = cb.length;\n            }\n        }\n    }\n\n    public void clearBuffer() throws IOException {\n        if (writer == null) {\n            this.clear();\n        }\n    }",
                "    public void close() throws IOException {\n        if (writer != null) {\n            writer.close();\n        } else {\n            closed = true;\n        }\n    }\n\n    public void writeOut(Writer out) throws IOException {\n        if (writer == null) {\n            out.write(cb, 0, nextChar);\n            // Flush not called as the writer passed could be a BodyContent and\n            // it doesn't allow to flush.\n        }\n    }\n\n    protected void recycle() {\n        this.writer = null;\n        try {\n            this.clear();\n        } catch (IOException ex) {\n            // ignore\n        }\n    }",
                "    private void ensureOpen() throws IOException {\n        if (closed) throw new IOException(\"Stream closed\");\n    }\n\n    private void reAllocBuff(int len) {\n        \n        if (bufferSize + len <= cb.length) {\n            bufferSize = cb.length;\n            return;\n        }\n        \n        if (len < cb.length) {\n            len = cb.length;\n        }\n        \n        char[] tmp = new char[cb.length + len];\n        System.arraycopy(cb, 0, tmp, 0, cb.length);\n        cb = tmp;\n        bufferSize = cb.length;\n    }"
            ],
            "java\\org\\apache\\jasper\\runtime\\JspContextWrapper.java": [
                "    public Object findAttribute(String name) {\n\n        if (name == null) {\n            throw new NullPointerException(Localizer\n                    .getMessage(\"jsp.error.attribute.null_name\"));\n        }\n\n        Object o = pageAttributes.get(name);\n        if (o == null) {\n            o = rootJspCtxt.getAttribute(name, REQUEST_SCOPE);\n            if (o == null) {\n                if (getSession() != null) {\n                    o = rootJspCtxt.getAttribute(name, SESSION_SCOPE);\n                }\n                if (o == null) {\n                    o = rootJspCtxt.getAttribute(name, APPLICATION_SCOPE);\n                }\n            }\n        }\n\n        return o;\n    }\n\n    public void removeAttribute(String name) {\n\n        if (name == null) {\n            throw new NullPointerException(Localizer\n                    .getMessage(\"jsp.error.attribute.null_name\"));\n        }\n\n        pageAttributes.remove(name);\n        rootJspCtxt.removeAttribute(name, REQUEST_SCOPE);\n        if (getSession() != null) {\n            rootJspCtxt.removeAttribute(name, SESSION_SCOPE);\n        }\n        rootJspCtxt.removeAttribute(name, APPLICATION_SCOPE);\n    }",
                "    public void removeAttribute(String name, int scope) {\n\n        if (name == null) {\n            throw new NullPointerException(Localizer\n                    .getMessage(\"jsp.error.attribute.null_name\"));\n        }\n\n        if (scope == PAGE_SCOPE) {\n            pageAttributes.remove(name);\n        } else {\n            rootJspCtxt.removeAttribute(name, scope);\n        }\n    }\n\n    public void handlePageException(Throwable t) throws IOException,",
                "    private void copyTagToPageScope(int scope) {\n        Iterator<String> iter = null;\n\n        switch (scope) {\n        case VariableInfo.NESTED:\n            if (nestedVars != null) {\n                iter = nestedVars.iterator();\n            }\n            break;\n        case VariableInfo.AT_BEGIN:\n            if (atBeginVars != null) {\n                iter = atBeginVars.iterator();\n            }\n            break;\n        case VariableInfo.AT_END:\n            if (atEndVars != null) {\n                iter = atEndVars.iterator();\n            }\n            break;\n        }\n\n        while ((iter != null) && iter.hasNext()) {\n            String varName = iter.next();\n            Object obj = getAttribute(varName);\n            varName = findAlias(varName);\n            if (obj != null) {\n                invokingJspCtxt.setAttribute(varName, obj);\n            } else {\n                invokingJspCtxt.removeAttribute(varName, PAGE_SCOPE);\n            }\n        }\n    }",
                "    private void saveNestedVariables() {\n        if (nestedVars != null) {\n            Iterator<String> iter = nestedVars.iterator();\n            while (iter.hasNext()) {\n                String varName = iter.next();\n                varName = findAlias(varName);\n                Object obj = invokingJspCtxt.getAttribute(varName);\n                if (obj != null) {\n                    originalNestedVars.put(varName, obj);\n                }\n            }\n        }\n    }\n\n    private void restoreNestedVariables() {\n        if (nestedVars != null) {\n            Iterator<String> iter = nestedVars.iterator();\n            while (iter.hasNext()) {\n                String varName = iter.next();\n                varName = findAlias(varName);\n                Object obj = originalNestedVars.get(varName);\n                if (obj != null) {\n                    invokingJspCtxt.setAttribute(varName, obj);\n                } else {\n                    invokingJspCtxt.removeAttribute(varName, PAGE_SCOPE);\n                }\n            }\n        }\n    }\n\n    private String findAlias(String varName) {\n\n        if (aliases == null)\n            return varName;\n\n        String alias = aliases.get(varName);\n        if (alias == null) {\n            return varName;\n        }\n        return alias;\n    }"
            ],
            "java\\javax\\servlet\\jsp\\tagext\\BodyTagSupport.java": [
                "    public int doEndTag() throws JspException {\n        return super.doEndTag();\n    }"
            ],
            "test\\org\\apache\\catalina\\util\\TestRequestUtil.java": [
                "    public void testURLDecodeStringInvalid() {\n        // %n rather than %nn should throw an IAE according to the Javadoc\n        Exception exception = null;\n        try {\n            RequestUtil.URLDecode(\"%5xxxxx\");\n        } catch (Exception e) {\n            exception = e;\n        }\n        assertTrue(exception instanceof IllegalArgumentException);\n\n        // Edge case trying to trigger ArrayIndexOutOfBoundsException\n        exception = null;\n        try {\n            RequestUtil.URLDecode(\"%5\");\n        } catch (Exception e) {\n            exception = e;\n        }\n        assertTrue(exception instanceof IllegalArgumentException);\n    }"
            ],
            "test\\org\\apache\\catalina\\core\\TestStandardHostValve.java": [
                "    public void testErrorPageHandling() throws Exception {\n        // Set up a container\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        // Add the error page\n        Tomcat.addServlet(ctx, \"error\", new ErrorServlet());\n        ctx.addServletMapping(\"/error\", \"error\");\n\n        // Add the error handling page\n        Tomcat.addServlet(ctx, \"report\", new ReportServlet());\n        ctx.addServletMapping(\"/report/*\", \"report\");\n\n        // And the handling for 500 responses\n        ErrorPage errorPage500 = new ErrorPage();\n        errorPage500.setErrorCode(Response.SC_INTERNAL_SERVER_ERROR);\n        errorPage500.setLocation(\"/report/500\");\n        ctx.addErrorPage(errorPage500);\n\n        // And the default error handling\n        ErrorPage errorPageDefault = new ErrorPage();\n        errorPageDefault.setLocation(\"/report/default\");\n        ctx.addErrorPage(errorPageDefault);\n\n        tomcat.start();\n\n        doTestErrorPageHandling(500, \"/500\");\n        doTestErrorPageHandling(501, \"/default\");\n    }"
            ],
            "java\\javax\\servlet\\jsp\\tagext\\BodyContent.java": [
                "    public void flush() throws IOException {\n        throw new IOException(\"Illegal to flush within a custom tag\");\n    }\n\n    public void clearBody() {\n        try {\n            this.clear();\n        } catch (IOException ex) {\n            // TODO -- clean this one up.\n            throw new Error(\"internal error!;\");\n        }\n    }"
            ],
            "java\\org\\apache\\tomcat\\websocket\\server\\UriTemplate.java": [
                "    public Map<String,String> match(UriTemplate candidate) {\n\n        Map<String,String> result = new HashMap<String, String>();\n\n        // Should not happen but for safety\n        if (candidate.getSegmentCount() != getSegmentCount()) {\n            return null;\n        }\n\n        Iterator<Segment> candidateSegments =\n                candidate.getSegments().iterator();\n        Iterator<Segment> targetSegments = segments.iterator();\n\n        while (candidateSegments.hasNext()) {\n            Segment candidateSegment = candidateSegments.next();\n            Segment targetSegment = targetSegments.next();\n\n            if (targetSegment.getParameterIndex() == -1) {\n                // Not a parameter - values must match\n                if (!targetSegment.getValue().equals(\n                        candidateSegment.getValue())) {\n                    // Not a match. Stop here\n                    return null;\n                }\n            } else {\n                // Parameter\n                result.put(targetSegment.getValue(),\n                        candidateSegment.getValue());\n            }\n        }\n\n        return result;\n    }"
            ],
            "test\\org\\apache\\tomcat\\websocket\\server\\TestUriTemplate.java": [
                "    public void testBasic() throws Exception {\n        UriTemplate t = new UriTemplate(\"/{a}/{b}\");\n        Map<String,String> result = t.match(new UriTemplate(\"/foo/bar\"));\n\n        Assert.assertEquals(2, result.size());\n        Assert.assertTrue(result.containsKey(\"a\"));\n        Assert.assertTrue(result.containsKey(\"b\"));\n        Assert.assertEquals(\"foo\", result.get(\"a\"));\n        Assert.assertEquals(\"bar\", result.get(\"b\"));\n    }\n\n    public void testOneOfTwo() throws Exception {\n        UriTemplate t = new UriTemplate(\"/{a}/{b}\");\n        Map<String,String> result = t.match(new UriTemplate(\"/foo\"));\n        Assert.assertNull(result);\n    }\n\n    public void testNoParams() throws Exception {\n        UriTemplate t = new UriTemplate(\"/foo/bar\");\n        Map<String,String> result = t.match(new UriTemplate(\"/foo/bar\"));\n\n        Assert.assertEquals(0, result.size());\n    }",
                "    public void testSpecExample1_01() throws Exception {\n        UriTemplate t = new UriTemplate(\"/a/b\");\n        Map<String,String> result = t.match(new UriTemplate(\"/a/b\"));\n\n        Assert.assertEquals(0, result.size());\n    }\n\n    public void testSpecExample1_02() throws Exception {\n        UriTemplate t = new UriTemplate(\"/a/b\");\n        Map<String,String> result = t.match(new UriTemplate(\"/a\"));\n\n        Assert.assertNull(result);\n    }\n\n    public void testSpecExample1_03() throws Exception {\n        UriTemplate t = new UriTemplate(\"/a/b\");\n        Map<String,String> result = t.match(new UriTemplate(\"/a/bb\"));\n\n        Assert.assertNull(result);\n    }",
                "    public void testSpecExample2_01() throws Exception {\n        UriTemplate t = new UriTemplate(\"/a/{var}\");\n        Map<String,String> result = t.match(new UriTemplate(\"/a/b\"));\n\n        Assert.assertEquals(1, result.size());\n        Assert.assertEquals(\"b\", result.get(\"var\"));\n    }\n\n    public void testSpecExample2_02() throws Exception {\n        UriTemplate t = new UriTemplate(\"/a/{var}\");\n        Map<String,String> result = t.match(new UriTemplate(\"/a/apple\"));\n\n        Assert.assertEquals(1, result.size());\n        Assert.assertEquals(\"apple\", result.get(\"var\"));\n    }\n\n    public void testSpecExample2_03() throws Exception {\n        UriTemplate t = new UriTemplate(\"/a/{var}\");\n        Map<String,String> result = t.match(new UriTemplate(\"/a\"));\n\n        Assert.assertNull(result);\n    }",
                "    public void testSpecExample2_04() throws Exception {\n        UriTemplate t = new UriTemplate(\"/a/{var}\");\n        Map<String,String> result = t.match(new UriTemplate(\"/a/b/c\"));\n\n        Assert.assertNull(result);\n    }\n\n    public void testDuplicate02() throws Exception {\n        UriTemplate t = new UriTemplate(\"/{a}/{b}\");\n        Map<String,String> result = t.match(new UriTemplate(\"/x/x\"));\n\n        Assert.assertEquals(2, result.size());\n        Assert.assertEquals(\"x\", result.get(\"a\"));\n        Assert.assertEquals(\"x\", result.get(\"b\"));\n    }\n\n    public void testEgMailingList01() throws Exception {\n        UriTemplate t = new UriTemplate(\"/a/{var}\");\n        Map<String,String> result = t.match(new UriTemplate(\"/a/b/\"));\n\n        Assert.assertNull(result);\n    }",
                "    public void testEgMailingList02() throws Exception {\n        UriTemplate t = new UriTemplate(\"/a/{var}\");\n        Map<String,String> result = t.match(new UriTemplate(\"/a/\"));\n\n        Assert.assertNull(result);\n    }\n\n    public void testEgMailingList03() throws Exception {\n        UriTemplate t = new UriTemplate(\"/a/{var}\");\n        Map<String,String> result = t.match(new UriTemplate(\"/a\"));\n\n        Assert.assertNull(result);\n    }\n\n    public void testEgMailingList04() throws Exception {\n        UriTemplate t = new UriTemplate(\"/a/{var1}/{var2}\");\n        @SuppressWarnings(\"unused\")\n        Map<String,String> result = t.match(new UriTemplate(\"/a//c\"));\n    }",
                "    public void testEgMailingList05() throws Exception {\n        UriTemplate t = new UriTemplate(\"/a/{var}/\");\n        @SuppressWarnings(\"unused\")\n        Map<String,String> result = t.match(new UriTemplate(\"/a/b/\"));\n    }"
            ],
            "test\\org\\apache\\jasper\\runtime\\TestPageContextImpl.java": [
                "    public void testDoForward() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        File appDir = new File(\"test/webapp-3.0\");\n        tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());\n\n        tomcat.start();\n\n        ByteChunk res = new ByteChunk();\n\n        int rc = getUrl(\"http://localhost:\" + getPort() +\n                \"/test/bug5nnnn/bug53545.jsp\", res, null);\n\n        Assert.assertEquals(HttpServletResponse.SC_OK, rc);\n\n        String body = res.toString();\n        Assert.assertTrue(body.contains(\"OK\"));\n        Assert.assertFalse(body.contains(\"FAIL\"));\n    }\n\n    public void testDefaultBufferSize() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        File appDir = new File(\"test/webapp-3.0\");\n        // app dir is relative to server home\n        Context ctx = tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());\n\n        // Add the Servlet\n        Tomcat.addServlet(ctx, \"bug56010\", new Bug56010());\n        ctx.addServletMapping(\"/bug56010\", \"bug56010\");\n\n        tomcat.start();\n\n        ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/test/bug56010\");\n\n        String result = res.toString();\n        Assert.assertTrue(result.contains(\"OK\"));\n    }"
            ]
        }
    },
    "55996": {
        "summary": "Bug 55996 Async context does not timeout with HTTP NIO connector",
        "code_segments": {
            "java\\org\\apache\\coyote\\AsyncStateMachine.java": [
                "    public synchronized void asyncStart(AsyncContextCallback asyncCtxt) {\n        if (state == AsyncState.DISPATCHED) {\n            state = AsyncState.STARTING;\n            this.asyncCtxt = asyncCtxt;\n        } else {\n            throw new IllegalStateException(\n                    sm.getString(\"asyncStateMachine.invalidAsyncState\",\n                            \"asyncStart()\", state));\n        }\n    }\n\n    public synchronized SocketState asyncPostProcess() {\n        \n        if (state == AsyncState.STARTING) {\n            state = AsyncState.STARTED;\n            return SocketState.LONG;\n        } else if (state == AsyncState.MUST_COMPLETE) {\n            asyncCtxt.fireOnComplete();\n            state = AsyncState.DISPATCHED;\n            return SocketState.ASYNC_END;\n        } else if (state == AsyncState.COMPLETING) {\n            asyncCtxt.fireOnComplete();\n            state = AsyncState.DISPATCHED;\n            return SocketState.ASYNC_END;\n        } else if (state == AsyncState.MUST_DISPATCH) {\n            state = AsyncState.DISPATCHING;\n            return SocketState.ASYNC_END;\n        } else if (state == AsyncState.DISPATCHING) {\n            state = AsyncState.DISPATCHED;\n            return SocketState.ASYNC_END;\n        } else if (state == AsyncState.STARTED) {\n            // This can occur if an async listener does a dispatch to an async\n            // servlet during onTimeout\n            return SocketState.LONG;\n        } else {\n            throw new IllegalStateException(\n                    sm.getString(\"asyncStateMachine.invalidAsyncState\",\n                            \"asyncPostProcess()\", state));\n        }\n    }",
                "    public synchronized boolean asyncComplete() {\n        boolean doComplete = false;\n        \n        if (state == AsyncState.STARTING) {\n            state = AsyncState.MUST_COMPLETE;\n        } else if (state == AsyncState.STARTED) {\n            state = AsyncState.COMPLETING;\n            doComplete = true;\n        } else if (state == AsyncState.TIMING_OUT ||\n                state == AsyncState.ERROR) {\n            state = AsyncState.MUST_COMPLETE;\n        } else {\n            throw new IllegalStateException(\n                    sm.getString(\"asyncStateMachine.invalidAsyncState\",\n                            \"asyncComplete()\", state));\n            \n        }\n        return doComplete;\n    }\n\n    public synchronized boolean asyncTimeout() {\n        if (state == AsyncState.STARTED) {\n            state = AsyncState.TIMING_OUT;\n            return true;\n        } else if (state == AsyncState.COMPLETING ||\n                state == AsyncState.DISPATCHED) {\n            // NOOP - App called complete between the the timeout firing and\n            // execution reaching this point\n            return false;\n        } else {\n            throw new IllegalStateException(\n                    sm.getString(\"asyncStateMachine.invalidAsyncState\",\n                            \"asyncTimeout()\", state));\n        }\n    }",
                "    public synchronized boolean asyncDispatch() {\n        boolean doDispatch = false;\n        if (state == AsyncState.STARTING) {\n            state = AsyncState.MUST_DISPATCH;\n        } else if (state == AsyncState.STARTED ||\n                state == AsyncState.TIMING_OUT ||\n                state == AsyncState.ERROR) {\n            state = AsyncState.DISPATCHING;\n            doDispatch = true;\n        } else {\n            throw new IllegalStateException(\n                    sm.getString(\"asyncStateMachine.invalidAsyncState\",\n                            \"asyncDispatch()\", state));\n        }\n        return doDispatch;\n    }\n\n    public synchronized void asyncDispatched() {\n        if (state == AsyncState.DISPATCHING) {\n            state = AsyncState.DISPATCHED;\n        } else {\n            throw new IllegalStateException(\n                    sm.getString(\"asyncStateMachine.invalidAsyncState\",\n                            \"asyncDispatched()\", state));\n        }\n    }\n\n    public synchronized boolean asyncError() {\n        boolean doDispatch = false;\n        if (state == AsyncState.DISPATCHED ||\n                state == AsyncState.TIMING_OUT) {\n            state = AsyncState.ERROR;\n        } else {\n            throw new IllegalStateException(\n                    sm.getString(\"asyncStateMachine.invalidAsyncState\",\n                            \"asyncError()\", state));\n        }\n        return doDispatch;\n    }",
                "    public synchronized void asyncRun(Runnable runnable) {\n        if (state == AsyncState.STARTING || state ==  AsyncState.STARTED) {\n            // Execute the runnable using a container thread from the\n            // Connector's thread pool. Use a wrapper to prevent a memory leak\n            ClassLoader oldCL;\n            if (Constants.IS_SECURITY_ENABLED) {\n                PrivilegedAction<ClassLoader> pa = new PrivilegedGetTccl();\n                oldCL = AccessController.doPrivileged(pa);\n            } else {\n                oldCL = Thread.currentThread().getContextClassLoader();\n            }\n            try {\n                if (Constants.IS_SECURITY_ENABLED) {\n                    PrivilegedAction<Void> pa = new PrivilegedSetTccl(\n                            this.getClass().getClassLoader());\n                    AccessController.doPrivileged(pa);\n                } else {\n                    Thread.currentThread().setContextClassLoader(\n                            this.getClass().getClassLoader());\n                }\n                \n                processor.getExecutor().execute(runnable);\n            } finally {\n                if (Constants.IS_SECURITY_ENABLED) {\n                    PrivilegedAction<Void> pa = new PrivilegedSetTccl(\n                            oldCL);\n                    AccessController.doPrivileged(pa);\n                } else {\n                    Thread.currentThread().setContextClassLoader(oldCL);\n                }\n            }\n        } else {\n            throw new IllegalStateException(\n                    sm.getString(\"asyncStateMachine.invalidAsyncState\",\n                            \"asyncRun()\", state));\n        }\n\n    }"
            ],
            "test\\org\\apache\\catalina\\connector\\TestConnector.java": [
                "    public void testStop() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Wrapper w =\n            Tomcat.addServlet(root, \"tester\", new TesterServlet());\n        w.setAsyncSupported(true);\n        root.addServletMapping(\"/\", \"tester\");\n\n        Connector connector = tomcat.getConnector();\n\n        tomcat.start();\n\n        ByteChunk bc = new ByteChunk();\n        int rc = getUrl(\"http://localhost:\" + getPort() + \"/\", bc, null, null);\n\n        assertEquals(200, rc);\n        assertEquals(\"OK\", bc.toString());\n\n        rc = -1;\n        bc.recycle();\n\n        connector.stop();\n\n        try {\n            rc = getUrl(\"http://localhost:\" + getPort() + \"/\", bc, 1000,\n                    null, null);\n        } catch (SocketTimeoutException ste) {\n            // May also see this with NIO\n            // Make sure the test passes if we do\n            rc = 503;\n        }\n        assertEquals(503, rc);\n    }",
                "    public void testPort() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        Connector connector1 = tomcat.getConnector();\n        connector1.setPort(0);\n\n        Connector connector2 = new Connector();\n        connector2.setPort(0);\n\n        tomcat.getService().addConnector(connector2);\n\n        tomcat.start();\n\n        int localPort1 = connector1.getLocalPort();\n        int localPort2 = connector2.getLocalPort();\n\n        assertTrue(localPort1 > 0);\n        assertTrue(localPort2 > 0);\n    }"
            ],
            "java\\org\\apache\\tomcat\\util\\net\\SecureNioChannel.java": [
                "    public void reset() throws IOException {\n        super.reset();\n        netOutBuffer.position(0);\n        netOutBuffer.limit(0);\n        netInBuffer.position(0);\n        netInBuffer.limit(0);\n        handshakeComplete = false;\n        closed = false;\n        closing = false;\n        //initiate handshake\n        sslEngine.beginHandshake();\n        handshakeStatus = sslEngine.getHandshakeStatus();\n    }\n\n    protected boolean flush(ByteBuffer buf) throws IOException {\n        int remaining = buf.remaining();\n        if ( remaining > 0 ) {\n            int written = sc.write(buf);\n            return written >= remaining;\n        }else {\n            return true;\n        }\n    }",
                "    public int handshake(boolean read, boolean write) throws IOException {\n        if ( handshakeComplete ) return 0; //we have done our initial handshake\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; //we still have data to write\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    //should never happen\n                    throw new IOException(\"NOT_HANDSHAKING during handshake\");\n                }\n                case FINISHED: {\n                    //we are complete if we have delivered the last package\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    //return 0 if we are complete, otherwise we still have data to write\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    //perform the wrap function\n                    handshake = handshakeWrap(write);\n                    if ( handshake.getStatus() == Status.OK ){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        //wrap should always work with our buffers\n                        throw new IOException(\"Unexpected status:\" + handshake.getStatus() + \" during handshake WRAP.\");\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        //should actually return OP_READ if we have NEED_UNWRAP\n                        return SelectionKey.OP_WRITE;\n                    }\n                    //fall down to NEED_UNWRAP on the same call, will result in a\n                    //BUFFER_UNDERFLOW if it needs data\n                }\n                //$FALL-THROUGH$\n                case NEED_UNWRAP: {\n                    //perform the unwrap function\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        //read more data, reregister for OP_READ\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(\"Invalid handshake status:\"+handshakeStatus+\" during handshake UNWRAP.\");\n                    }//switch\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(\"Invalid handshake status:\"+handshakeStatus);\n            }//switch\n        }//while\n        //return 0 if we are complete, otherwise reregister for any activity that\n        //would cause this method to be called again.\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }",
                "    public void rehandshake(long timeout) throws IOException {\n        //validate the network buffers are empty\n        if (netInBuffer.position() > 0 && netInBuffer.position()<netInBuffer.limit()) throw new IOException(\"Network input buffer still contains data. Handshake will fail.\");\n        if (netOutBuffer.position() > 0 && netOutBuffer.position()<netOutBuffer.limit()) throw new IOException(\"Network output buffer still contains data. Handshake will fail.\");\n        if (getBufHandler().getReadBuffer().position()>0 && getBufHandler().getReadBuffer().position()<getBufHandler().getReadBuffer().limit()) throw new IOException(\"Application input buffer still contains data. Data would have been lost.\");\n        if (getBufHandler().getWriteBuffer().position()>0 && getBufHandler().getWriteBuffer().position()<getBufHandler().getWriteBuffer().limit()) throw new IOException(\"Application output buffer still contains data. Data would have been lost.\");\n        reset();\n        boolean isReadable = true;\n        boolean isWriteable = true;\n        boolean handshaking = true;\n        Selector selector = null;\n        SelectionKey key = null;\n        try {\n            while (handshaking) {\n                int hsStatus = this.handshake(isReadable, isWriteable);\n                switch (hsStatus) {\n                    case -1 : throw new EOFException(\"EOF during handshake.\");\n                    case  0 : handshaking = false; break;\n                    default : {\n                        long now = System.currentTimeMillis();\n                        if (selector==null) {\n                            synchronized (Selector.class) {\n                                // Selector.open() isn't thread safe\n                                // http://bugs.sun.com/view_bug.do?bug_id=6427854\n                                // Affects 1.6.0_29, fixed in 1.7.0_01\n                                selector = Selector.open();\n                            }\n                            key = getIOChannel().register(selector, hsStatus);\n                        } else {\n                            key.interestOps(hsStatus);\n                        }\n                        int keyCount = selector.select(timeout);\n                        if (keyCount == 0 && ((System.currentTimeMillis()-now) >= timeout)) {\n                            throw new SocketTimeoutException(\"Handshake operation timed out.\");\n                        }\n                        isReadable = key.isReadable();\n                        isWriteable = key.isWritable();\n                    }\n                }\n            }\n        } catch (IOException x) {\n            throw x;\n        } catch (Exception cx) {\n            IOException x = new IOException(cx);\n            throw x;\n        } finally {\n            if (key!=null) try {key.cancel();} catch (Exception ignore) {}\n            if (selector!=null) try {selector.close();} catch (Exception ignore) {}\n        }\n    }",
                "    protected SSLEngineResult.HandshakeStatus tasks() {\n        Runnable r = null;\n        while ( (r = sslEngine.getDelegatedTask()) != null) {\n            r.run();\n        }\n        return sslEngine.getHandshakeStatus();\n    }\n\n    protected SSLEngineResult handshakeWrap(boolean doWrite) throws IOException {\n        //this should never be called with a network buffer that contains data\n        //so we can clear it here.\n        netOutBuffer.clear();\n        //perform the wrap\n        SSLEngineResult result = sslEngine.wrap(bufHandler.getWriteBuffer(), netOutBuffer);\n        //prepare the results to be written\n        netOutBuffer.flip();\n        //set the status\n        handshakeStatus = result.getHandshakeStatus();\n        //optimization, if we do have a writable channel, write it now\n        if ( doWrite ) flush(netOutBuffer);\n        return result;\n    }",
                "    protected SSLEngineResult handshakeUnwrap(boolean doread) throws IOException {\n\n        if (netInBuffer.position() == netInBuffer.limit()) {\n            //clear the buffer if we have emptied it out on data\n            netInBuffer.clear();\n        }\n        if ( doread )  {\n            //if we have data to read, read it\n            int read = sc.read(netInBuffer);\n            if (read == -1) throw new IOException(\"EOF encountered during handshake.\");\n        }\n        SSLEngineResult result;\n        boolean cont = false;\n        //loop while we can perform pure SSLEngine data\n        do {\n            //prepare the buffer with the incoming data\n            netInBuffer.flip();\n            //call unwrap\n            result = sslEngine.unwrap(netInBuffer, bufHandler.getReadBuffer());\n            //compact the buffer, this is an optional method, wonder what would happen if we didn't\n            netInBuffer.compact();\n            //read in the status\n            handshakeStatus = result.getHandshakeStatus();\n            if ( result.getStatus() == SSLEngineResult.Status.OK &&\n                 result.getHandshakeStatus() == HandshakeStatus.NEED_TASK ) {\n                //execute tasks if we need to\n                handshakeStatus = tasks();\n            }\n            //perform another unwrap?\n            cont = result.getStatus() == SSLEngineResult.Status.OK &&\n                   handshakeStatus == HandshakeStatus.NEED_UNWRAP;\n        }while ( cont );\n        return result;\n    }",
                "    public void close() throws IOException {\n        if (closing) return;\n        closing = true;\n        sslEngine.closeOutbound();\n\n        if (!flush(netOutBuffer)) {\n            throw new IOException(\"Remaining data in the network buffer, can't send SSL close message, force a close with close(true) instead\");\n        }\n        //prep the buffer for the close message\n        netOutBuffer.clear();\n        //perform the close, since we called sslEngine.closeOutbound\n        SSLEngineResult handshake = sslEngine.wrap(getEmptyBuf(), netOutBuffer);\n        //we should be in a close state\n        if (handshake.getStatus() != SSLEngineResult.Status.CLOSED) {\n            throw new IOException(\"Invalid close state, will not send network data.\");\n        }\n        //prepare the buffer for writing\n        netOutBuffer.flip();\n        //if there is data to be written\n        flush(netOutBuffer);\n\n        //is the channel closed?\n        closed = (!netOutBuffer.hasRemaining() && (handshake.getHandshakeStatus() != HandshakeStatus.NEED_WRAP));\n    }\n\n    public void close(boolean force) throws IOException {\n        try {\n            close();\n        }finally {\n            if ( force || closed ) {\n                closed = true;\n                sc.socket().close();\n                sc.close();\n            }\n        }\n    }",
                "    public int read(ByteBuffer dst) throws IOException {\n        //if we want to take advantage of the expand function, make sure we only use the ApplicationBufferHandler's buffers\n        if ( dst != bufHandler.getReadBuffer() ) throw new IllegalArgumentException(\"You can only read using the application read buffer provided by the handler.\");\n        //are we in the middle of closing or closed?\n        if ( closing || closed) return -1;\n        //did we finish our handshake?\n        if (!handshakeComplete) throw new IllegalStateException(\"Handshake incomplete, you must complete handshake before reading data.\");\n\n        //read from the network\n        int netread = sc.read(netInBuffer);\n        //did we reach EOF? if so send EOF up one layer.\n        if (netread == -1) return -1;\n\n        //the data read\n        int read = 0;\n        //the SSL engine result\n        SSLEngineResult unwrap;\n        do {\n            //prepare the buffer\n            netInBuffer.flip();\n            //unwrap the data\n            unwrap = sslEngine.unwrap(netInBuffer, dst);\n            //compact the buffer\n            netInBuffer.compact();\n\n            if ( unwrap.getStatus()==Status.OK || unwrap.getStatus()==Status.BUFFER_UNDERFLOW ) {\n                //we did receive some data, add it to our total\n                read += unwrap.bytesProduced();\n                //perform any tasks if needed\n                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK) tasks();\n                //if we need more network data, then bail out for now.\n                if ( unwrap.getStatus() == Status.BUFFER_UNDERFLOW ) break;\n            }else if ( unwrap.getStatus()==Status.BUFFER_OVERFLOW && read>0 ) {\n                //buffer overflow can happen, if we have read data, then\n                //empty out the dst buffer before we do another read\n                break;\n            }else {\n                //here we should trap BUFFER_OVERFLOW and call expand on the buffer\n                //for now, throw an exception, as we initialized the buffers\n                //in the constructor\n                throw new IOException(\"Unable to unwrap data, invalid status: \" + unwrap.getStatus());\n            }\n        } while ( (netInBuffer.position() != 0)); //continue to unwrapping as long as the input buffer has stuff\n        return (read);\n    }",
                "    public int write(ByteBuffer src) throws IOException {\n        if ( src == this.netOutBuffer ) {\n            //we can get here through a recursive call\n            //by using the NioBlockingSelector\n            int written = sc.write(src);\n            return written;\n        } else {\n            //make sure we can handle expand, and that we only use on buffer\n            if ( (!this.isSendFile()) && (src != bufHandler.getWriteBuffer()) ) throw new IllegalArgumentException(\"You can only write using the application write buffer provided by the handler.\");\n            //are we closing or closed?\n            if ( closing || closed) throw new IOException(\"Channel is in closing state.\");\n\n            //the number of bytes written\n            int written = 0;\n\n            if (!flush(netOutBuffer)) {\n                //we haven't emptied out the buffer yet\n                return written;\n            }\n\n            /*\n             * The data buffer is empty, we can reuse the entire buffer.\n             */\n            netOutBuffer.clear();\n\n            SSLEngineResult result = sslEngine.wrap(src, netOutBuffer);\n            written = result.bytesConsumed();\n            netOutBuffer.flip();\n\n            if (result.getStatus() == Status.OK) {\n                if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) tasks();\n            } else {\n                throw new IOException(\"Unable to wrap data, invalid engine state: \" +result.getStatus());\n            }\n\n            //force a flush\n            flush(netOutBuffer);\n\n            return written;\n        }\n    }",
                "    public boolean flushOutbound() throws IOException {\n        int remaining = netOutBuffer.remaining();\n        flush(netOutBuffer);\n        int remaining2= netOutBuffer.remaining();\n        return remaining2 < remaining;\n    }"
            ],
            "java\\org\\apache\\tomcat\\util\\net\\NioChannel.java": [
                "    public void reset() throws IOException {\n        bufHandler.getReadBuffer().clear();\n        bufHandler.getWriteBuffer().clear();\n        this.sendFile = false;\n    }\n\n    public void close() throws IOException {\n        getIOChannel().socket().close();\n        getIOChannel().close();\n    }\n\n    public void close(boolean force) throws IOException {\n        if (isOpen() || force ) close();\n    }"
            ],
            "java\\org\\apache\\catalina\\core\\AsyncContextImpl.java": [
                "    public void complete() {\n        if (log.isDebugEnabled()) {\n            logDebug(\"complete   \");\n        }\n        check();\n        request.getCoyoteRequest().action(ActionCode.COMMIT, null);\n        request.getCoyoteRequest().action(ActionCode.ASYNC_COMPLETE, null);\n    }",
                "    public void fireOnComplete() {\n        List<AsyncListenerWrapper> listenersCopy =\n            new ArrayList<AsyncListenerWrapper>();\n        listenersCopy.addAll(listeners);\n\n        ClassLoader oldCL;\n        if (Globals.IS_SECURITY_ENABLED) {\n            PrivilegedAction<ClassLoader> pa = new PrivilegedGetTccl();\n            oldCL = AccessController.doPrivileged(pa);\n        } else {\n            oldCL = Thread.currentThread().getContextClassLoader();\n        }\n        ClassLoader newCL = context.getLoader().getClassLoader();\n\n        try {\n            if (Globals.IS_SECURITY_ENABLED) {\n                PrivilegedAction<Void> pa = new PrivilegedSetTccl(newCL);\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(newCL);\n            }\n            for (AsyncListenerWrapper listener : listenersCopy) {\n                try {\n                    listener.fireOnComplete(event);\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.warn(\"onComplete() failed for listener of type [\" +\n                            listener.getClass().getName() + \"]\", t);\n                }\n            }\n        } finally {\n            if (Globals.IS_SECURITY_ENABLED) {\n                PrivilegedAction<Void> pa = new PrivilegedSetTccl(oldCL);\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(oldCL);\n            }\n        }\n    }",
                "    public boolean timeout() {\n        AtomicBoolean result = new AtomicBoolean();\n        request.getCoyoteRequest().action(ActionCode.ASYNC_TIMEOUT, result);\n\n        if (result.get()) {\n\n            ClassLoader oldCL = Thread.currentThread().getContextClassLoader();\n            ClassLoader newCL = request.getContext().getLoader().getClassLoader();\n            try {\n                Thread.currentThread().setContextClassLoader(newCL);\n                List<AsyncListenerWrapper> listenersCopy =\n                    new ArrayList<AsyncListenerWrapper>();\n                listenersCopy.addAll(listeners);\n                for (AsyncListenerWrapper listener : listenersCopy) {\n                    try {\n                        listener.fireOnTimeout(event);\n                    } catch (Throwable t) {\n                        ExceptionUtils.handleThrowable(t);\n                        log.warn(\"onTimeout() failed for listener of type [\" +\n                                listener.getClass().getName() + \"]\", t);\n                    }\n                }\n                request.getCoyoteRequest().action(\n                        ActionCode.ASYNC_IS_TIMINGOUT, result);\n                return !result.get();\n            } finally {\n                Thread.currentThread().setContextClassLoader(oldCL);\n            }\n        }\n        return true;\n    }",
                "    public void dispatch() {\n        check();\n        String path;\n        String pathInfo;\n        ServletRequest servletRequest = getRequest();\n        if (servletRequest instanceof HttpServletRequest) {\n            HttpServletRequest sr = (HttpServletRequest) servletRequest;\n            path = sr.getServletPath();\n            pathInfo = sr.getPathInfo();\n        } else {\n            path = request.getServletPath();\n            pathInfo = request.getPathInfo();\n        }\n        if (pathInfo != null) {\n            path += pathInfo;\n        }\n        dispatch(path);\n    }",
                "    public void dispatch(ServletContext context, String path) {\n        if (log.isDebugEnabled()) {\n            logDebug(\"dispatch   \");\n        }\n        check();\n        if (dispatch != null) {\n            throw new IllegalStateException(\n                    sm.getString(\"asyncContextImpl.dispatchingStarted\"));\n        }\n        if (request.getAttribute(ASYNC_REQUEST_URI)==null) {\n            request.setAttribute(ASYNC_REQUEST_URI, request.getRequestURI());\n            request.setAttribute(ASYNC_CONTEXT_PATH, request.getContextPath());\n            request.setAttribute(ASYNC_SERVLET_PATH, request.getServletPath());\n            request.setAttribute(ASYNC_PATH_INFO, request.getPathInfo());\n            request.setAttribute(ASYNC_QUERY_STRING, request.getQueryString());\n        }\n        final RequestDispatcher requestDispatcher = context.getRequestDispatcher(path);\n        if (!(requestDispatcher instanceof AsyncDispatcher)) {\n            throw new UnsupportedOperationException(\n                    sm.getString(\"asyncContextImpl.noAsyncDispatcher\"));\n        }\n        final AsyncDispatcher applicationDispatcher =\n                (AsyncDispatcher) requestDispatcher;\n        final ServletRequest servletRequest = getRequest();\n        final ServletResponse servletResponse = getResponse();\n        Runnable run = new Runnable() {\n            @Override\n            public void run() {\n                request.getCoyoteRequest().action(ActionCode.ASYNC_DISPATCHED, null);\n                try {\n                    applicationDispatcher.dispatch(servletRequest, servletResponse);\n                }catch (Exception x) {\n                    //log.error(\"Async.dispatch\",x);\n                    throw new RuntimeException(x);\n                }\n            }\n        };\n\n        this.dispatch = run;\n        this.request.getCoyoteRequest().action(ActionCode.ASYNC_DISPATCH, null);\n    }",
                "    public void start(final Runnable run) {\n        if (log.isDebugEnabled()) {\n            logDebug(\"start      \");\n        }\n        check();\n        Runnable wrapper = new RunnableWrapper(run, context);\n        this.request.getCoyoteRequest().action(ActionCode.ASYNC_RUN, wrapper);\n    }\n\n    public void recycle() {\n        if (log.isDebugEnabled()) {\n            logDebug(\"recycle    \");\n        }\n        context = null;\n        dispatch = null;\n        event = null;\n        hasOriginalRequestAndResponse = true;\n        instanceManager = null;\n        listeners.clear();\n        request = null;\n        servletRequest = null;\n        servletResponse = null;\n        timeout = -1;\n    }",
                "    protected void doInternalDispatch() throws ServletException, IOException {\n        if (log.isDebugEnabled()) {\n            logDebug(\"intDispatch\");\n        }\n        try {\n            Runnable runnable = dispatch;\n            dispatch = null;\n            runnable.run();\n            if (!request.isAsync()) {\n                fireOnComplete();\n            }\n        } catch (RuntimeException x) {\n            // doInternalComplete(true);\n            if (x.getCause() instanceof ServletException) {\n                throw (ServletException)x.getCause();\n            }\n            if (x.getCause() instanceof IOException) {\n                throw (IOException)x.getCause();\n            }\n            throw new ServletException(x);\n        }\n    }",
                "    private void logDebug(String method) {\n        String rHashCode;\n        String crHashCode;\n        String rpHashCode;\n        String stage;\n        StringBuilder uri = new StringBuilder();\n        if (request == null) {\n            rHashCode = \"null\";\n            crHashCode = \"null\";\n            rpHashCode = \"null\";\n            stage = \"-\";\n            uri.append(\"N/A\");\n        } else {\n            rHashCode = Integer.toHexString(request.hashCode());\n            org.apache.coyote.Request coyoteRequest = request.getCoyoteRequest();\n            if (coyoteRequest == null) {\n                crHashCode = \"null\";\n                rpHashCode = \"null\";\n                stage = \"-\";\n            } else {\n                crHashCode = Integer.toHexString(coyoteRequest.hashCode());\n                RequestInfo rp = coyoteRequest.getRequestProcessor();\n                if (rp == null) {\n                    rpHashCode = \"null\";\n                    stage = \"-\";\n                } else {\n                    rpHashCode = Integer.toHexString(rp.hashCode());\n                    stage = Integer.toString(rp.getStage());\n                }\n            }\n            uri.append(request.getRequestURI());\n            if (request.getQueryString() != null) {\n                uri.append('?');\n                uri.append(request.getQueryString());\n            }\n        }\n        String threadName = Thread.currentThread().getName();\n        int len = threadName.length();\n        if (len > 20) {\n            threadName = threadName.substring(len - 20, len);\n        }\n        String msg = String.format(\n                \"Req: %1$8s  CReq: %2$8s  RP: %3$8s  Stage: %4$s  \" +\n                \"Thread: %5$20s  State: %6$20s  Method: %7$11s  URI: %8$s\",\n                rHashCode, crHashCode, rpHashCode, stage,\n                threadName, \"N/A\", method, uri);\n        if (log.isTraceEnabled()) {\n            log.trace(msg, new DebugException());\n        } else {\n            log.debug(msg);\n        }\n    }",
                "    private void check() {\n        if (request == null) {\n            // AsyncContext has been recycled and should not be being used\n            throw new IllegalStateException(sm.getString(\n                    \"asyncContextImpl.requestEnded\"));\n        }\n    }"
            ],
            "java\\org\\apache\\tomcat\\util\\net\\NioSelectorPool.java": [
                "    public void put(Selector s) throws IOException {\n        if ( SHARED ) return;\n        if ( enabled ) active.decrementAndGet();\n        if ( enabled && (maxSpareSelectors==-1 || spare.get() < Math.min(maxSpareSelectors,maxSelectors)) ) {\n            spare.incrementAndGet();\n            selectors.offer(s);\n        }\n        else s.close();\n    }\n\n    public void close() throws IOException {\n        enabled = false;\n        Selector s;\n        while ( (s = selectors.poll()) != null ) s.close();\n        spare.set(0);\n        active.set(0);\n        if (blockingSelector!=null) {\n            blockingSelector.close();\n        }\n        if ( SHARED && getSharedSelector()!=null ) {\n            getSharedSelector().close();\n            SHARED_SELECTOR = null;\n        }\n    }\n\n    public void open() throws IOException {\n        enabled = true;\n        getSharedSelector();\n        if (SHARED) {\n            blockingSelector = new NioBlockingSelector();\n            blockingSelector.open(getSharedSelector());\n        }\n\n    }",
                "    public int write(ByteBuffer buf, NioChannel socket, Selector selector, long writeTimeout) throws IOException {\n        return write(buf,socket,selector,writeTimeout,true);\n    }\n\n    public int read(ByteBuffer buf, NioChannel socket, Selector selector, long readTimeout) throws IOException {\n        return read(buf,socket,selector,readTimeout,true);\n    }",
                "    public int read(ByteBuffer buf, NioChannel socket, Selector selector, long readTimeout, boolean block) throws IOException {\n        if ( SHARED && block ) {\n            return blockingSelector.read(buf,socket,readTimeout);\n        }\n        SelectionKey key = null;\n        int read = 0;\n        boolean timedout = false;\n        int keycount = 1; //assume we can write\n        long time = System.currentTimeMillis(); //start the timeout timer\n        try {\n            while ( (!timedout) ) {\n                int cnt = 0;\n                if ( keycount > 0 ) { //only read if we were registered for a read\n                    cnt = socket.read(buf);\n                    if (cnt == -1) throw new EOFException();\n                    read += cnt;\n                    if (cnt > 0) continue; //read some more\n                    if (cnt==0 && (read>0 || (!block) ) ) break; //we are done reading\n                }\n                if ( selector != null ) {//perform a blocking read\n                    //register OP_WRITE to the selector\n                    if (key==null) key = socket.getIOChannel().register(selector, SelectionKey.OP_READ);\n                    else key.interestOps(SelectionKey.OP_READ);\n                    keycount = selector.select(readTimeout);\n                }\n                if (readTimeout > 0 && (selector == null || keycount == 0) ) timedout = (System.currentTimeMillis()-time)>=readTimeout;\n            }//while\n            if ( timedout ) throw new SocketTimeoutException();\n        } finally {\n            if (key != null) {\n                key.cancel();\n                if (selector != null) selector.selectNow();//removes the key from this selector\n            }\n        }\n        return read;\n    }"
            ],
            "java\\org\\apache\\coyote\\ajp\\AjpNioProcessor.java": [
                "    protected void actionInternal(ActionCode actionCode, Object param) {\n\n        if (actionCode == ActionCode.ASYNC_COMPLETE) {\n            if (asyncStateMachine.asyncComplete()) {\n                ((NioEndpoint)endpoint).processSocket(this.socket,\n                        SocketStatus.OPEN_READ, false);\n            }\n\n        } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {\n            if (param == null) return;\n            long timeout = ((Long)param).longValue();\n            final KeyAttachment ka = (KeyAttachment)socket.getAttachment(false);\n            ka.setTimeout(timeout);\n\n        } else if (actionCode == ActionCode.ASYNC_DISPATCH) {\n            if (asyncStateMachine.asyncDispatch()) {\n                ((NioEndpoint)endpoint).processSocket(this.socket,\n                        SocketStatus.OPEN_READ, true);\n            }\n        }\n    }\n\n    protected void resetTimeouts() {\n        // The NIO connector uses the timeout configured on the wrapper in the\n        // poller. Therefore, it needs to be reset once asycn processing has\n        // finished.\n        final KeyAttachment attach = (KeyAttachment)socket.getAttachment(false);\n        if (!error && attach != null &&\n                asyncStateMachine.isAsyncDispatching()) {\n            long soTimeout = endpoint.getSoTimeout();\n\n            //reset the timeout\n            if (keepAliveTimeout > 0) {\n                attach.setTimeout(keepAliveTimeout);\n            } else {\n                attach.setTimeout(soTimeout);\n            }\n        }\n\n    }",
                "    public boolean receive() throws IOException {\n\n        first = false;\n        bodyMessage.reset();\n        \n        readMessage(bodyMessage, true);\n\n        // No data received.\n        if (bodyMessage.getLen() == 0) {\n            // just the header\n            // Don't mark 'end of stream' for the first chunk.\n            return false;\n        }\n        int blen = bodyMessage.peekInt();\n        if (blen == 0) {\n            return false;\n        }\n\n        bodyMessage.getBodyBytes(bodyBytes);\n        empty = false;\n        return true;\n    }"
            ],
            "test\\org\\apache\\catalina\\valves\\TesterAccessLogValve.java": [
                "    public void invoke(Request request, Response response) throws IOException,"
            ],
            "modules\\jdbc-pool\\src\\test\\java\\org\\apache\\tomcat\\jdbc\\test\\TestSizePreservation.java": [
                "    private void initSimplePoolProperties() {\n        PoolConfiguration p = new DefaultProperties();\n        ds = new org.apache.tomcat.jdbc.pool.DataSource();\n        ds.setPoolProperties(p);\n\n        ds.getPoolProperties().setDriverClassName(Driver.class.getName());\n        ds.getPoolProperties().setUrl(Driver.url);\n        ds.getPoolProperties().setFairQueue(true);\n        ds.getPoolProperties().setJmxEnabled(false);\n        ds.getPoolProperties().setTestWhileIdle(true);\n        ds.getPoolProperties().setTestOnBorrow(false);\n        ds.getPoolProperties().setTestOnReturn(false);\n        ds.getPoolProperties().setValidationInterval(30000);\n        ds.getPoolProperties().setTimeBetweenEvictionRunsMillis(30000);\n        ds.getPoolProperties().setInitialSize(100);\n        ds.getPoolProperties().setMaxActive(100);\n        ds.getPoolProperties().setMinIdle(0);\n        ds.getPoolProperties().setMaxIdle(0);\n        ds.getPoolProperties().setMaxWait(10000);\n        ds.getPoolProperties().setRemoveAbandonedTimeout(10);\n        ds.getPoolProperties().setMinEvictableIdleTimeMillis(10000);\n        ds.getPoolProperties().setLogAbandoned(false);\n        ds.getPoolProperties().setRemoveAbandoned(false);\n        ds.getPoolProperties().setUseLock(true);\n    }\n\n    public void testSimple() throws Exception {\n        initSimplePoolProperties();\n        common();\n        ds.close(true);\n        Driver.reset();\n    }\n\n    public void testEvicting() throws Exception {\n        initEvictingPool();\n        common();\n        ds.close(true);\n        Driver.reset();\n    }",
                "    private void common() throws Exception {\n        ds.getConnection().close();\n        final int iterations = 1000;\n        final AtomicInteger loopcount = new AtomicInteger(0);\n        final Runnable run = new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    while (loopcount.incrementAndGet() < iterations) {\n                        Connection c = ds.getConnection();\n                        Thread.sleep(1000);\n                        c.close();\n                    }\n                } catch (Exception x) {\n                    x.printStackTrace();\n                }\n            }\n        };\n        Thread[] threads = new Thread[200];\n        for (int i = 0; i < threads.length; i++) {\n            threads[i] = new Thread(run);\n        }\n        for (int i = 0; i < threads.length; i++) {\n            threads[i].start();\n        }\n        try {\n            while (loopcount.get() < iterations) {\n                Thread.sleep(250);\n            }\n        } catch (Exception x) {\n            loopcount.set(iterations); // stops the test\n            x.printStackTrace();\n        }\n        for (int i = 0; i < threads.length; i++) {\n            threads[i].join();\n        }\n        System.out.println(\"Pool size:\"+ds.getPool().getSize());\n        Assert.assertTrue(\"Size validity check: \", ds.getPool().getSize() >= 0);\n    }"
            ],
            "java\\org\\apache\\coyote\\http11\\Http11NioProcessor.java": [
                "    protected void resetTimeouts() {\n        final NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socket.getSocket().getAttachment(false);\n        if (!error && attach != null &&\n                asyncStateMachine.isAsyncDispatching()) {\n            long soTimeout = endpoint.getSoTimeout();\n\n            //reset the timeout\n            if (keepAlive) {\n                attach.setTimeout(keepAliveTimeout);\n            } else {\n                attach.setTimeout(soTimeout);\n            }\n        }\n    }",
                "    protected boolean handleIncompleteRequestLineRead() {\n        // Haven't finished reading the request so keep the socket\n        // open\n        openSocket = true;\n        // Check to see if we have read any of the request line yet\n        if (inputBuffer.getParsingRequestLinePhase() < 2) {\n            if (socket.getLastAccess() > -1 || keptAlive) {\n                // Haven't read the request line and have previously processed a\n                // request. Must be keep-alive. Make sure poller uses keepAlive.\n                socket.setTimeout(endpoint.getKeepAliveTimeout());\n            }\n        } else {\n            // Started to read request line. Need to keep processor\n            // associated with socket\n            readComplete = false;\n            // Make sure poller uses soTimeout from here onwards\n            socket.setTimeout(endpoint.getSoTimeout());\n        }\n        if (endpoint.isPaused()) {\n            // 503 - Service unavailable\n            response.setStatus(503);\n            adapter.log(request, response, 0);\n            error = true;\n        } else {\n            return true;\n        }\n        return false;\n    }",
                "    public void actionInternal(ActionCode actionCode, Object param) {\n\n        if (actionCode == ActionCode.REQ_HOST_ADDR_ATTRIBUTE) {\n\n            // Get remote host address\n            if ((remoteAddr == null) && (socket != null)) {\n                InetAddress inetAddr = socket.getSocket().getIOChannel().socket().getInetAddress();\n                if (inetAddr != null) {\n                    remoteAddr = inetAddr.getHostAddress();\n                }\n            }\n            request.remoteAddr().setString(remoteAddr);\n\n        } else if (actionCode == ActionCode.REQ_LOCAL_NAME_ATTRIBUTE) {\n\n            // Get local host name\n            if ((localName == null) && (socket != null)) {\n                InetAddress inetAddr = socket.getSocket().getIOChannel().socket().getLocalAddress();\n                if (inetAddr != null) {\n                    localName = inetAddr.getHostName();\n                }\n            }\n            request.localName().setString(localName);\n\n        } else if (actionCode == ActionCode.REQ_HOST_ATTRIBUTE) {\n\n            // Get remote host name\n            if ((remoteHost == null) && (socket != null)) {\n                InetAddress inetAddr = socket.getSocket().getIOChannel().socket().getInetAddress();\n                if (inetAddr != null) {\n                    remoteHost = inetAddr.getHostName();\n                }\n                if(remoteHost == null) {\n                    if(remoteAddr != null) {\n                        remoteHost = remoteAddr;\n                    } else { // all we can do is punt\n                        request.remoteHost().recycle();\n                    }\n                }\n            }\n            request.remoteHost().setString(remoteHost);\n\n        } else if (actionCode == ActionCode.REQ_LOCAL_ADDR_ATTRIBUTE) {\n\n            if (localAddr == null) {\n                localAddr = socket.getSocket().getIOChannel().socket().getLocalAddress().getHostAddress();\n            }\n\n            request.localAddr().setString(localAddr);\n\n        } else if (actionCode == ActionCode.REQ_REMOTEPORT_ATTRIBUTE) {\n\n            if ((remotePort == -1 ) && (socket !=null)) {\n                remotePort = socket.getSocket().getIOChannel().socket().getPort();\n            }\n            request.setRemotePort(remotePort);\n\n        } else if (actionCode == ActionCode.REQ_LOCALPORT_ATTRIBUTE) {\n\n            if ((localPort == -1 ) && (socket !=null)) {\n                localPort = socket.getSocket().getIOChannel().socket().getLocalPort();\n            }\n            request.setLocalPort(localPort);\n\n        } else if (actionCode == ActionCode.REQ_SSL_ATTRIBUTE ) {\n\n            try {\n                if (sslSupport != null) {\n                    Object sslO = sslSupport.getCipherSuite();\n                    if (sslO != null) {\n                        request.setAttribute\n                            (SSLSupport.CIPHER_SUITE_KEY, sslO);\n                    }\n                    sslO = sslSupport.getPeerCertificateChain(false);\n                    if (sslO != null) {\n                        request.setAttribute\n                            (SSLSupport.CERTIFICATE_KEY, sslO);\n                    }\n                    sslO = sslSupport.getKeySize();\n                    if (sslO != null) {\n                        request.setAttribute\n                            (SSLSupport.KEY_SIZE_KEY, sslO);\n                    }\n                    sslO = sslSupport.getSessionId();\n                    if (sslO != null) {\n                        request.setAttribute\n                            (SSLSupport.SESSION_ID_KEY, sslO);\n                    }\n                    request.setAttribute(SSLSupport.SESSION_MGR, sslSupport);\n                }\n            } catch (Exception e) {\n                log.warn(sm.getString(\"http11processor.socket.ssl\"), e);\n            }\n\n        } else if (actionCode == ActionCode.REQ_SSL_CERTIFICATE) {\n\n            if( sslSupport != null) {\n                /*\n                 * Consume and buffer the request body, so that it does not\n                 * interfere with the client's handshake messages\n                 */\n                InputFilter[] inputFilters = inputBuffer.getFilters();\n                ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER])\n                    .setLimit(maxSavePostSize);\n                inputBuffer.addActiveFilter\n                    (inputFilters[Constants.BUFFERED_FILTER]);\n                SecureNioChannel sslChannel = (SecureNioChannel) socket.getSocket();\n                SSLEngine engine = sslChannel.getSslEngine();\n                if (!engine.getNeedClientAuth()) {\n                    // Need to re-negotiate SSL connection\n                    engine.setNeedClientAuth(true);\n                    try {\n                        sslChannel.rehandshake(endpoint.getSoTimeout());\n                        sslSupport = ((NioEndpoint)endpoint).getHandler()\n                                .getSslImplementation().getSSLSupport(\n                                        engine.getSession());\n                    } catch (IOException ioe) {\n                        log.warn(sm.getString(\"http11processor.socket.sslreneg\",ioe));\n                    }\n                }\n\n                try {\n                    // use force=false since re-negotiation is handled above\n                    // (and it is a NO-OP for NIO anyway)\n                    Object sslO = sslSupport.getPeerCertificateChain(false);\n                    if( sslO != null) {\n                        request.setAttribute\n                            (SSLSupport.CERTIFICATE_KEY, sslO);\n                    }\n                } catch (Exception e) {\n                    log.warn(sm.getString(\"http11processor.socket.ssl\"), e);\n                }\n            }\n\n        } else if (actionCode == ActionCode.AVAILABLE) {\n            request.setAvailable(inputBuffer.available());\n        } else if (actionCode == ActionCode.COMET_BEGIN) {\n            comet = true;\n        } else if (actionCode == ActionCode.COMET_END) {\n            comet = false;\n        }  else if (actionCode == ActionCode.COMET_CLOSE) {\n            if (socket==null || socket.getSocket().getAttachment(false)==null) {\n                return;\n            }\n            NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socket.getSocket().getAttachment(false);\n            attach.setCometOps(NioEndpoint.OP_CALLBACK);\n            RequestInfo rp = request.getRequestProcessor();\n            if (rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE) {\n                // Close event for this processor triggered by request\n                // processing in another processor, a non-Tomcat thread (i.e.\n                // an application controlled thread) or similar.\n                socket.getSocket().getPoller().add(socket.getSocket());\n            }\n        } else if (actionCode == ActionCode.COMET_SETTIMEOUT) {\n            if (param==null) {\n                return;\n            }\n            if (socket==null || socket.getSocket().getAttachment(false)==null) {\n                return;\n            }\n            NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socket.getSocket().getAttachment(false);\n            long timeout = ((Long)param).longValue();\n            //if we are not piggy backing on a worker thread, set the timeout\n            RequestInfo rp = request.getRequestProcessor();\n            if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) {\n                attach.setTimeout(timeout);\n            }\n        } else if (actionCode == ActionCode.ASYNC_COMPLETE) {\n            if (asyncStateMachine.asyncComplete()) {\n                ((NioEndpoint)endpoint).processSocket(this.socket.getSocket(),\n                        SocketStatus.OPEN_READ, true);\n            }\n        } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {\n            if (param==null) {\n                return;\n            }\n            if (socket==null || socket.getSocket().getAttachment(false)==null) {\n                return;\n            }\n            NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socket.getSocket().getAttachment(false);\n            long timeout = ((Long)param).longValue();\n            //if we are not piggy backing on a worker thread, set the timeout\n            attach.setTimeout(timeout);\n        } else if (actionCode == ActionCode.ASYNC_DISPATCH) {\n            if (asyncStateMachine.asyncDispatch()) {\n                ((NioEndpoint)endpoint).processSocket(this.socket.getSocket(),\n                        SocketStatus.OPEN_READ, true);\n            }\n        }\n    }",
                "    protected boolean prepareSendfile(OutputFilter[] outputFilters) {\n        String fileName = (String) request.getAttribute(\n                org.apache.coyote.Constants.SENDFILE_FILENAME_ATTR);\n        if (fileName != null) {\n            // No entity body sent here\n            outputBuffer.addActiveFilter(outputFilters[Constants.VOID_FILTER]);\n            contentDelimitation = true;\n            sendfileData = new NioEndpoint.SendfileData();\n            sendfileData.fileName = fileName;\n            sendfileData.pos = ((Long) request.getAttribute(\n                    org.apache.coyote.Constants.SENDFILE_FILE_START_ATTR)).longValue();\n            sendfileData.length = ((Long) request.getAttribute(\n                    org.apache.coyote.Constants.SENDFILE_FILE_END_ATTR)).longValue() - sendfileData.pos;\n            return true;\n        }\n        return false;\n    }"
            ],
            "java\\org\\apache\\coyote\\http11\\upgrade\\UpgradeInbound.java": [
                "    SocketState onData() throws IOException;"
            ],
            "test\\org\\apache\\catalina\\core\\TestAsyncContextImpl.java": [
                "    public void testBug49528() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        Bug49528Servlet servlet = new Bug49528Servlet();\n\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"servlet\", servlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        // Call the servlet once\n        ByteChunk bc = getUrl(\"http://localhost:\" + getPort() + \"/\");\n        assertEquals(\"OK\", bc.toString());\n\n        // Give the async thread a chance to finish (but not too long)\n        int counter = 0;\n        while (!servlet.isDone() && counter < 10) {\n            Thread.sleep(1000);\n            counter++;\n        }\n\n        assertEquals(\"1false2true3true4true5false\", servlet.getResult());\n\n        // Check the access log\n        alv.validateAccessLog(1, 200, Bug49528Servlet.THREAD_SLEEP_TIME,\n                Bug49528Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);\n    }",
                "    public void testBug49567() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        Bug49567Servlet servlet = new Bug49567Servlet();\n\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"servlet\", servlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        // Call the servlet once\n        ByteChunk bc = getUrl(\"http://localhost:\" + getPort() + \"/\");\n        assertEquals(\"OK\", bc.toString());\n\n        // Give the async thread a chance to finish (but not too long)\n        int counter = 0;\n        while (!servlet.isDone() && counter < 10) {\n            Thread.sleep(1000);\n            counter++;\n        }\n\n        assertEquals(\"1false2true3true4true5false\", servlet.getResult());\n\n        // Check the access log\n        alv.validateAccessLog(1, 200, Bug49567Servlet.THREAD_SLEEP_TIME,\n                Bug49567Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);\n    }",
                "    public void testAsyncStartNoComplete() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Minimise pauses during test\n        tomcat.getConnector().setAttribute(\n                \"connectionTimeout\", Integer.valueOf(3000));\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        AsyncStartNoCompleteServlet servlet =\n            new AsyncStartNoCompleteServlet();\n\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"servlet\", servlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        // Call the servlet the first time\n        ByteChunk bc1 = getUrl(\"http://localhost:\" + getPort() +\n                \"/?echo=run1\");\n        assertEquals(\"OK-run1\", bc1.toString());\n\n        // Call the servlet the second time with a request parameter\n        ByteChunk bc2 = getUrl(\"http://localhost:\" + getPort() +\n                \"/?echo=run2\");\n        assertEquals(\"OK-run2\", bc2.toString());\n\n        // Check the access log\n        alv.validateAccessLog(2, 500,\n                AsyncStartNoCompleteServlet.ASYNC_TIMEOUT,\n                AsyncStartNoCompleteServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN +\n                        REQUEST_TIME);\n    }",
                "    public void testAsyncStartWithComplete() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        AsyncStartWithCompleteServlet servlet =\n            new AsyncStartWithCompleteServlet();\n\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"servlet\", servlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        // Call the servlet once\n        ByteChunk bc = getUrl(\"http://localhost:\" + getPort() + \"/\");\n        assertEquals(\"OK\", bc.toString());\n\n        // Check the access log\n        alv.validateAccessLog(1, 200, 0, REQUEST_TIME);\n    }\n\n    public void testTimeoutListenerCompleteNoDispatch() throws Exception {\n        // Should work\n        doTestTimeout(Boolean.TRUE, null);\n    }\n\n    public void testTimeoutListenerNoCompleteNoDispatch() throws Exception {\n        // Should trigger an error - must do one or other\n        doTestTimeout(Boolean.FALSE, null);\n    }",
                "    public void testTimeoutListenerCompleteNonAsyncDispatch() throws Exception {\n        // Should trigger an error - can't do both\n        doTestTimeout(Boolean.TRUE, Boolean.FALSE);\n    }\n\n    public void testTimeoutListenerCompleteAsyncDispatch() throws Exception {\n        // Should trigger an error - can't do both\n        doTestTimeout(Boolean.TRUE, Boolean.TRUE);\n    }\n\n    public void testTimeoutNoListener() throws Exception {\n        // Should work\n        doTestTimeout(null, null);\n    }",
                "    public void testDispatchDouble() throws Exception {\n        doTestDispatch(2, false);\n    }\n\n    public void testDispatchWithThreadSingle() throws Exception {\n        doTestDispatch(1, true);\n    }\n\n    public void testDispatchWithThreadDouble() throws Exception {\n        doTestDispatch(2, true);\n    }",
                "    public void testDispatchWithThreadMultiple() throws Exception {\n        doTestDispatch(5, true);\n    }",
                "    private void doTestDispatch(int iter, boolean useThread) throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        DispatchingServlet dispatch = new DispatchingServlet(false, false);\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"dispatch\", dispatch);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/stage1\", \"dispatch\");\n\n        NonAsyncServlet nonasync = new NonAsyncServlet();\n        Wrapper wrapper2 = Tomcat.addServlet(ctx, \"nonasync\", nonasync);\n        wrapper2.setAsyncSupported(true);\n        ctx.addServletMapping(\"/stage2\", \"nonasync\");\n\n        ctx.addApplicationListener(new ApplicationListener(\n                TrackingRequestListener.class.getName(), false));\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/stage1?iter=\");\n        url.append(iter);\n        if (useThread) {\n            url.append(\"&useThread=y\");\n        }\n        ByteChunk res = getUrl(url.toString());\n\n        StringBuilder expected = new StringBuilder(\"requestInitialized-\");\n        int loop = iter;\n        while (loop > 0) {\n            expected.append(\"DispatchingServletGet-\");\n            loop--;\n        }\n        expected.append(\"NonAsyncServletGet-\");\n        expected.append(\"requestDestroyed\");\n        assertEquals(expected.toString(), res.toString());\n\n        // Check the access log\n        alv.validateAccessLog(1, 200, 0, REQUEST_TIME);\n    }",
                "    public void testListeners() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        TrackingServlet tracking = new TrackingServlet();\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"tracking\", tracking);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/stage1\", \"tracking\");\n\n        TimeoutServlet timeout = new TimeoutServlet(Boolean.TRUE, null);\n        Wrapper wrapper2 = Tomcat.addServlet(ctx, \"timeout\", timeout);\n        wrapper2.setAsyncSupported(true);\n        ctx.addServletMapping(\"/stage2\", \"timeout\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/stage1\");\n\n        ByteChunk res = getUrl(url.toString());\n\n        assertEquals(\n                \"DispatchingServletGet-DispatchingServletGet-onStartAsync-\" +\n                \"TimeoutServletGet-onStartAsync-onTimeout-onComplete-\",\n                res.toString());\n\n        // Check the access log\n        alv.validateAccessLog(1, 200, TimeoutServlet.ASYNC_TIMEOUT,\n                TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN + REQUEST_TIME);\n    }",
                "    public void testDispatchErrorDouble() throws Exception {\n        doTestDispatchError(2, false, false);\n    }\n\n    public void testDispatchErrorWithThreadSingle() throws Exception {\n        doTestDispatchError(1, true, false);\n    }\n\n    public void testDispatchErrorWithThreadDouble() throws Exception {\n        doTestDispatchError(2, true, false);\n    }",
                "    public void testDispatchErrorWithThreadMultiple() throws Exception {\n        doTestDispatchError(5, true, false);\n    }\n\n    public void testDispatchErrorDoubleThenComplete() throws Exception {\n        doTestDispatchError(2, false, true);\n    }\n\n    public void testBug50352() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        AsyncStartRunnable servlet = new AsyncStartRunnable();\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"servlet\", servlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/\");\n\n        assertEquals(\"Runnable-onComplete-\", res.toString());\n\n        // Check the access log\n        alv.validateAccessLog(1, 200, AsyncStartRunnable.THREAD_SLEEP_TIME,\n                AsyncStartRunnable.THREAD_SLEEP_TIME + REQUEST_TIME);\n    }",
                "    public void testBug50753() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        Bug50753Servlet servlet = new Bug50753Servlet();\n\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"servlet\", servlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        // Call the servlet once\n        Map<String,List<String>> headers =\n            new LinkedHashMap<String,List<String>>();\n        ByteChunk bc = new ByteChunk();\n        int rc = getUrl(\"http://localhost:\" + getPort() + \"/\", bc, headers);\n        assertEquals(200, rc);\n        assertEquals(\"OK\", bc.toString());\n        List<String> testHeader = headers.get(\"A\");\n        assertNotNull(testHeader);\n        assertEquals(1, testHeader.size());\n        assertEquals(\"xyz\",testHeader.get(0));\n\n        // Check the access log\n        alv.validateAccessLog(1, 200, Bug50753Servlet.THREAD_SLEEP_TIME,\n                Bug50753Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);\n    }",
                "    public void testErrorHandling() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        ErrorServlet error = new ErrorServlet(false);\n        Tomcat.addServlet(ctx, \"error\", error);\n        ctx.addServletMapping(\"/error\", \"error\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/error\");\n\n        int rc = getUrl(url.toString(), new ByteChunk(), null);\n\n        assertEquals(500, rc);\n\n        // Without this test may complete before access log has a chance to log\n        // the request\n        Thread.sleep(REQUEST_TIME);\n\n        // Check the access log\n        alv.validateAccessLog(1, 500, 0, REQUEST_TIME);\n    }",
                "    public void testCommitOnComplete() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        AsyncStatusServlet asyncStatusServlet =\n            new AsyncStatusServlet(HttpServletResponse.SC_BAD_REQUEST);\n        Wrapper wrapper =\n            Tomcat.addServlet(ctx, \"asyncStatusServlet\", asyncStatusServlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/asyncStatusServlet\", \"asyncStatusServlet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/asyncStatusServlet\");\n\n        int rc = getUrl(url.toString(), new ByteChunk(), null);\n\n        assertEquals(HttpServletResponse.SC_BAD_REQUEST, rc);\n\n        // Without this test may complete before access log has a chance to log\n        // the request\n        Thread.sleep(REQUEST_TIME);\n\n        // Check the access log\n        alv.validateAccessLog(1, HttpServletResponse.SC_BAD_REQUEST, 0,\n                REQUEST_TIME);\n\n    }",
                "    private void doTestBug51197(boolean threaded) throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        AsyncErrorServlet asyncErrorServlet =\n            new AsyncErrorServlet(HttpServletResponse.SC_BAD_REQUEST, threaded);\n        Wrapper wrapper =\n            Tomcat.addServlet(ctx, \"asyncErrorServlet\", asyncErrorServlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/asyncErrorServlet\", \"asyncErrorServlet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/asyncErrorServlet\");\n\n        ByteChunk res = new ByteChunk();\n        int rc = getUrl(url.toString(), res, null);\n\n        assertEquals(HttpServletResponse.SC_BAD_REQUEST, rc);\n\n        // SRV 10.9.2 - Writing the response is entirely the application's\n        // responsibility when an error occurs on an application thread.\n        // The test servlet writes no content in this case.\n        if (threaded) {\n            assertEquals(0, res.getLength());\n        } else {\n            assertTrue(res.getLength() > 0);\n        }\n\n        // Without this test may complete before access log has a chance to log\n        // the request\n        Thread.sleep(REQUEST_TIME);\n\n        // Check the access log\n        alv.validateAccessLog(1, HttpServletResponse.SC_BAD_REQUEST, 0,\n                REQUEST_TIME);\n    }",
                "    public void testBug53337() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n        Wrapper a = Tomcat.addServlet(ctx, \"ServletA\", new Bug53337ServletA());\n        a.setAsyncSupported(true);\n        Wrapper b = Tomcat.addServlet(ctx, \"ServletB\", new Bug53337ServletB());\n        b.setAsyncSupported(true);\n        Tomcat.addServlet(ctx, \"ServletC\", new Bug53337ServletC());\n        ctx.addServletMapping(\"/ServletA\", \"ServletA\");\n        ctx.addServletMapping(\"/ServletB\", \"ServletB\");\n        ctx.addServletMapping(\"/ServletC\", \"ServletC\");\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/ServletA\");\n\n        ByteChunk body = new ByteChunk();\n        int rc = getUrl(url.toString(), body, null);\n\n        assertEquals(HttpServletResponse.SC_OK, rc);\n        assertEquals(\"OK\", body.toString());\n    }",
                "    public void testBug53843() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n        Bug53843ServletA servletA = new Bug53843ServletA();\n        Wrapper a = Tomcat.addServlet(ctx, \"ServletA\", servletA);\n        a.setAsyncSupported(true);\n        Tomcat.addServlet(ctx, \"ServletB\", new Bug53843ServletB());\n\n        ctx.addServletMapping(\"/ServletA\", \"ServletA\");\n        ctx.addServletMapping(\"/ServletB\", \"ServletB\");\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/ServletA\");\n\n        ByteChunk body = new ByteChunk();\n        int rc = getUrl(url.toString(), body, null);\n\n        assertEquals(HttpServletResponse.SC_OK, rc);\n        assertEquals(\"OK\", body.toString());\n        assertTrue(servletA.isAsyncWhenExpected());\n    }\n\n    public void testTimeoutErrorDispatchNone() throws Exception {\n        doTestTimeoutErrorDispatch(null, null);\n    }\n\n    public void testTimeoutErrorDispatchNonAsync() throws Exception {\n        doTestTimeoutErrorDispatch(Boolean.FALSE, null);\n    }",
                "    public void testBug54178() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        Bug54178ServletA bug54178ServletA = new Bug54178ServletA();\n        Wrapper wrapper =\n            Tomcat.addServlet(ctx, \"bug54178ServletA\", bug54178ServletA);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/bug54178ServletA\", \"bug54178ServletA\");\n\n        Bug54178ServletB bug54178ServletB = new Bug54178ServletB();\n        Tomcat.addServlet(ctx, \"bug54178ServletB\", bug54178ServletB);\n        ctx.addServletMapping(\"/bug54178ServletB\", \"bug54178ServletB\");\n\n        tomcat.start();\n\n        ByteChunk body = new ByteChunk();\n        int rc = -1;\n\n        try {\n            rc = getUrl(\"http://localhost:\" + getPort() + \"/bug54178ServletA?\" +\n                    Bug54178ServletA.PARAM_NAME + \"=bar\",\n                    body, null);\n        } catch (IOException ioe) {\n            // This may happen if test fails. Output the exception in case it is\n            // useful and let asserts handle the failure\n            ioe.printStackTrace();\n        }\n\n        assertEquals(HttpServletResponse.SC_OK, rc);\n\n        body.recycle();\n\n        rc = getUrl(\"http://localhost:\" + getPort() + \"/bug54178ServletB\",\n                body, null);\n\n        assertEquals(HttpServletResponse.SC_OK, rc);\n        assertEquals(\"OK\", body.toString());\n    }",
                "    public void testForbiddenDispatching() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        NonAsyncServlet nonAsyncServlet = new NonAsyncServlet();\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"nonAsyncServlet\",\n                nonAsyncServlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/target\", \"nonAsyncServlet\");\n\n        DispatchingGenericServlet forbiddenDispatchingServlet = new DispatchingGenericServlet();\n        Wrapper wrapper1 = Tomcat.addServlet(ctx,\n                \"forbiddenDispatchingServlet\", forbiddenDispatchingServlet);\n        wrapper1.setAsyncSupported(true);\n        ctx.addServletMapping(\"/forbiddenDispatchingServlet\",\n                \"forbiddenDispatchingServlet\");\n\n        tomcat.start();\n\n        ByteChunk body = new ByteChunk();\n\n        try {\n            getUrl(\"http://localhost:\" + getPort()\n                    + \"/forbiddenDispatchingServlet\", body, null);\n        } catch (IOException ioe) {\n            // This may happen if test fails. Output the exception in case it is\n            // useful and let asserts handle the failure\n            ioe.printStackTrace();\n        }\n\n        assertTrue(body.toString().contains(\"OK\"));\n        assertTrue(body.toString().contains(\"NonAsyncServletGet\"));\n    }",
                "    public void testDispatchWithCustomRequestResponse() throws Exception {\n        prepareApplicationWithGenericServlet(\"\");\n\n        StringBuilder expected = new StringBuilder();\n        expected.append(\"OK\");\n        expected.append(\"CustomGenericServletGet-\");\n        requestApplicationWithGenericServlet(\"/dispatch?crr=y\", expected);\n\n        expected = new StringBuilder();\n        expected.append(\"OK\");\n        expected.append(\"DispatchingGenericServletGet-\");\n        requestApplicationWithGenericServlet(\"/dispatch?crr=y&empty=y\",\n                expected);\n    }\n\n    public void testEmptyDispatch() throws Exception {\n        prepareApplicationWithGenericServlet(\"/fo o\");\n        StringBuilder expected = new StringBuilder();\n        expected.append(\"OK\");\n        expected.append(\"DispatchingGenericServletGet-\");\n        requestApplicationWithGenericServlet(\"/fo%20o/dispatch?empty=y\",\n                expected);\n        requestApplicationWithGenericServlet(\"//fo%20o/dispatch?empty=y\",\n                expected);\n        requestApplicationWithGenericServlet(\"/./fo%20o/dispatch?empty=y\",\n                expected);\n        requestApplicationWithGenericServlet(\"/fo%20o//dispatch?empty=y\",\n                expected);\n        requestApplicationWithGenericServlet(\"/fo%20o/./dispatch?empty=y\",\n                expected);\n        requestApplicationWithGenericServlet(\"/fo%20o/c/../dispatch?empty=y\",\n                expected);\n    }",
                "    public void testEmptyDispatchWithCustomRequestResponse() throws Exception {\n        prepareApplicationWithGenericServlet(\"/fo o\");\n        StringBuilder expected = new StringBuilder();\n        expected.append(\"OK\");\n        expected.append(\"DispatchingGenericServletGet-\");\n        requestApplicationWithGenericServlet(\"/fo%20o/dispatch?crr=y&empty=y\",\n                expected);\n        requestApplicationWithGenericServlet(\"//fo%20o/dispatch?crr=y&empty=y\",\n                expected);\n        requestApplicationWithGenericServlet(\n                \"/./fo%20o/dispatch?crr=y&empty=y\", expected);\n        requestApplicationWithGenericServlet(\"/fo%20o//dispatch?crr=y&empty=y\",\n                expected);\n        requestApplicationWithGenericServlet(\n                \"/fo%20o/./dispatch?crr=y&empty=y\", expected);\n        requestApplicationWithGenericServlet(\n                \"/fo%20o/c/../dispatch?crr=y&empty=y\", expected);\n    }"
            ],
            "java\\org\\apache\\catalina\\tribes\\transport\\nio\\ParallelNioSender.java": [
                "    public synchronized void sendMessage(Member[] destination, ChannelMessage msg) throws ChannelException {\n        long start = System.currentTimeMillis();\n        this.setUdpBased((msg.getOptions()&Channel.SEND_OPTIONS_UDP) == Channel.SEND_OPTIONS_UDP);\n        byte[] data = XByteBuffer.createDataPackage((ChannelData)msg);\n        NioSender[] senders = setupForSend(destination);\n        connect(senders);\n        setData(senders,data);\n\n        int remaining = senders.length;\n        ChannelException cx = null;\n        try {\n            //loop until complete, an error happens, or we timeout\n            long delta = System.currentTimeMillis() - start;\n            boolean waitForAck = (Channel.SEND_OPTIONS_USE_ACK & msg.getOptions()) == Channel.SEND_OPTIONS_USE_ACK;\n            while ( (remaining>0) && (delta<getTimeout()) ) {\n                try {\n                    remaining -= doLoop(selectTimeout, getMaxRetryAttempts(),waitForAck,msg);\n                } catch (Exception x ) {\n                    if (log.isTraceEnabled()) log.trace(\"Error sending message\", x);\n                    int faulty = (cx == null)?0:cx.getFaultyMembers().length;\n                    if ( cx == null ) {\n                        if ( x instanceof ChannelException ) cx = (ChannelException)x;\n                        else cx = new ChannelException(\"Parallel NIO send failed.\", x);\n                    } else {\n                        if (x instanceof ChannelException) cx.addFaultyMember( ( (ChannelException) x).getFaultyMembers());\n                    }\n                    //count down the remaining on an error\n                    if (faulty<cx.getFaultyMembers().length) remaining -= (cx.getFaultyMembers().length-faulty);\n                }\n                //bail out if all remaining senders are failing\n                if ( cx != null && cx.getFaultyMembers().length == remaining ) throw cx;\n                delta = System.currentTimeMillis() - start;\n            }\n            if ( remaining > 0 ) {\n                //timeout has occurred\n                ChannelException cxtimeout = new ChannelException(\"Operation has timed out(\"+getTimeout()+\" ms.).\");\n                if ( cx==null ) cx = new ChannelException(\"Operation has timed out(\"+getTimeout()+\" ms.).\");\n                for (int i=0; i<senders.length; i++ ) {\n                    if (!senders[i].isComplete() ) cx.addFaultyMember(senders[i].getDestination(),cxtimeout);\n                }\n                throw cx;\n            } else if ( cx != null ) {\n                //there was an error\n                throw cx;\n            }\n        } catch (Exception x ) {\n            try { this.disconnect(); } catch (Exception e) {/*Ignore*/}\n            if ( x instanceof ChannelException ) throw (ChannelException)x;\n            else throw new ChannelException(x);\n        }\n\n    }",
                "    private int doLoop(long selectTimeOut, int maxAttempts, boolean waitForAck, ChannelMessage msg) throws IOException, ChannelException {\n        int completed = 0;\n        int selectedKeys = selector.select(selectTimeOut);\n\n        if (selectedKeys == 0) {\n            return 0;\n        }\n\n        Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n        while (it.hasNext()) {\n            SelectionKey sk = it.next();\n            it.remove();\n            int readyOps = sk.readyOps();\n            sk.interestOps(sk.interestOps() & ~readyOps);\n            NioSender sender = (NioSender) sk.attachment();\n            try {\n                if (sender.process(sk,waitForAck)) {\n                    completed++;\n                    sender.setComplete(true);\n                    if ( Logs.MESSAGES.isTraceEnabled() ) {\n                        Logs.MESSAGES.trace(\"ParallelNioSender - Sent msg:\" + new UniqueId(msg.getUniqueId()) + \" at \" +new java.sql.Timestamp(System.currentTimeMillis())+ \" to \"+sender.getDestination().getName());\n                    }\n                    SenderState.getSenderState(sender.getDestination()).setReady();\n                }//end if\n            } catch (Exception x) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Error while processing send to \" + sender.getDestination().getName(), x);\n                }\n                SenderState state = SenderState.getSenderState(sender.getDestination());\n                int attempt = sender.getAttempt()+1;\n                boolean retry = (sender.getAttempt() <= maxAttempts && maxAttempts>0);\n                synchronized (state) {\n\n                    //sk.cancel();\n                    if (state.isSuspect()) state.setFailing();\n                    if (state.isReady()) {\n                        state.setSuspect();\n                        if ( retry )\n                            log.warn(\"Member send is failing for:\" + sender.getDestination().getName() +\" ; Setting to suspect and retrying.\");\n                        else\n                            log.warn(\"Member send is failing for:\" + sender.getDestination().getName() +\" ; Setting to suspect.\", x);\n                    }\n                }\n                if ( !isConnected() ) {\n                    log.warn(\"Not retrying send for:\" + sender.getDestination().getName() + \"; Sender is disconnected.\");\n                    ChannelException cx = new ChannelException(\"Send failed, and sender is disconnected. Not retrying.\",x);\n                    cx.addFaultyMember(sender.getDestination(),x);\n                    throw cx;\n                }\n\n                byte[] data = sender.getMessage();\n                if ( retry ) {\n                    try {\n                        sender.disconnect();\n                        sender.connect();\n                        sender.setAttempt(attempt);\n                        sender.setMessage(data);\n                    }catch ( Exception ignore){\n                        state.setFailing();\n                    }\n                } else {\n                    ChannelException cx = new ChannelException(\"Send failed, attempt:\"+sender.getAttempt()+\" max:\"+maxAttempts,x);\n                    cx.addFaultyMember(sender.getDestination(),x);\n                    throw cx;\n                }//end if\n            }\n        }\n        return completed;\n\n    }",
                "    private void connect(NioSender[] senders) throws ChannelException {\n        ChannelException x = null;\n        for (int i=0; i<senders.length; i++ ) {\n            try {\n                senders[i].connect();\n            }catch ( IOException io ) {\n                if ( x==null ) x = new ChannelException(io);\n                x.addFaultyMember(senders[i].getDestination(),io);\n            }\n        }\n        if ( x != null ) throw x;\n    }\n\n    private synchronized void close() throws ChannelException  {\n        ChannelException x = null;\n        Object[] members = nioSenders.keySet().toArray();\n        for (int i=0; i<members.length; i++ ) {\n            Member mbr = (Member)members[i];\n            try {\n                NioSender sender = nioSenders.get(mbr);\n                sender.disconnect();\n            }catch ( Exception e ) {\n                if ( x == null ) x = new ChannelException(e);\n                x.addFaultyMember(mbr,e);\n            }\n            nioSenders.remove(mbr);\n        }\n        if ( x != null ) throw x;\n    }\n\n    public void remove(Member member) {\n        //disconnect senders\n        NioSender sender = nioSenders.remove(member);\n        if ( sender != null ) sender.disconnect();\n    }",
                "    public synchronized void disconnect() {\n        setConnected(false);\n        try {close(); }catch (Exception x){/*Ignore*/}\n    }\n\n    public void finalize() {\n        try {disconnect(); }catch ( Exception e){/*Ignore*/}\n        try {\n            selector.close();\n        }catch (Exception e) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Failed to close selector\", e);\n            }\n        }\n    }",
                "    public boolean keepalive() {\n        boolean result = false;\n        for ( Iterator<Entry<Member, NioSender>> i = nioSenders.entrySet().iterator(); i.hasNext();) {\n            Map.Entry<Member, NioSender> entry = i.next();\n            NioSender sender = entry.getValue();\n            if ( sender.keepalive() ) {\n                //nioSenders.remove(entry.getKey());\n                i.remove();\n                result = true;\n            } else {\n                try {\n                    sender.read(null);\n                }catch ( IOException x ) {\n                    sender.disconnect();\n                    sender.reset();\n                    //nioSenders.remove(entry.getKey());\n                    i.remove();\n                    result = true;\n                }catch ( Exception x ) {\n                    log.warn(\"Error during keepalive test for sender:\"+sender,x);\n                }\n            }\n        }\n        //clean up any cancelled keys\n        if ( result ) try { selector.selectNow(); }catch (Exception e){/*Ignore*/}\n        return result;\n    }"
            ],
            "java\\org\\apache\\coyote\\http11\\upgrade\\UpgradeNioProcessor.java": [
                "    public void flush() throws IOException {\n        NioEndpoint.KeyAttachment att =\n                (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);\n        if (att == null) {\n            throw new IOException(\"Key must be cancelled\");\n        }\n        long writeTimeout = att.getTimeout();\n        Selector selector = null;\n        try {\n            selector = pool.get();\n        } catch ( IOException x ) {\n            //ignore\n        }\n        try {\n            do {\n                if (nioChannel.flush(true, selector, writeTimeout)) {\n                    break;\n                }\n            } while (true);\n        } finally {\n            if (selector != null) {\n                pool.put(selector);\n            }\n        }\n    }\n\n    public void write(int b) throws IOException {\n        writeToSocket(new byte[] {(byte) b}, 0, 1);\n    }\n\n    public void write(byte[]b, int off, int len) throws IOException {\n        int written = 0;\n        while (len - written > maxWrite) {\n            written += writeToSocket(b, off + written, maxWrite);\n        }\n        writeToSocket(b, off + written, len - written);\n    }",
                "    public int read() throws IOException {\n        byte[] bytes = new byte[1];\n        int result = readSocket(true, bytes, 0, 1);\n        if (result == -1) {\n            return -1;\n        } else {\n            return bytes[0] & 0xFF;\n        }\n    }\n\n    private int fillReadBuffer(boolean block) throws IOException {\n        int nRead;\n        if (block) {\n            Selector selector = null;\n            try {\n                selector = pool.get();\n            } catch ( IOException x ) {\n                // Ignore\n            }\n            try {\n                NioEndpoint.KeyAttachment att =\n                        (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);\n                if (att == null) {\n                    throw new IOException(\"Key must be cancelled.\");\n                }\n                nRead = pool.read(nioChannel.getBufHandler().getReadBuffer(),\n                        nioChannel, selector, att.getTimeout());\n            } catch (EOFException eof) {\n                nRead = -1;\n            } finally {\n                if (selector != null) {\n                    pool.put(selector);\n                }\n            }\n        } else {\n            nRead = nioChannel.read(nioChannel.getBufHandler().getReadBuffer());\n        }\n        return nRead;\n    }"
            ],
            "test\\org\\apache\\coyote\\http11\\TestInternalInputBuffer.java": [
                "    public void testBug48839() {\n\n        Bug48839Client client = new Bug48839Client();\n\n        client.doRequest();\n        assertTrue(client.isResponse200());\n        assertTrue(client.isResponseBodyOK());\n    }\n\n    public void testBug51557NoColon() {\n\n        Bug51557Client client = new Bug51557Client(\"X-Bug51557NoColon\");\n\n        client.doRequest();\n        assertTrue(client.isResponse200());\n        assertEquals(\"abcd\", client.getResponseBody());\n        assertTrue(client.isResponseBodyOK());\n    }\n\n    public void testBug51557Separators() throws Exception {\n        char httpSeparators[] = new char[] {\n                '\\t', ' ', '\\\"', '(', ')', ',', '/', ':', ';', '<',\n                '=', '>', '?', '@', '[', '\\\\', ']', '{', '}' };\n\n        for (char s : httpSeparators) {\n            doTestBug51557Char(s);\n            tearDown();\n            setUp();\n        }\n    }",
                "    public void testBug51557Ctl() throws Exception {\n        for (int i = 0; i < 31; i++) {\n            doTestBug51557Char((char) i);\n            tearDown();\n            setUp();\n        }\n        doTestBug51557Char((char) 127);\n    }\n\n    public void testBug51557Continuation() {\n\n        Bug51557Client client = new Bug51557Client(\"X-Bug=51557NoColon\",\n                \"foo\" + SimpleHttpClient.CRLF + \" bar\");\n\n        client.doRequest();\n        assertTrue(client.isResponse200());\n        assertEquals(\"abcd\", client.getResponseBody());\n        assertTrue(client.isResponseBodyOK());\n    }\n\n    public void testBug51557BoundaryStart() {\n\n        Bug51557Client client = new Bug51557Client(\"=X-Bug51557\",\n                \"invalid\");\n\n        client.doRequest();\n        assertTrue(client.isResponse200());\n        assertEquals(\"abcd\", client.getResponseBody());\n        assertTrue(client.isResponseBodyOK());\n    }",
                "    public void testBug51557BoundaryEnd() {\n\n        Bug51557Client client = new Bug51557Client(\"X-Bug51557=\",\n                \"invalid\");\n\n        client.doRequest();\n        assertTrue(client.isResponse200());\n        assertEquals(\"abcd\", client.getResponseBody());\n        assertTrue(client.isResponseBodyOK());\n    }\n\n    private void doTestBug51557Char(char s) {\n        Bug51557Client client =\n            new Bug51557Client(\"X-Bug\" + s + \"51557\", \"invalid\");\n\n        client.doRequest();\n        assertTrue(client.isResponse200());\n        assertEquals(\"abcd\", client.getResponseBody());\n        assertTrue(client.isResponseBodyOK());\n    }\n\n    public void testNewLines() {\n\n        NewLinesClient client = new NewLinesClient(10);\n\n        client.doRequest();\n        assertTrue(client.isResponse200());\n        assertTrue(client.isResponseBodyOK());\n    }",
                "    public void testNewLinesExcessive() {\n\n        NewLinesClient client = new NewLinesClient(10000);\n\n        // If the connection is closed fast enough, writing the request will\n        // fail and the response won't be read.\n        Exception e = client.doRequest();\n        if (e == null) {\n            assertTrue(client.isResponse400());\n        }\n        assertFalse(client.isResponseBodyOK());\n    }\n\n    public void testBug54947() {\n\n        Bug54947Client client = new Bug54947Client();\n\n        client.doRequest();\n        assertTrue(client.isResponse200());\n        assertTrue(client.isResponseBodyOK());\n    }"
            ],
            "java\\org\\apache\\coyote\\http11\\InternalNioOutputBuffer.java": [
                "    public void flush() throws IOException {\n\n        super.flush();\n        // Flush the current buffer\n        flushBuffer();\n\n    }\n\n    public void recycle() {\n        super.recycle();\n        if (socket != null) {\n            socket.getBufHandler().getWriteBuffer().clear();\n            socket = null;\n        }\n    }\n\n    public void endRequest() throws IOException {\n        super.endRequest();\n        flushBuffer();\n    }",
                "    public void sendAck() throws IOException {\n\n        if (!committed) {\n            //Socket.send(socket, Constants.ACK_BYTES, 0, Constants.ACK_BYTES.length) < 0\n            socket.getBufHandler() .getWriteBuffer().put(Constants.ACK_BYTES,0,Constants.ACK_BYTES.length);    \n            writeToSocket(socket.getBufHandler() .getWriteBuffer(),true,true);\n        }\n\n    }\n\n    private synchronized int writeToSocket(ByteBuffer bytebuffer, boolean block, boolean flip) throws IOException {\n        if ( flip ) bytebuffer.flip();\n\n        int written = 0;\n        NioEndpoint.KeyAttachment att = (NioEndpoint.KeyAttachment)socket.getAttachment(false);\n        if ( att == null ) throw new IOException(\"Key must be cancelled\");\n        long writeTimeout = att.getWriteTimeout();\n        Selector selector = null;\n        try {\n            selector = pool.get();\n        } catch ( IOException x ) {\n            //ignore\n        }\n        try {\n            written = pool.write(bytebuffer, socket, selector, writeTimeout, block);\n            //make sure we are flushed \n            do {\n                if (socket.flush(true,selector,writeTimeout)) break;\n            }while ( true );\n        }finally { \n            if ( selector != null ) pool.put(selector);\n        }\n        if ( block ) bytebuffer.clear(); //only clear\n        return written;\n    } ",
                "    private synchronized void addToBB(byte[] buf, int offset, int length) throws IOException {\n        while (length > 0) {\n            int thisTime = length;\n            if (socket.getBufHandler().getWriteBuffer().position() ==\n                    socket.getBufHandler().getWriteBuffer().capacity()\n                    || socket.getBufHandler().getWriteBuffer().remaining()==0) {\n                flushBuffer();\n            }\n            if (thisTime > socket.getBufHandler().getWriteBuffer().remaining()) {\n                thisTime = socket.getBufHandler().getWriteBuffer().remaining();\n            }\n            socket.getBufHandler().getWriteBuffer().put(buf, offset, thisTime);\n            length = length - thisTime;\n            offset = offset + thisTime;\n        }\n        NioEndpoint.KeyAttachment ka = (NioEndpoint.KeyAttachment)socket.getAttachment(false);\n        if ( ka!= null ) ka.access();//prevent timeouts for just doing client writes\n    }\n\n    private void flushBuffer() throws IOException {\n\n        //prevent timeout for async,\n        SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());\n        if (key != null) {\n            NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) key.attachment();\n            attach.access();\n        }\n\n        //write to the socket, if there is anything to write\n        if (socket.getBufHandler().getWriteBuffer().position() > 0) {\n            socket.getBufHandler().getWriteBuffer().flip();\n            writeToSocket(socket.getBufHandler().getWriteBuffer(),true, false);\n        }\n    }"
            ],
            "java\\org\\apache\\tomcat\\util\\net\\SocketWrapper.java": [
                "    public void reset(E socket, long timeout) {\n        async = false;\n        blockingStatus = true;\n        comet = false;\n        error = false;\n        keepAliveLeft = 100;\n        lastAccess = System.currentTimeMillis();\n        this.socket = socket;\n        this.timeout = timeout;\n        upgraded = false;\n    }"
            ],
            "java\\org\\apache\\tomcat\\util\\net\\NioEndpoint.java": [
                "    protected void checkParachute() {\n        boolean para = reclaimParachute(false);\n        if (!para && (System.currentTimeMillis()-lastParachuteCheck)>10000) {\n            try {\n                log.fatal(oomParachuteMsg);\n            }catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                System.err.println(oomParachuteMsg);\n            }\n            lastParachuteCheck = System.currentTimeMillis();\n        }\n    }\n\n    protected boolean reclaimParachute(boolean force) {\n        if ( oomParachuteData != null ) return true;\n        if ( oomParachute > 0 && ( force || (Runtime.getRuntime().freeMemory() > (oomParachute*2))) )\n            oomParachuteData = new byte[oomParachute];\n        return oomParachuteData != null;\n    }\n\n    protected void releaseCaches() {\n        this.keyCache.clear();\n        this.nioChannels.clear();\n        this.processorCache.clear();\n        if ( handler != null ) handler.recycle();\n\n    }",
                "    public void bind() throws Exception {\n\n        serverSock = ServerSocketChannel.open();\n        socketProperties.setProperties(serverSock.socket());\n        InetSocketAddress addr = (getAddress()!=null?new InetSocketAddress(getAddress(),getPort()):new InetSocketAddress(getPort()));\n        serverSock.socket().bind(addr,getBacklog());\n        serverSock.configureBlocking(true); //mimic APR behavior\n        serverSock.socket().setSoTimeout(getSocketProperties().getSoTimeout());\n\n        // Initialize thread count defaults for acceptor, poller\n        if (acceptorThreadCount == 0) {\n            // FIXME: Doesn't seem to work that well with multiple accept threads\n            acceptorThreadCount = 1;\n        }\n        if (pollerThreadCount <= 0) {\n            //minimum one poller thread\n            pollerThreadCount = 1;\n        }\n        stopLatch = new CountDownLatch(pollerThreadCount);\n\n        // Initialize SSL if needed\n        if (isSSLEnabled()) {\n            SSLUtil sslUtil = handler.getSslImplementation().getSSLUtil(this);\n\n            sslContext = sslUtil.createSSLContext();\n            sslContext.init(wrap(sslUtil.getKeyManagers()),\n                    sslUtil.getTrustManagers(), null);\n\n            SSLSessionContext sessionContext =\n                sslContext.getServerSessionContext();\n            if (sessionContext != null) {\n                sslUtil.configureSessionContext(sessionContext);\n            }\n            // Determine which cipher suites and protocols to enable\n            enabledCiphers = sslUtil.getEnableableCiphers(sslContext);\n            enabledProtocols = sslUtil.getEnableableProtocols(sslContext);\n        }\n\n        if (oomParachute>0) reclaimParachute(true);\n        selectorPool.open();\n    }",
                "    public KeyManager[] wrap(KeyManager[] managers) {\n        if (managers==null) return null;\n        KeyManager[] result = new KeyManager[managers.length];\n        for (int i=0; i<result.length; i++) {\n            if (managers[i] instanceof X509KeyManager && getKeyAlias()!=null) {\n                result[i] = new NioX509KeyManager((X509KeyManager)managers[i],getKeyAlias());\n            } else {\n                result[i] = managers[i];\n            }\n        }\n        return result;\n    }\n\n    public void startInternal() throws Exception {\n\n        if (!running) {\n            running = true;\n            paused = false;\n\n            // Create worker collection\n            if ( getExecutor() == null ) {\n                createExecutor();\n            }\n\n            initializeConnectionLatch();\n\n            // Start poller threads\n            pollers = new Poller[getPollerThreadCount()];\n            for (int i=0; i<pollers.length; i++) {\n                pollers[i] = new Poller();\n                Thread pollerThread = new Thread(pollers[i], getName() + \"-ClientPoller-\"+i);\n                pollerThread.setPriority(threadPriority);\n                pollerThread.setDaemon(true);\n                pollerThread.start();\n            }\n\n            startAcceptorThreads();\n        }\n    }",
                "    public void stopInternal() {\n        releaseConnectionLatch();\n        if (!paused) {\n            pause();\n        }\n        if (running) {\n            running = false;\n            unlockAccept();\n            for (int i=0; pollers!=null && i<pollers.length; i++) {\n                if (pollers[i]==null) continue;\n                pollers[i].destroy();\n                pollers[i] = null;\n            }\n            try {\n                stopLatch.await(selectorTimeout + 100, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException ignore) {\n            }\n        }\n        eventCache.clear();\n        keyCache.clear();\n        nioChannels.clear();\n        processorCache.clear();\n        shutdownExecutor();\n\n    }",
                "    public void unbind() throws Exception {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Destroy initiated for \"+new InetSocketAddress(getAddress(),getPort()));\n        }\n        if (running) {\n            stop();\n        }\n        // Close server socket\n        serverSock.socket().close();\n        serverSock.close();\n        serverSock = null;\n        sslContext = null;\n        releaseCaches();\n        selectorPool.close();\n        if (log.isDebugEnabled()) {\n            log.debug(\"Destroy completed for \"+new InetSocketAddress(getAddress(),getPort()));\n        }\n    }\n\n    protected SSLEngine createSSLEngine() {\n        SSLEngine engine = sslContext.createSSLEngine();\n        if (\"false\".equals(getClientAuth())) {\n            engine.setNeedClientAuth(false);\n            engine.setWantClientAuth(false);\n        } else if (\"true\".equals(getClientAuth()) || \"yes\".equals(getClientAuth())){\n            engine.setNeedClientAuth(true);\n        } else if (\"want\".equals(getClientAuth())) {\n            engine.setWantClientAuth(true);\n        }\n        engine.setUseClientMode(false);\n        engine.setEnabledCipherSuites(enabledCiphers);\n        engine.setEnabledProtocols(enabledProtocols);\n\n        return engine;\n    }",
                "    public boolean processSocket(NioChannel socket, SocketStatus status, boolean dispatch) {\n        try {\n            KeyAttachment attachment = (KeyAttachment)socket.getAttachment(false);\n            if (attachment == null) {\n                return false;\n            }\n            attachment.setCometNotify(false); //will get reset upon next reg\n            SocketProcessor sc = processorCache.poll();\n            if ( sc == null ) sc = new SocketProcessor(socket,status);\n            else sc.reset(socket,status);\n            if ( dispatch && getExecutor()!=null ) getExecutor().execute(sc);\n            else sc.run();\n        } catch (RejectedExecutionException rx) {\n            log.warn(\"Socket processing request was rejected for:\"+socket,rx);\n            return false;\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            // This means we got an OOM or similar creating a thread, or that\n            // the pool and its queue are full\n            log.error(sm.getString(\"endpoint.process.fail\"), t);\n            return false;\n        }\n        return true;\n    }\n\n    private void closeSocket(SocketChannel socket) {\n        try {\n            socket.socket().close();\n        } catch (IOException ioe)  {\n            if (log.isDebugEnabled()) {\n                log.debug(\"\", ioe);\n            }\n        }\n        try {\n            socket.close();\n        } catch (IOException ioe) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"\", ioe);\n            }\n        }\n    }"
            ]
        }
    },
    "55995": {
        "summary": "Bug 55995 java.lang.NullPointerException at org.apache.jasper.servlet.JspCServletContext.getResource(JspCServletContext.java:344)",
        "code_segments": {
            "java\\org\\apache\\jasper\\JspCompilationContext.java": [
                "    public Compiler createCompiler() {\n        if (jspCompiler != null ) {\n            return jspCompiler;\n        }\n        jspCompiler = null;\n        if (options.getCompilerClassName() != null) {\n            jspCompiler = createCompiler(options.getCompilerClassName());\n        } else {\n            if (options.getCompiler() == null) {\n                jspCompiler = createCompiler(\"org.apache.jasper.compiler.JDTCompiler\");\n                if (jspCompiler == null) {\n                    jspCompiler = createCompiler(\"org.apache.jasper.compiler.AntCompiler\");\n                }\n            } else {\n                jspCompiler = createCompiler(\"org.apache.jasper.compiler.AntCompiler\");\n                if (jspCompiler == null) {\n                    jspCompiler = createCompiler(\"org.apache.jasper.compiler.JDTCompiler\");\n                }\n            }\n        }\n        if (jspCompiler == null) {\n            throw new IllegalStateException(Localizer.getMessage(\"jsp.error.compiler\"));\n        }\n        jspCompiler.init(this, jsw);\n        return jspCompiler;\n    }",
                "    protected Compiler createCompiler(String className) {\n        Compiler compiler = null;\n        try {\n            compiler = (Compiler) Class.forName(className).newInstance();\n        } catch (InstantiationException e) {\n            log.warn(Localizer.getMessage(\"jsp.error.compiler\"), e);\n        } catch (IllegalAccessException e) {\n            log.warn(Localizer.getMessage(\"jsp.error.compiler\"), e);\n        } catch (NoClassDefFoundError e) {\n            if (log.isDebugEnabled()) {\n                log.debug(Localizer.getMessage(\"jsp.error.compiler\"), e);\n            }\n        } catch (ClassNotFoundException e) {\n            if (log.isDebugEnabled()) {\n                log.debug(Localizer.getMessage(\"jsp.error.compiler\"), e);\n            }\n        }\n        return compiler;\n    }\n\n    public String resolveRelativeUri(String uri) {\n        // sometimes we get uri's massaged from File(String), so check for\n        // a root directory separator char\n        if (uri.startsWith(\"/\") || uri.startsWith(File.separator)) {\n            return uri;\n        } else {\n            return baseURI + uri;\n        }\n    }\n\n    public void incrementRemoved() {\n        if (removed == 0 && rctxt != null) {\n            rctxt.removeWrapper(jspUri);\n        }\n        removed++;\n    }",
                "    public void compile() throws JasperException, FileNotFoundException {\n        createCompiler();\n        if (jspCompiler.isOutDated()) {\n            if (isRemoved()) {\n                throw new FileNotFoundException(jspUri);\n            }\n            try {\n                jspCompiler.removeGeneratedFiles();\n                jspLoader = null;\n                jspCompiler.compile();\n                jsw.setReload(true);\n                jsw.setCompilationException(null);\n            } catch (JasperException ex) {\n                // Cache compilation exception\n                jsw.setCompilationException(ex);\n                if (options.getDevelopment() && options.getRecompileOnFail()) {\n                    // Force a recompilation attempt on next access\n                    jsw.setLastModificationTest(-1);\n                }\n                throw ex;\n            } catch (FileNotFoundException fnfe) {\n                // Re-throw to let caller handle this - will result in a 404\n                throw fnfe;\n            } catch (Exception ex) {\n                JasperException je = new JasperException(\n                            Localizer.getMessage(\"jsp.error.unable.compile\"),\n                            ex);\n                // Cache compilation exception\n                jsw.setCompilationException(je);\n                throw je;\n            }\n        }\n    }",
                "    public Class<?> load() throws JasperException {\n        try {\n            getJspLoader();\n\n            String name = getFQCN();\n            servletClass = jspLoader.loadClass(name);\n        } catch (ClassNotFoundException cex) {\n            throw new JasperException(Localizer.getMessage(\"jsp.error.unable.load\"),\n                                      cex);\n        } catch (Exception ex) {\n            throw new JasperException(Localizer.getMessage(\"jsp.error.unable.compile\"),\n                                      ex);\n        }\n        removed = 0;\n        return servletClass;\n    }\n\n    public void checkOutputDir() {\n        if (outputDir != null) {\n            if (!(new File(outputDir)).exists()) {\n                makeOutputDir();\n            }\n        } else {\n            createOutputDir();\n        }\n    }\n\n    protected boolean makeOutputDir() {\n        synchronized(outputDirLock) {\n            File outDirFile = new File(outputDir);\n            return (outDirFile.mkdirs() || outDirFile.isDirectory());\n        }\n    }",
                "    protected void createOutputDir() {\n        String path = null;\n        if (isTagFile()) {\n            String tagName = tagInfo.getTagClassName();\n            path = tagName.replace('.', File.separatorChar);\n            path = path.substring(0, path.lastIndexOf(File.separatorChar));\n        } else {\n            path = getServletPackageName().replace('.',File.separatorChar);\n        }\n\n            // Append servlet or tag handler path to scratch dir\n            try {\n                File base = options.getScratchDir();\n                baseUrl = base.toURI().toURL();\n                outputDir = base.getAbsolutePath() + File.separator + path +\n                    File.separator;\n                if (!makeOutputDir()) {\n                    throw new IllegalStateException(Localizer.getMessage(\"jsp.error.outputfolder\"));\n                }\n            } catch (MalformedURLException e) {\n                throw new IllegalStateException(Localizer.getMessage(\"jsp.error.outputfolder\"), e);\n            }\n    }",
                "    protected static final String canonicalURI(String s) {\n       if (s == null) {\n        return null;\n    }\n       StringBuilder result = new StringBuilder();\n       final int len = s.length();\n       int pos = 0;\n       while (pos < len) {\n           char c = s.charAt(pos);\n           if ( isPathSeparator(c) ) {\n               /*\n                * multiple path separators.\n                * 'foo///bar' -> 'foo/bar'\n                */\n               while (pos+1 < len && isPathSeparator(s.charAt(pos+1))) {\n                   ++pos;\n               }\n\n               if (pos+1 < len && s.charAt(pos+1) == '.') {\n                   /*\n                    * a single dot at the end of the path - we are done.\n                    */\n                   if (pos+2 >= len) {\n                    break;\n                }\n\n                   switch (s.charAt(pos+2)) {\n                       /*\n                        * self directory in path\n                        * foo/./bar -> foo/bar\n                        */\n                   case '/':\n                   case '\\\\':\n                       pos += 2;\n                       continue;\n\n                       /*\n                        * two dots in a path: go back one hierarchy.\n                        * foo/bar/../baz -> foo/baz\n                        */\n                   case '.':\n                       // only if we have exactly _two_ dots.\n                       if (pos+3 < len && isPathSeparator(s.charAt(pos+3))) {\n                           pos += 3;\n                           int separatorPos = result.length()-1;\n                           while (separatorPos >= 0 &&\n                                  ! isPathSeparator(result\n                                                    .charAt(separatorPos))) {\n                               --separatorPos;\n                           }\n                           if (separatorPos >= 0) {\n                            result.setLength(separatorPos);\n                        }\n                           continue;\n                       }\n                   }\n               }\n           }\n           result.append(c);\n           ++pos;\n       }\n       return result.toString();\n    }"
            ],
            "java\\org\\apache\\jasper\\servlet\\JspServletWrapper.java": [
                "    public Class<?> loadTagFile() throws JasperException {\n\n        try {\n            if (ctxt.isRemoved()) {\n                throw new FileNotFoundException(jspUri);\n            }\n            if (options.getDevelopment() || firstTime ) {\n                synchronized (this) {\n                    firstTime = false;\n                    ctxt.compile();\n                }\n            } else {\n                if (compileException != null) {\n                    throw compileException;\n                }\n            }\n\n            if (reload) {\n                tagHandlerClass = ctxt.load();\n                reload = false;\n            }\n        } catch (FileNotFoundException ex) {\n            throw new JasperException(ex);\n        }\n\n        return tagHandlerClass;\n    }\n\n    public Class<?> loadTagFilePrototype() throws JasperException {\n\n        ctxt.setPrototypeMode(true);\n        try {\n            return loadTagFile();\n        } finally {\n            ctxt.setPrototypeMode(false);\n        }\n    }",
                "    public void destroy() {\n        if (theServlet != null) {\n            theServlet.destroy();\n            InstanceManager instanceManager = InstanceManagerFactory.getInstanceManager(config);\n            try {\n                instanceManager.destroyInstance(theServlet);\n            } catch (Exception e) {\n                Throwable t = ExceptionUtils.unwrapInvocationTargetException(e);\n                ExceptionUtils.handleThrowable(t);\n                // Log any exception, since it can't be passed along\n                log.error(Localizer.getMessage(\"jsp.error.file.not.found\",\n                        e.getMessage()), t);\n            }\n        }\n    }",
                "    protected JasperException handleJspException(Exception ex) {\n        try {\n            Throwable realException = ex;\n            if (ex instanceof ServletException) {\n                realException = ((ServletException) ex).getRootCause();\n            }\n\n            // First identify the stack frame in the trace that represents the JSP\n            StackTraceElement[] frames = realException.getStackTrace();\n            StackTraceElement jspFrame = null;\n\n            for (int i=0; i<frames.length; ++i) {\n                if ( frames[i].getClassName().equals(this.getServlet().getClass().getName()) ) {\n                    jspFrame = frames[i];\n                    break;\n                }\n            }\n\n            \n            if (jspFrame == null ||\n                    this.ctxt.getCompiler().getPageNodes() == null) {\n                // If we couldn't find a frame in the stack trace corresponding\n                // to the generated servlet class or we don't have a copy of the\n                // parsed JSP to hand, we can't really add anything\n                return new JasperException(ex);\n            }\n\n            int javaLineNumber = jspFrame.getLineNumber();\n            JavacErrorDetail detail = ErrorDispatcher.createJavacError(\n                    jspFrame.getMethodName(),\n                    this.ctxt.getCompiler().getPageNodes(),\n                    null,\n                    javaLineNumber,\n                    ctxt);\n\n            // If the line number is less than one we couldn't find out\n            // where in the JSP things went wrong\n            int jspLineNumber = detail.getJspBeginLineNumber();\n            if (jspLineNumber < 1) {\n                throw new JasperException(ex);\n            }\n\n            if (options.getDisplaySourceFragment()) {\n                return new JasperException(Localizer.getMessage\n                        (\"jsp.exception\", detail.getJspFileName(),\n                                \"\" + jspLineNumber) + Constants.NEWLINE +\n                                Constants.NEWLINE + detail.getJspExtract() +\n                                Constants.NEWLINE + Constants.NEWLINE + \n                                \"Stacktrace:\", ex);\n                \n            }\n\n            return new JasperException(Localizer.getMessage\n                    (\"jsp.exception\", detail.getJspFileName(),\n                            \"\" + jspLineNumber), ex);\n        } catch (Exception je) {\n            // If anything goes wrong, just revert to the original behaviour\n            if (ex instanceof JasperException) {\n                return (JasperException) ex;\n            }\n            return new JasperException(ex);\n        }\n    }"
            ],
            "java\\org\\apache\\jasper\\compiler\\JspRuntimeContext.java": [
                "    public FastRemovalDequeue<JspServletWrapper>.Entry push(JspServletWrapper jsw) {\n        if (log.isTraceEnabled()) {\n            log.trace(Localizer.getMessage(\"jsp.message.jsp_added\",\n                                           jsw.getJspUri(), context.getContextPath()));\n        }\n        FastRemovalDequeue<JspServletWrapper>.Entry entry = jspQueue.push(jsw);\n        JspServletWrapper replaced = entry.getReplaced();\n        if (replaced != null) {\n            if (log.isDebugEnabled()) {\n                log.debug(Localizer.getMessage(\"jsp.message.jsp_removed_excess\",\n                                               replaced.getJspUri(), context.getContextPath()));\n            }\n            unloadJspServletWrapper(replaced);\n            entry.clearReplaced();\n        }\n        return entry;\n    }\n\n    public void makeYoungest(FastRemovalDequeue<JspServletWrapper>.Entry unloadHandle) {\n        if (log.isTraceEnabled()) {\n            JspServletWrapper jsw = unloadHandle.getContent();\n            log.trace(Localizer.getMessage(\"jsp.message.jsp_queue_update\",\n                                           jsw.getJspUri(), context.getContextPath()));\n        }\n        jspQueue.moveFirst(unloadHandle);\n    }",
                "    public void checkCompile() {\n\n        if (lastCompileCheck < 0) {\n            // Checking was disabled\n            return;\n        }\n        long now = System.currentTimeMillis();\n        if (now > (lastCompileCheck + (options.getCheckInterval() * 1000L))) {\n            lastCompileCheck = now;\n        } else {\n            return;\n        }\n        \n        Object [] wrappers = jsps.values().toArray();\n        for (int i = 0; i < wrappers.length; i++ ) {\n            JspServletWrapper jsw = (JspServletWrapper)wrappers[i];\n            JspCompilationContext ctxt = jsw.getJspEngineContext();\n            // JspServletWrapper also synchronizes on this when\n            // it detects it has to do a reload\n            synchronized(jsw) {\n                try {\n                    ctxt.compile();\n                } catch (FileNotFoundException ex) {\n                    ctxt.incrementRemoved();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    jsw.getServletContext().log(\"Background compile failed\",\n                                                t);\n                }\n            }\n        }\n\n    }",
                "    private String initClassPath() {\n\n        StringBuilder cpath = new StringBuilder();\n        String sep = System.getProperty(\"path.separator\");\n\n        if (parentClassLoader instanceof URLClassLoader) {\n            URL [] urls = ((URLClassLoader)parentClassLoader).getURLs();\n    \n            for(int i = 0; i < urls.length; i++) {\n                // Tomcat 4 can use URL's other than file URL's,\n                // a protocol other than file: will generate a\n                // bad file system path, so only add file:\n                // protocol URL's to the classpath.\n                \n                if( urls[i].getProtocol().equals(\"file\") ) {\n                    cpath.append(urls[i].getFile()+sep);\n                }\n            }\n        }\n\n        cpath.append(options.getScratchDir() + sep);\n\n        String cp = (String) context.getAttribute(Constants.SERVLET_CLASSPATH);\n        if (cp == null || cp.equals(\"\")) {\n            cp = options.getClassPath();\n        }\n\n        String path = cpath.toString() + cp;\n\n        if(log.isDebugEnabled()) {\n            log.debug(\"Compilation classpath initialized: \" + path);\n        }\n        return path;\n    }",
                "    private SecurityHolder initSecurity() {\n\n        // Setup the PermissionCollection for this web app context\n        // based on the permissions configured for the root of the\n        // web app context directory, then add a file read permission\n        // for that directory.\n        Policy policy = Policy.getPolicy();\n        CodeSource source = null;\n        PermissionCollection permissions = null;\n        if( policy != null ) {\n            try {          \n                // Get the permissions for the web app context\n                String docBase = context.getRealPath(\"/\");\n                if( docBase == null ) {\n                    docBase = options.getScratchDir().toString();\n                }\n                String codeBase = docBase;\n                if (!codeBase.endsWith(File.separator)){\n                    codeBase = codeBase + File.separator;\n                }\n                File contextDir = new File(codeBase);\n                URL url = contextDir.getCanonicalFile().toURI().toURL();\n                source = new CodeSource(url,(Certificate[])null);\n                permissions = policy.getPermissions(source);\n\n                // Create a file read permission for web app context directory\n                if (!docBase.endsWith(File.separator)){\n                    permissions.add\n                        (new FilePermission(docBase,\"read\"));\n                    docBase = docBase + File.separator;\n                } else {\n                    permissions.add\n                        (new FilePermission\n                            (docBase.substring(0,docBase.length() - 1),\"read\"));\n                }\n                docBase = docBase + \"-\";\n                permissions.add(new FilePermission(docBase,\"read\"));\n\n                // Spec says apps should have read/write for their temp\n                // directory. This is fine, as no security sensitive files, at\n                // least any that the app doesn't have full control of anyway,\n                // will be written here.\n                String workDir = options.getScratchDir().toString();\n                if (!workDir.endsWith(File.separator)){\n                    permissions.add\n                        (new FilePermission(workDir,\"read,write\"));\n                    workDir = workDir + File.separator;\n                }\n                workDir = workDir + \"-\";\n                permissions.add(new FilePermission(\n                        workDir,\"read,write,delete\"));\n\n                // Allow the JSP to access org.apache.jasper.runtime.HttpJspBase\n                permissions.add( new RuntimePermission(\n                    \"accessClassInPackage.org.apache.jasper.runtime\") );\n\n                if (parentClassLoader instanceof URLClassLoader) {\n                    URL [] urls = ((URLClassLoader)parentClassLoader).getURLs();\n                    String jarUrl = null;\n                    String jndiUrl = null;\n                    for (int i=0; i<urls.length; i++) {\n                        if (jndiUrl == null\n                                && urls[i].toString().startsWith(\"jndi:\") ) {\n                            jndiUrl = urls[i].toString() + \"-\";\n                        }\n                        if (jarUrl == null\n                                && urls[i].toString().startsWith(\"jar:jndi:\")\n                                ) {\n                            jarUrl = urls[i].toString();\n                            jarUrl = jarUrl.substring(0,jarUrl.length() - 2);\n                            jarUrl = jarUrl.substring(0,\n                                     jarUrl.lastIndexOf('/')) + \"/-\";\n                        }\n                    }\n                    if (jarUrl != null) {\n                        permissions.add(\n                                new FilePermission(jarUrl,\"read\"));\n                        permissions.add(\n                                new FilePermission(jarUrl.substring(4),\"read\"));\n                    }\n                    if (jndiUrl != null)\n                        permissions.add(\n                                new FilePermission(jndiUrl,\"read\") );\n                }\n            } catch(Exception e) {\n                context.log(\"Security Init for context failed\",e);\n            }\n        }\n        return new SecurityHolder(source, permissions);\n    }",
                "    public void checkUnload() {\n\n        if (log.isTraceEnabled()) {\n            int queueLength = -1;\n            if (jspQueue != null) {\n                queueLength = jspQueue.getSize();\n            }\n            log.trace(Localizer.getMessage(\"jsp.message.jsp_unload_check\",\n                                           context.getContextPath(), \"\" + jsps.size(), \"\" + queueLength));\n        }\n        long now = System.currentTimeMillis();\n        if (jspIdleTimeout > 0) {\n            long unloadBefore = now - jspIdleTimeout;\n            Object [] wrappers = jsps.values().toArray();\n            for (int i = 0; i < wrappers.length; i++ ) {\n                JspServletWrapper jsw = (JspServletWrapper)wrappers[i];\n                synchronized(jsw) {\n                    if (jsw.getLastUsageTime() < unloadBefore) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(Localizer.getMessage(\"jsp.message.jsp_removed_idle\",\n                                                           jsw.getJspUri(), context.getContextPath(),\n                                                           \"\" + (now-jsw.getLastUsageTime())));\n                        }\n                        if (jspQueue != null) {\n                            jspQueue.remove(jsw.getUnloadHandle());\n                        }\n                        unloadJspServletWrapper(jsw);\n                    }\n                }\n            }\n        }\n        lastJspQueueUpdate = now;\n    }"
            ],
            "java\\org\\apache\\jasper\\servlet\\JspServlet.java": [
                "    public void init(ServletConfig config) throws ServletException {\n        \n        super.init(config);\n        this.config = config;\n        this.context = config.getServletContext();\n        \n        // Initialize the JSP Runtime Context\n        // Check for a custom Options implementation\n        String engineOptionsName = \n            config.getInitParameter(\"engineOptionsClass\");\n        if (engineOptionsName != null) {\n            // Instantiate the indicated Options implementation\n            try {\n                ClassLoader loader = Thread.currentThread()\n                        .getContextClassLoader();\n                Class<?> engineOptionsClass =\n                    loader.loadClass(engineOptionsName);\n                Class<?>[] ctorSig =\n                    { ServletConfig.class, ServletContext.class };\n                Constructor<?> ctor =\n                    engineOptionsClass.getConstructor(ctorSig);\n                Object[] args = { config, context };\n                options = (Options) ctor.newInstance(args);\n            } catch (Throwable e) {\n                e = ExceptionUtils.unwrapInvocationTargetException(e);\n                ExceptionUtils.handleThrowable(e);\n                // Need to localize this.\n                log.warn(\"Failed to load engineOptionsClass\", e);\n                // Use the default Options implementation\n                options = new EmbeddedServletOptions(config, context);\n            }\n        } else {\n            // Use the default Options implementation\n            options = new EmbeddedServletOptions(config, context);\n        }\n        rctxt = new JspRuntimeContext(context, options);\n        if (config.getInitParameter(\"jspFile\") != null) {\n            jspFile = config.getInitParameter(\"jspFile\");\n            try {\n                if (null == context.getResource(jspFile)) {\n                    throw new ServletException(\"missing jspFile: [\" + jspFile + \"]\");\n                }\n            } catch (MalformedURLException e) {\n                throw new ServletException(\"Can not locate jsp file\", e);\n            }\n            try {\n                if (SecurityUtil.isPackageProtectionEnabled()){\n                   AccessController.doPrivileged(new PrivilegedExceptionAction<Object>(){\n                        @Override\n                        public Object run() throws IOException, ServletException {\n                            serviceJspFile(null, null, jspFile, true);\n                            return null;\n                        }\n                    });\n                } else {\n                    serviceJspFile(null, null, jspFile, true);\n                }\n            } catch (IOException e) {\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n            } catch (PrivilegedActionException e) {\n                Throwable t = e.getCause();\n                if (t instanceof ServletException) throw (ServletException)t;\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n            }\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(Localizer.getMessage(\"jsp.message.scratch.dir.is\",\n                    options.getScratchDir().toString()));\n            log.debug(Localizer.getMessage(\"jsp.message.dont.modify.servlets\"));\n        }\n    }",
                "    boolean preCompile(HttpServletRequest request) throws ServletException {\n\n        String queryString = request.getQueryString();\n        if (queryString == null) {\n            return (false);\n        }\n        int start = queryString.indexOf(Constants.PRECOMPILE);\n        if (start < 0) {\n            return (false);\n        }\n        queryString =\n            queryString.substring(start + Constants.PRECOMPILE.length());\n        if (queryString.length() == 0) {\n            return (true);             // ?jsp_precompile\n        }\n        if (queryString.startsWith(\"&\")) {\n            return (true);             // ?jsp_precompile&foo=bar...\n        }\n        if (!queryString.startsWith(\"=\")) {\n            return (false);            // part of some other name or value\n        }\n        int limit = queryString.length();\n        int ampersand = queryString.indexOf(\"&\");\n        if (ampersand > 0) {\n            limit = ampersand;\n        }\n        String value = queryString.substring(1, limit);\n        if (value.equals(\"true\")) {\n            return (true);             // ?jsp_precompile=true\n        } else if (value.equals(\"false\")) {\n            // Spec says if jsp_precompile=false, the request should not\n            // be delivered to the JSP page; the easiest way to implement\n            // this is to set the flag to true, and precompile the page anyway.\n            // This still conforms to the spec, since it says the\n            // precompilation request can be ignored.\n            return (true);             // ?jsp_precompile=false\n        } else {\n            throw new ServletException(\"Cannot have request parameter \" +\n                                       Constants.PRECOMPILE + \" set to \" +\n                                       value);\n        }\n\n    }",
                "    public void destroy() {\n        if (log.isDebugEnabled()) {\n            log.debug(\"JspServlet.destroy()\");\n        }\n\n        rctxt.destroy();\n    }"
            ],
            "java\\org\\apache\\jasper\\tagplugins\\jstl\\core\\Import.java": [
                "    public void doTag(TagPluginContext ctxt) {\n        boolean hasContext, hasVar, hasScope, hasVarReader, hasCharEncoding;\n        \n        //flags\n        hasContext  = ctxt.isAttributeSpecified(\"context\");\n        hasVar = ctxt.isAttributeSpecified(\"var\");\n        hasScope = ctxt.isAttributeSpecified(\"scope\");\n        hasVarReader = ctxt.isAttributeSpecified(\"varReader\");\n        hasCharEncoding = ctxt.isAttributeSpecified(\"charEncoding\");\n        \n        //variables' names\n        String urlName = ctxt.getTemporaryVariableName();           \n        String contextName = ctxt.getTemporaryVariableName();       \n        String iauName = ctxt.getTemporaryVariableName();           // is absolute url\n        String urlObjName = ctxt.getTemporaryVariableName();        //URL object\n        String ucName = ctxt.getTemporaryVariableName();            //URLConnection\n        String inputStreamName = ctxt.getTemporaryVariableName();   \n        String tempReaderName = ctxt.getTemporaryVariableName();\n        String tempReaderName2 = ctxt.getTemporaryVariableName();\n        String charSetName = ctxt.getTemporaryVariableName();\n        String charEncodingName = ctxt.getTemporaryVariableName();\n        String contentTypeName = ctxt.getTemporaryVariableName();\n        String varReaderName = ctxt.getTemporaryVariableName();\n        String servletContextName = ctxt.getTemporaryVariableName();\n        String servletPathName = ctxt.getTemporaryVariableName();\n        String requestDispatcherName = ctxt.getTemporaryVariableName();\n        String irwName = ctxt.getTemporaryVariableName();           //ImportResponseWrapper name\n        String brName = ctxt.getTemporaryVariableName();            //BufferedReader name\n        String sbName = ctxt.getTemporaryVariableName();            //StringBuilder name\n        String tempStringName = ctxt.getTemporaryVariableName();\n        \n        //is absolute url\n        ctxt.generateJavaSource(\"boolean \" + iauName + \";\");\n        \n        //get the url value\n        ctxt.generateJavaSource(\"String \" + urlName + \" = \");\n        ctxt.generateAttribute(\"url\");\n        ctxt.generateJavaSource(\";\");\n        \n        //validate the url\n        ctxt.generateJavaSource(\"if(\" + urlName + \" == null || \" + urlName + \".equals(\\\"\\\")){\");\n        ctxt.generateJavaSource(\"    throw new JspTagException(\\\"The \\\\\\\"url\\\\\\\" attribute \" +\n        \"illegally evaluated to \\\\\\\"null\\\\\\\" or \\\\\\\"\\\\\\\" in &lt;import&gt;\\\");\");\n        ctxt.generateJavaSource(\"}\");\n        \n        //initialize the is_absolute_url\n        ctxt.generateJavaSource(iauName + \" = \" +\n                \"org.apache.jasper.tagplugins.jstl.Util.isAbsoluteUrl(\" + urlName + \");\");\n        \n        //validate the context\n        if(hasContext){\n            \n            ctxt.generateJavaSource(\"String \" + contextName + \" = \");\n            ctxt.generateAttribute(\"context\");\n            ctxt.generateJavaSource(\";\");\n            \n            ctxt.generateJavaSource(\"if((!\" + contextName + \".startsWith(\\\"/\\\")) \" +\n                    \"|| (!\" + urlName + \".startsWith(\\\"/\\\"))){\");\n            ctxt.generateJavaSource(\"    throw new JspTagException\" +\n                    \"(\\\"In URL tags, when the \\\\\\\"context\\\\\\\" attribute is specified, \" +\n            \"values of both \\\\\\\"context\\\\\\\" and \\\\\\\"url\\\\\\\" must start with \\\\\\\"/\\\\\\\".\\\");\");\n            ctxt.generateJavaSource(\"}\");\n            \n        }\n        \n        //define charset\n        ctxt.generateJavaSource(\"String \" + charSetName + \" = null;\");\n        \n        //if the charEncoding attribute is specified\n        if(hasCharEncoding){\n            \n            //initialize the charEncoding\n            ctxt.generateJavaSource(\"String \" + charEncodingName + \" = \");\n            ctxt.generateAttribute(\"charEncoding\");\n            ctxt.generateJavaSource(\";\");\n            \n            //assign appropriate value to the charset\n            ctxt.generateJavaSource(\"if(null != \" + charEncodingName + \" \" +\n                    \"&& !\" + charEncodingName + \".equals(\\\"\\\")){\");\n            ctxt.generateJavaSource(\"    \" + charSetName + \" = \" \n                    + charEncodingName + \";\");\n            ctxt.generateJavaSource(\"}\");\n        }\n        \n        //reshape the url string\n        ctxt.generateJavaSource(\"if(!\"+iauName+\"){\");\n        ctxt.generateJavaSource(\"    if(!\" + urlName + \".startsWith(\\\"/\\\")){\");\n        ctxt.generateJavaSource(\"        String \" + servletPathName + \" = \" +\n        \"((HttpServletRequest)pageContext.getRequest()).getServletPath();\");\n        ctxt.generateJavaSource(\"        \" + urlName + \" = \" \n                + servletPathName + \".substring(0,\" + servletPathName + \".lastIndexOf('/')) + '/' + \" + urlName + \";\");\n        ctxt.generateJavaSource(\"    }\");\n        ctxt.generateJavaSource(\"}\");\n        \n        //if the varReader attribute specified\n        if(hasVarReader){\n            \n            //get the String value of varReader\n            ctxt.generateJavaSource(\"String \" + varReaderName + \" = \");\n            ctxt.generateAttribute(\"varReader\");\n            ctxt.generateJavaSource(\";\");\n            \n            //if the url is absolute url\n            ctxt.generateJavaSource(\"if(\" + iauName + \"){\");\n            \n            //get the content of the target\n            ctxt.generateJavaSource(\"    java.net.URL \" + urlObjName + \" = new java.net.URL(\" + urlName + \");\");\n            ctxt.generateJavaSource(\"    java.net.URLConnection \" + ucName + \" = \" \n                    + urlObjName + \".openConnection();\");\n            ctxt.generateJavaSource(\"    java.io.InputStream \" + inputStreamName + \" = \" \n                    + ucName + \".getInputStream();\");\n            \n            ctxt.generateJavaSource(\"    if(\" + charSetName + \" == null){\");\n            ctxt.generateJavaSource(\"        String \" + contentTypeName + \" = \" \n                    + ucName + \".getContentType();\");\n            ctxt.generateJavaSource(\"        if(null != \" + contentTypeName + \"){\");\n            ctxt.generateJavaSource(\"            \" + charSetName + \" = \" +\n                    \"org.apache.jasper.tagplugins.jstl.Util.getContentTypeAttribute(\" + contentTypeName + \", \\\"charset\\\");\");\n            ctxt.generateJavaSource(\"            if(\" + charSetName + \" == null) \" \n                    + charSetName + \" = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;\");\n            ctxt.generateJavaSource(\"        }else{\");\n            ctxt.generateJavaSource(\"            \" + charSetName + \" = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;\");\n            ctxt.generateJavaSource(\"        }\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            if(!hasCharEncoding){\n                ctxt.generateJavaSource(\"    String \" + contentTypeName + \" = \" + ucName + \".getContentType();\");\n            }\n            \n            //define the Reader\n            ctxt.generateJavaSource(\"    java.io.Reader \" + tempReaderName + \" = null;\");\n            \n            //initialize the Reader object\n            ctxt.generateJavaSource(\"    try{\");\n            ctxt.generateJavaSource(\"        \" + tempReaderName + \" = new java.io.InputStreamReader(\" + inputStreamName + \", \" + charSetName + \");\");\n            ctxt.generateJavaSource(\"    }catch(Exception ex){\");\n            ctxt.generateJavaSource(\"        \" + tempReaderName + \" = new java.io.InputStreamReader(\" + inputStreamName + \", org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING);\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            //validate the response\n            ctxt.generateJavaSource(\"    if(\" + ucName + \" instanceof java.net.HttpURLConnection){\");\n            ctxt.generateJavaSource(\"        int status = ((java.net.HttpURLConnection) \" + ucName + \").getResponseCode();\");\n            ctxt.generateJavaSource(\"        if(status < 200 || status > 299){\");\n            ctxt.generateJavaSource(\"            throw new JspTagException(status + \\\" \\\" + \" + urlName + \");\");\n            ctxt.generateJavaSource(\"        }\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            //set attribute in the page context scope\n            ctxt.generateJavaSource(\"    pageContext.setAttribute(\" + varReaderName + \", \" + tempReaderName + \");\");\n            \n            //if the url is relative\n            ctxt.generateJavaSource(\"}else{\");\n            \n            //if the url is relative, http request is needed\n            ctxt.generateJavaSource(\"    if (!(pageContext.getRequest() instanceof HttpServletRequest  \" +\n            \"&& pageContext.getResponse() instanceof HttpServletResponse)){\");\n            ctxt.generateJavaSource(\"        throw new JspTagException(\\\"Relative &lt;import&gt; from non-HTTP request not allowed\\\");\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            //get the servlet context of the context defined in the context attribute\n            ctxt.generateJavaSource(\"    ServletContext \" + servletContextName + \" = null;\");\n            if(hasContext){\n                ctxt.generateJavaSource(\"    if(null != \" + contextName + \"){\");\n                ctxt.generateJavaSource(\"        \" + servletContextName + \" = pageContext.getServletContext().getContext(\" + contextName + \");\" );\n                ctxt.generateJavaSource(\"    }else{\");\n                ctxt.generateJavaSource(\"        \" + servletContextName + \" = pageContext.getServletContext();\");\n                ctxt.generateJavaSource(\"    }\");\n            }else{\n                ctxt.generateJavaSource(\"    \" + servletContextName + \" = pageContext.getServletContext();\");\n            }\n            \n            //\n            ctxt.generateJavaSource(\"    if(\" + servletContextName + \" == null){\");\n            if(hasContext){\n                ctxt.generateJavaSource(\"        throw new JspTagException(\\\"Unable to get RequestDispatcher for Context: \\\\\\\" \\\"+\" + contextName + \"+\\\" \\\\\\\" and URL: \\\\\\\" \\\" +\" + urlName + \"+ \\\" \\\\\\\". Verify values and/or enable cross context access.\\\");\");\n            }else{\n                ctxt.generateJavaSource(\"        throw new JspTagException(\\\"Unable to get RequestDispatcher for  URL: \\\\\\\" \\\" +\" + urlName + \"+ \\\" \\\\\\\". Verify values and/or enable cross context access.\\\");\");\n            }\n            ctxt.generateJavaSource(\"    }\");\n            \n            //get the request dispatcher\n            ctxt.generateJavaSource(\"    RequestDispatcher \" + requestDispatcherName + \" = \" + servletContextName + \".getRequestDispatcher(org.apache.jasper.tagplugins.jstl.Util.stripSession(\"+urlName+\"));\");\n            ctxt.generateJavaSource(\"    if(\" + requestDispatcherName + \" == null) throw new JspTagException(org.apache.jasper.tagplugins.jstl.Util.stripSession(\"+urlName+\"));\");\n            \n            //initialize a ImportResponseWrapper to include the resource\n            ctxt.generateJavaSource(\"    org.apache.jasper.tagplugins.jstl.Util.ImportResponseWrapper \" + irwName + \" = new org.apache.jasper.tagplugins.jstl.Util.ImportResponseWrapper((HttpServletResponse) pageContext.getResponse());\");\n            ctxt.generateJavaSource(\"    if(\" + charSetName + \" == null){\");\n            ctxt.generateJavaSource(\"        \" + charSetName + \" = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;\");\n            ctxt.generateJavaSource(\"    }\");\n            ctxt.generateJavaSource(\"    \" + irwName + \".setCharEncoding(\" + charSetName + \");\");\n            ctxt.generateJavaSource(\"    try{\");\n            ctxt.generateJavaSource(\"        \" + requestDispatcherName + \".include(pageContext.getRequest(), \" + irwName + \");\");\n            ctxt.generateJavaSource(\"    }catch(java.io.IOException ex){\");\n            ctxt.generateJavaSource(\"        throw new JspException(ex);\");\n            ctxt.generateJavaSource(\"    }catch(RuntimeException ex){\");\n            ctxt.generateJavaSource(\"        throw new JspException(ex);\");\n            ctxt.generateJavaSource(\"    }catch(ServletException ex){\");\n            ctxt.generateJavaSource(\"        Throwable rc = ex.getRootCause();\");\n            ctxt.generateJavaSource(\"        if (rc == null)\");\n            ctxt.generateJavaSource(\"            throw new JspException(ex);\");\n            ctxt.generateJavaSource(\"        else\");\n            ctxt.generateJavaSource(\"            throw new JspException(rc);\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            //validate the response status\n            ctxt.generateJavaSource(\"    if(\" + irwName + \".getStatus() < 200 || \" + irwName + \".getStatus() > 299){\");\n            ctxt.generateJavaSource(\"        throw new JspTagException(\" + irwName + \".getStatus()+\\\" \\\" + org.apache.jasper.tagplugins.jstl.Util.stripSession(\" + urlName + \"));\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            //push in the page context\n            ctxt.generateJavaSource(\"    java.io.Reader \" + tempReaderName + \" = new java.io.StringReader(\" + irwName + \".getString());\");\n            ctxt.generateJavaSource(\"    pageContext.setAttribute(\" + varReaderName + \", \" + tempReaderName + \");\");\n            \n            ctxt.generateJavaSource(\"}\");\n            \n            //execute the body action\n            ctxt.generateBody();\n            \n            //close the reader\n            ctxt.generateJavaSource(\"java.io.Reader \" + tempReaderName2 + \" = (java.io.Reader)pageContext.getAttribute(\" + varReaderName + \");\");\n            ctxt.generateJavaSource(\"if(\" + tempReaderName2 + \" != null) \" + tempReaderName2 + \".close();\");\n            ctxt.generateJavaSource(\"pageContext.removeAttribute(\" + varReaderName + \",1);\");\n        }\n        \n        //if the varReader is not specified \n        else{\n            \n            ctxt.generateJavaSource(\"pageContext.setAttribute(\\\"url_without_param\\\",\" + urlName + \");\");\n            ctxt.generateBody();\n            ctxt.generateJavaSource(urlName + \" = (String)pageContext.getAttribute(\\\"url_without_param\\\");\");\n            ctxt.generateJavaSource(\"pageContext.removeAttribute(\\\"url_without_param\\\");\");\n            String strScope = \"page\";\n            if(hasScope){\n                strScope = ctxt.getConstantAttribute(\"scope\");\n            }\n            int iScope = Util.getScope(strScope);\n            \n            ctxt.generateJavaSource(\"String \" + tempStringName + \" = null;\");\n            \n            ctxt.generateJavaSource(\"if(\" + iauName + \"){\");\n            \n            //get the content of the target\n            ctxt.generateJavaSource(\"    java.net.URL \" + urlObjName + \" = new java.net.URL(\" + urlName + \");\");\n            ctxt.generateJavaSource(\"    java.net.URLConnection \" + ucName + \" = \" + urlObjName + \".openConnection();\");\n            ctxt.generateJavaSource(\"    java.io.InputStream \" + inputStreamName + \" = \" + ucName + \".getInputStream();\");\n            ctxt.generateJavaSource(\"    java.io.Reader \" + tempReaderName + \" = null;\");\n            \n            ctxt.generateJavaSource(\"    if(\" + charSetName + \" == null){\");\n            ctxt.generateJavaSource(\"        String \" + contentTypeName + \" = \" \n                    + ucName + \".getContentType();\");\n            ctxt.generateJavaSource(\"        if(null != \" + contentTypeName + \"){\");\n            ctxt.generateJavaSource(\"            \" + charSetName + \" = \" +\n                    \"org.apache.jasper.tagplugins.jstl.Util.getContentTypeAttribute(\" + contentTypeName + \", \\\"charset\\\");\");\n            ctxt.generateJavaSource(\"            if(\" + charSetName + \" == null) \" \n                    + charSetName + \" = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;\");\n            ctxt.generateJavaSource(\"        }else{\");\n            ctxt.generateJavaSource(\"            \" + charSetName + \" = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;\");\n            ctxt.generateJavaSource(\"        }\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            ctxt.generateJavaSource(\"    try{\");\n            ctxt.generateJavaSource(\"        \" + tempReaderName + \" = new java.io.InputStreamReader(\" + inputStreamName + \",\" + charSetName + \");\");\n            ctxt.generateJavaSource(\"    }catch(Exception ex){\");\n            //ctxt.generateJavaSource(\"        throw new JspTagException(ex.toString());\");\n            ctxt.generateJavaSource(\"        \" + tempReaderName + \" = new java.io.InputStreamReader(\" + inputStreamName + \",org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING);\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            //validate the response\n            ctxt.generateJavaSource(\"    if(\" + ucName + \" instanceof java.net.HttpURLConnection){\");\n            ctxt.generateJavaSource(\"        int status = ((java.net.HttpURLConnection) \" + ucName + \").getResponseCode();\");\n            ctxt.generateJavaSource(\"        if(status < 200 || status > 299){\");\n            ctxt.generateJavaSource(\"            throw new JspTagException(status + \\\" \\\" + \" + urlName + \");\");\n            ctxt.generateJavaSource(\"        }\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            ctxt.generateJavaSource(\"    java.io.BufferedReader \" + brName + \" =  new java.io.BufferedReader(\" + tempReaderName + \");\");\n            ctxt.generateJavaSource(\"    StringBuilder \" + sbName + \" = new StringBuilder();\");\n            String index = ctxt.getTemporaryVariableName();\n            ctxt.generateJavaSource(\"    int \" + index + \";\");\n            ctxt.generateJavaSource(\"    while((\"+index+\" = \"+brName+\".read()) != -1) \"+sbName+\".append((char)\"+index+\");\");\n            ctxt.generateJavaSource(\"    \" + tempStringName + \" = \" +sbName + \".toString();\");\n            \n            ctxt.generateJavaSource(\"}else{\");\n            \n            //if the url is relative, http request is needed.\n            ctxt.generateJavaSource(\"    if (!(pageContext.getRequest() instanceof HttpServletRequest  \" +\n            \"&& pageContext.getResponse() instanceof HttpServletResponse)){\");\n            ctxt.generateJavaSource(\"        throw new JspTagException(\\\"Relative &lt;import&gt; from non-HTTP request not allowed\\\");\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            //get the servlet context of the context defined in the context attribute\n            ctxt.generateJavaSource(\"    ServletContext \" + servletContextName + \" = null;\");\n            if(hasContext){\n                ctxt.generateJavaSource(\"    if(null != \" + contextName + \"){\");\n                ctxt.generateJavaSource(\"        \" + servletContextName + \" = pageContext.getServletContext().getContext(\" + contextName + \");\" );\n                ctxt.generateJavaSource(\"    }else{\");\n                ctxt.generateJavaSource(\"        \" + servletContextName + \" = pageContext.getServletContext();\");\n                ctxt.generateJavaSource(\"    }\");\n            }else{\n                ctxt.generateJavaSource(\"    \" + servletContextName + \" = pageContext.getServletContext();\");\n            }\n            \n            //\n            ctxt.generateJavaSource(\"    if(\" + servletContextName + \" == null){\");\n            if(hasContext){\n                ctxt.generateJavaSource(\"        throw new JspTagException(\\\"Unable to get RequestDispatcher for Context: \\\\\\\" \\\" +\" + contextName + \"+ \\\" \\\\\\\" and URL: \\\\\\\" \\\" +\" + urlName + \"+ \\\" \\\\\\\". Verify values and/or enable cross context access.\\\");\");\n            }else{\n                ctxt.generateJavaSource(\"        throw new JspTagException(\\\"Unable to get RequestDispatcher for URL: \\\\\\\" \\\" +\" + urlName + \"+ \\\" \\\\\\\". Verify values and/or enable cross context access.\\\");\");\n            }\n            ctxt.generateJavaSource(\"    }\");\n            \n            //get the request dispatcher\n            ctxt.generateJavaSource(\"    RequestDispatcher \" + requestDispatcherName + \" = \" + servletContextName + \".getRequestDispatcher(org.apache.jasper.tagplugins.jstl.Util.stripSession(\"+urlName+\"));\");\n            ctxt.generateJavaSource(\"    if(\" + requestDispatcherName + \" == null) throw new JspTagException(org.apache.jasper.tagplugins.jstl.Util.stripSession(\"+urlName+\"));\");\n            \n            //initialize a ImportResponseWrapper to include the resource\n            ctxt.generateJavaSource(\"    org.apache.jasper.tagplugins.jstl.Util.ImportResponseWrapper \" + irwName + \" = new org.apache.jasper.tagplugins.jstl.Util.ImportResponseWrapper((HttpServletResponse) pageContext.getResponse());\");\n            ctxt.generateJavaSource(\"    if(\" + charSetName + \" == null){\");\n            ctxt.generateJavaSource(\"        \" + charSetName + \" = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;\");\n            ctxt.generateJavaSource(\"    }\");\n            ctxt.generateJavaSource(\"    \" + irwName + \".setCharEncoding(\" + charSetName + \");\");\n            ctxt.generateJavaSource(\"    try{\");\n            ctxt.generateJavaSource(\"        \" + requestDispatcherName + \".include(pageContext.getRequest(), \" + irwName + \");\");\n            ctxt.generateJavaSource(\"    }catch(java.io.IOException ex){\");\n            ctxt.generateJavaSource(\"        throw new JspException(ex);\");\n            ctxt.generateJavaSource(\"    }catch(RuntimeException ex){\");\n            ctxt.generateJavaSource(\"        throw new JspException(ex);\");\n            ctxt.generateJavaSource(\"    }catch(ServletException ex){\");\n            ctxt.generateJavaSource(\"        Throwable rc = ex.getRootCause();\");\n            ctxt.generateJavaSource(\"        if (rc == null)\");\n            ctxt.generateJavaSource(\"            throw new JspException(ex);\");\n            ctxt.generateJavaSource(\"        else\");\n            ctxt.generateJavaSource(\"            throw new JspException(rc);\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            //validate the response status\n            ctxt.generateJavaSource(\"    if(\" + irwName + \".getStatus() < 200 || \" + irwName + \".getStatus() > 299){\");\n            ctxt.generateJavaSource(\"        throw new JspTagException(\" + irwName + \".getStatus()+\\\" \\\" + org.apache.jasper.tagplugins.jstl.Util.stripSession(\" + urlName + \"));\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            ctxt.generateJavaSource(\"    \" + tempStringName + \" = \" + irwName + \".getString();\");\n            \n            ctxt.generateJavaSource(\"}\");\n            \n            if(hasVar){\n                String strVar = ctxt.getConstantAttribute(\"var\");\n                ctxt.generateJavaSource(\"pageContext.setAttribute(\\\"\"+strVar+\"\\\",\" + tempStringName + \",\" + iScope + \");\");\n            }else{\n                ctxt.generateJavaSource(\"pageContext.getOut().print(\" + tempStringName + \");\");\n            }\n        }\n    }"
            ],
            "java\\org\\apache\\jasper\\JspC.java": [
                "    protected void addExtension(final String extension) {\n        if(extension != null) {\n            if(extensions == null) {\n                extensions = new Vector<String>();\n            }\n\n            extensions.add(extension);\n        }\n    }",
                "    protected void mergeIntoWebXml() throws IOException {\n\n        File webappBase = new File(uriRoot);\n        File webXml = new File(webappBase, \"WEB-INF/web.xml\");\n        File webXml2 = new File(webappBase, \"WEB-INF/web2.xml\");\n        String insertStartMarker =\n            Localizer.getMessage(\"jspc.webinc.insertStart\");\n        String insertEndMarker =\n            Localizer.getMessage(\"jspc.webinc.insertEnd\");\n\n        BufferedReader reader = new BufferedReader(openWebxmlReader(webXml));\n        BufferedReader fragmentReader = new BufferedReader(\n                openWebxmlReader(new File(webxmlFile)));\n        PrintWriter writer = new PrintWriter(openWebxmlWriter(webXml2));\n\n        // Insert the <servlet> and <servlet-mapping> declarations\n        boolean inserted = false;\n        int current = reader.read();\n        while (current > -1) {\n            if (current == '<') {\n                String element = getElement(reader);\n                if (!inserted && insertBefore.contains(element)) {\n                    // Insert generated content here\n                    writer.println(insertStartMarker);\n                    while (true) {\n                        String line = fragmentReader.readLine();\n                        if (line == null) {\n                            writer.println();\n                            break;\n                        }\n                        writer.println(line);\n                    }\n                    writer.println(insertEndMarker);\n                    writer.println();\n                    writer.write(element);\n                    inserted = true;\n                } else if (element.equals(insertStartMarker)) {\n                    // Skip the previous auto-generated content\n                    while (true) {\n                        current = reader.read();\n                        if (current < 0) {\n                            throw new EOFException();\n                        }\n                        if (current == '<') {\n                            element = getElement(reader);\n                            if (element.equals(insertEndMarker)) {\n                                break;\n                            }\n                        }\n                    }\n                    current = reader.read();\n                    while (current == '\\n' || current == '\\r') {\n                        current = reader.read();\n                    }\n                    continue;\n                } else {\n                    writer.write(element);\n                }\n            } else {\n                writer.write(current);\n            }\n            current = reader.read();\n        }\n        writer.close();\n\n        reader.close();\n        fragmentReader.close();\n\n        FileInputStream fis = new FileInputStream(webXml2);\n        FileOutputStream fos = new FileOutputStream(webXml);\n\n        byte buf[] = new byte[512];\n        while (true) {\n            int n = fis.read(buf);\n            if (n < 0) {\n                break;\n            }\n            fos.write(buf, 0, n);\n        }\n\n        fis.close();\n        fos.close();\n\n        if(!webXml2.delete() && log.isDebugEnabled())\n            log.debug(Localizer.getMessage(\"jspc.delete.fail\",\n                    webXml2.toString()));\n        \n        if (!(new File(webxmlFile)).delete() && log.isDebugEnabled())\n            log.debug(Localizer.getMessage(\"jspc.delete.fail\", webxmlFile));\n\n    }",
                "    public void scanFiles( File base ) throws JasperException {\n        Stack<String> dirs = new Stack<String>();\n        dirs.push(base.toString());\n\n        // Make sure default extensions are always included\n        if ((getExtensions() == null) || (getExtensions().size() < 2)) {\n            addExtension(\"jsp\");\n            addExtension(\"jspx\");\n        }\n\n        while (!dirs.isEmpty()) {\n            String s = dirs.pop();\n            File f = new File(s);\n            if (f.exists() && f.isDirectory()) {\n                String[] files = f.list();\n                String ext;\n                for (int i = 0; (files != null) && i < files.length; i++) {\n                    File f2 = new File(s, files[i]);\n                    if (f2.isDirectory()) {\n                        dirs.push(f2.getPath());\n                    } else {\n                        String path = f2.getPath();\n                        String uri = path.substring(uriRoot.length());\n                        ext = files[i].substring(files[i].lastIndexOf('.') +1);\n                        if (getExtensions().contains(ext) ||\n                            jspConfig.isJspPage(uri)) {\n                            pages.add(path);\n                        }\n                    }\n                }\n            }\n        }\n    }",
                "    public void execute() {\n        if(log.isDebugEnabled()) {\n            log.debug(\"execute() starting for \" + pages.size() + \" pages.\");\n        }\n\n        try {\n            if (uriRoot == null) {\n                if( pages.size() == 0 ) {\n                    throw new JasperException(\n                        Localizer.getMessage(\"jsp.error.jspc.missingTarget\"));\n                }\n                String firstJsp = pages.get( 0 );\n                File firstJspF = new File( firstJsp );\n                if (!firstJspF.exists()) {\n                    throw new JasperException(\n                        Localizer.getMessage(\"jspc.error.fileDoesNotExist\",\n                                             firstJsp));\n                }\n                locateUriRoot( firstJspF );\n            }\n\n            if (uriRoot == null) {\n                throw new JasperException(\n                    Localizer.getMessage(\"jsp.error.jspc.no_uriroot\"));\n            }\n\n            File uriRootF = new File(uriRoot);\n            if (!uriRootF.isDirectory()) {\n                throw new JasperException(\n                    Localizer.getMessage(\"jsp.error.jspc.uriroot_not_dir\"));\n            }\n\n            if(context == null) {\n                initServletContext();\n            }\n\n            // No explicit pages, we'll process all .jsp in the webapp\n            if (pages.size() == 0) {\n                scanFiles(uriRootF);\n            }\n\n            initWebXml();\n\n            Iterator<String> iter = pages.iterator();\n            while (iter.hasNext()) {\n                String nextjsp = iter.next().toString();\n                File fjsp = new File(nextjsp);\n                if (!fjsp.isAbsolute()) {\n                    fjsp = new File(uriRootF, nextjsp);\n                }\n                if (!fjsp.exists()) {\n                    if (log.isWarnEnabled()) {\n                        log.warn\n                            (Localizer.getMessage\n                             (\"jspc.error.fileDoesNotExist\", fjsp.toString()));\n                    }\n                    continue;\n                }\n                String s = fjsp.getAbsolutePath();\n                if (s.startsWith(uriRoot)) {\n                    nextjsp = s.substring(uriRoot.length());\n                }\n                if (nextjsp.startsWith(\".\" + File.separatorChar)) {\n                    nextjsp = nextjsp.substring(2);\n                }\n                processFile(nextjsp);\n            }\n\n            completeWebXml();\n\n            if (addWebXmlMappings) {\n                mergeIntoWebXml();\n            }\n\n        } catch (IOException ioe) {\n            throw new BuildException(ioe);\n\n        } catch (JasperException je) {\n            Throwable rootCause = je;\n            while (rootCause instanceof JasperException\n                    && ((JasperException) rootCause).getRootCause() != null) {\n                rootCause = ((JasperException) rootCause).getRootCause();\n            }\n            if (rootCause != je) {\n                rootCause.printStackTrace();\n            }\n            throw new BuildException(je);\n        } finally {\n            if (loader != null) {\n                LogFactory.release(loader);\n            }\n        }\n    }",
                "    protected String nextArg() {\n        if ((argPos >= args.length)\n            || (fullstop = SWITCH_FULL_STOP.equals(args[argPos]))) {\n            return null;\n        } else {\n            return args[argPos++];\n        }\n    }\n\n    protected String nextFile() {\n        if (fullstop) argPos++;\n        if (argPos >= args.length) {\n            return null;\n        } else {\n            return args[argPos++];\n        }\n    }\n\n    protected void initWebXml() {\n        try {\n            if (webxmlLevel >= INC_WEBXML) {\n                mapout = openWebxmlWriter(new File(webxmlFile));\n                servletout = new CharArrayWriter();\n                mappingout = new CharArrayWriter();\n            } else {\n                mapout = null;\n                servletout = null;\n                mappingout = null;\n            }\n            if (webxmlLevel >= ALL_WEBXML) {\n                mapout.write(Localizer.getMessage(\"jspc.webxml.header\"));\n                mapout.flush();\n            } else if ((webxmlLevel>= INC_WEBXML) && !addWebXmlMappings) {\n                mapout.write(Localizer.getMessage(\"jspc.webinc.header\"));\n                mapout.flush();\n            }\n        } catch (IOException ioe) {\n            mapout = null;\n            servletout = null;\n            mappingout = null;\n        }\n    }",
                "    protected void completeWebXml() {\n        if (mapout != null) {\n            try {\n                servletout.writeTo(mapout);\n                mappingout.writeTo(mapout);\n                if (webxmlLevel >= ALL_WEBXML) {\n                    mapout.write(Localizer.getMessage(\"jspc.webxml.footer\"));\n                } else if ((webxmlLevel >= INC_WEBXML) && !addWebXmlMappings) {\n                    mapout.write(Localizer.getMessage(\"jspc.webinc.footer\"));\n                }\n                mapout.close();\n            } catch (IOException ioe) {\n                // noting to do if it fails since we are done with it\n            }\n        }\n    }\n\n    protected void initServletContext() {\n        try {\n            context =new JspCServletContext\n                (new PrintWriter(System.out),\n                 new URL(\"file:\" + uriRoot.replace('\\\\','/') + '/'));\n            tldLocationsCache = TldLocationsCache.getInstance(context);\n        } catch (MalformedURLException me) {\n            System.out.println(\"**\" + me);\n        }\n        if (isValidateTld()) {\n            context.setInitParameter(Constants.XML_VALIDATION_TLD_INIT_PARAM, \"true\");\n        }\n        context.setInitParameter(Constants.XML_BLOCK_EXTERNAL_INIT_PARAM,\n                String.valueOf(isBlockExternal()));\n\n        rctxt = new JspRuntimeContext(context, this);\n        jspConfig = new JspConfig(context);\n        tagPluginManager = new TagPluginManager(context);\n    }",
                "    protected void locateUriRoot( File f ) {\n        String tUriBase = uriBase;\n        if (tUriBase == null) {\n            tUriBase = \"/\";\n        }\n        try {\n            if (f.exists()) {\n                f = new File(f.getAbsolutePath());\n                while (true) {\n                    File g = new File(f, \"WEB-INF\");\n                    if (g.exists() && g.isDirectory()) {\n                        uriRoot = f.getCanonicalPath();\n                        uriBase = tUriBase;\n                        if (log.isInfoEnabled()) {\n                            log.info(Localizer.getMessage(\n                                        \"jspc.implicit.uriRoot\",\n                                        uriRoot));\n                        }\n                        break;\n                    }\n                    if (f.exists() && f.isDirectory()) {\n                        tUriBase = \"/\" + f.getName() + \"/\" + tUriBase;\n                    }\n\n                    String fParent = f.getParent();\n                    if (fParent == null) {\n                        break;\n                    } else {\n                        f = new File(fParent);\n                    }\n\n                    // If there is no acceptable candidate, uriRoot will\n                    // remain null to indicate to the CompilerContext to\n                    // use the current working/user dir.\n                }\n\n                if (uriRoot != null) {\n                    File froot = new File(uriRoot);\n                    uriRoot = froot.getCanonicalPath();\n                }\n            }\n        } catch (IOException ioe) {\n            // since this is an optional default and a null value\n            // for uriRoot has a non-error meaning, we can just\n            // pass straight through\n        }\n    }",
                "     protected File resolveFile(final String s) {\n         if(getProject() == null) {\n             // Note FileUtils.getFileUtils replaces FileUtils.newFileUtils in Ant 1.6.3\n             return FileUtils.getFileUtils().resolveFile(null, s);\n         } else {\n             return FileUtils.getFileUtils().resolveFile(getProject().getBaseDir(), s);\n         }\n     }\n\n    private Reader openWebxmlReader(File file) throws IOException {\n        FileInputStream fis = new FileInputStream(file);\n        try {\n            return webxmlEncoding != null ? new InputStreamReader(fis,\n                    webxmlEncoding) : new InputStreamReader(fis);\n        } catch (IOException ex) {\n            fis.close();\n            throw ex;\n        }\n    }\n\n    private Writer openWebxmlWriter(File file) throws IOException {\n        FileOutputStream fos = new FileOutputStream(file);\n        try {\n            return webxmlEncoding != null ? new OutputStreamWriter(fos,\n                    webxmlEncoding) : new OutputStreamWriter(fos);\n        } catch (IOException ex) {\n            fos.close();\n            throw ex;\n        }\n    }"
            ],
            "java\\org\\apache\\jasper\\servlet\\JspCServletContext.java": [
                "    public void log(Exception exception, String message) {\n\n        log(message, exception);\n\n    }\n\n    public void log(String message, Throwable exception) {\n\n        myLogWriter.println(message);\n        exception.printStackTrace(myLogWriter);\n\n    }"
            ],
            "java\\org\\apache\\jasper\\compiler\\Compiler.java": [
                "    protected String[] generateJava() throws Exception {\n\n        String[] smapStr = null;\n\n        long t1, t2, t3, t4;\n\n        t1 = t2 = t3 = t4 = 0;\n\n        if (log.isDebugEnabled()) {\n            t1 = System.currentTimeMillis();\n        }\n\n        // Setup page info area\n        pageInfo = new PageInfo(new BeanRepository(ctxt.getClassLoader(),\n                errDispatcher), ctxt.getJspFile(), ctxt.isTagFile());\n\n        JspConfig jspConfig = options.getJspConfig();\n        JspConfig.JspProperty jspProperty = jspConfig.findJspProperty(ctxt\n                .getJspFile());\n\n        /*\n         * If the current uri is matched by a pattern specified in a\n         * jsp-property-group in web.xml, initialize pageInfo with those\n         * properties.\n         */\n        if (jspProperty.isELIgnored() != null) {\n            pageInfo.setELIgnored(JspUtil.booleanValue(jspProperty\n                    .isELIgnored()));\n        }\n        if (jspProperty.isScriptingInvalid() != null) {\n            pageInfo.setScriptingInvalid(JspUtil.booleanValue(jspProperty\n                    .isScriptingInvalid()));\n        }\n        if (jspProperty.getIncludePrelude() != null) {\n            pageInfo.setIncludePrelude(jspProperty.getIncludePrelude());\n        }\n        if (jspProperty.getIncludeCoda() != null) {\n            pageInfo.setIncludeCoda(jspProperty.getIncludeCoda());\n        }\n        if (jspProperty.isDeferedSyntaxAllowedAsLiteral() != null) {\n            pageInfo.setDeferredSyntaxAllowedAsLiteral(JspUtil.booleanValue(jspProperty\n                    .isDeferedSyntaxAllowedAsLiteral()));\n        }\n        if (jspProperty.isTrimDirectiveWhitespaces() != null) {\n            pageInfo.setTrimDirectiveWhitespaces(JspUtil.booleanValue(jspProperty\n                    .isTrimDirectiveWhitespaces()));\n        }\n        // Default ContentType processing is deferred until after the page has\n        // been parsed\n        if (jspProperty.getBuffer() != null) {\n            pageInfo.setBufferValue(jspProperty.getBuffer(), null,\n                    errDispatcher);\n        }\n        if (jspProperty.isErrorOnUndeclaredNamespace() != null) {\n            pageInfo.setErrorOnUndeclaredNamespace(\n                    JspUtil.booleanValue(\n                            jspProperty.isErrorOnUndeclaredNamespace()));\n        }\n        if (ctxt.isTagFile()) {\n            try {\n                double libraryVersion = Double.parseDouble(ctxt.getTagInfo()\n                        .getTagLibrary().getRequiredVersion());\n                if (libraryVersion < 2.0) {\n                    pageInfo.setIsELIgnored(\"true\", null, errDispatcher, true);\n                }\n                if (libraryVersion < 2.1) {\n                    pageInfo.setDeferredSyntaxAllowedAsLiteral(\"true\", null,\n                            errDispatcher, true);\n                }\n            } catch (NumberFormatException ex) {\n                errDispatcher.jspError(ex);\n            }\n        }\n\n        ctxt.checkOutputDir();\n        String javaFileName = ctxt.getServletJavaFileName();\n\n        ServletWriter writer = null;\n        try {\n            /*\n             * The setting of isELIgnored changes the behaviour of the parser\n             * in subtle ways. To add to the 'fun', isELIgnored can be set in\n             * any file that forms part of the translation unit so setting it\n             * in a file included towards the end of the translation unit can\n             * change how the parser should have behaved when parsing content\n             * up to the point where isELIgnored was set. Arghh!\n             * Previous attempts to hack around this have only provided partial\n             * solutions. We now use two passes to parse the translation unit.\n             * The first just parses the directives and the second parses the\n             * whole translation unit once we know how isELIgnored has been set.\n             * TODO There are some possible optimisations of this process.  \n             */ \n            // Parse the file\n            ParserController parserCtl = new ParserController(ctxt, this);\n            \n            // Pass 1 - the directives\n            Node.Nodes directives =\n                parserCtl.parseDirectives(ctxt.getJspFile());\n            Validator.validateDirectives(this, directives);\n            \n            // Pass 2 - the whole translation unit\n            pageNodes = parserCtl.parse(ctxt.getJspFile());\n\n            // Leave this until now since it can only be set once - bug 49726\n            if (pageInfo.getContentType() == null &&\n                    jspProperty.getDefaultContentType() != null) {\n                pageInfo.setContentType(jspProperty.getDefaultContentType());\n            }\n\n            if (ctxt.isPrototypeMode()) {\n                // generate prototype .java file for the tag file\n                writer = setupContextWriter(javaFileName);\n                Generator.generate(writer, this, pageNodes);\n                writer.close();\n                writer = null;\n                return null;\n            }\n\n            // Validate and process attributes - don't re-validate the\n            // directives we validated in pass 1\n            Validator.validateExDirectives(this, pageNodes);\n\n            if (log.isDebugEnabled()) {\n                t2 = System.currentTimeMillis();\n            }\n\n            // Collect page info\n            Collector.collect(this, pageNodes);\n\n            // Compile (if necessary) and load the tag files referenced in\n            // this compilation unit.\n            tfp = new TagFileProcessor();\n            tfp.loadTagFiles(this, pageNodes);\n\n            if (log.isDebugEnabled()) {\n                t3 = System.currentTimeMillis();\n            }\n\n            // Determine which custom tag needs to declare which scripting vars\n            ScriptingVariabler.set(pageNodes, errDispatcher);\n\n            // Optimizations by Tag Plugins\n            TagPluginManager tagPluginManager = options.getTagPluginManager();\n            tagPluginManager.apply(pageNodes, errDispatcher, pageInfo);\n\n            // Optimization: concatenate contiguous template texts.\n            TextOptimizer.concatenate(this, pageNodes);\n\n            // Generate static function mapper codes.\n            ELFunctionMapper.map(pageNodes);\n\n            // generate servlet .java file\n            writer = setupContextWriter(javaFileName);\n            Generator.generate(writer, this, pageNodes);\n            writer.close();\n            writer = null;\n\n            // The writer is only used during the compile, dereference\n            // it in the JspCompilationContext when done to allow it\n            // to be GC'd and save memory.\n            ctxt.setWriter(null);\n\n            if (log.isDebugEnabled()) {\n                t4 = System.currentTimeMillis();\n                log.debug(\"Generated \" + javaFileName + \" total=\" + (t4 - t1)\n                        + \" generate=\" + (t4 - t3) + \" validate=\" + (t2 - t1));\n            }\n\n        } catch (Exception e) {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (Exception e1) {\n                    // do nothing\n                }\n            }\n            // Remove the generated .java file\n            File file = new File(javaFileName);\n            if (file.exists()) {\n                if (!file.delete()) {\n                    log.warn(Localizer.getMessage(\n                            \"jsp.warning.compiler.javafile.delete.fail\",\n                            file.getAbsolutePath()));\n                }\n            }\n            throw e;\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                } catch (Exception e2) {\n                    // do nothing\n                }\n            }\n        }\n\n        // JSR45 Support\n        if (!options.isSmapSuppressed()) {\n            smapStr = SmapUtil.generateSmap(ctxt, pageNodes);\n        }\n\n        // If any proto type .java and .class files was generated,\n        // the prototype .java may have been replaced by the current\n        // compilation (if the tag file is self referencing), but the\n        // .class file need to be removed, to make sure that javac would\n        // generate .class again from the new .java file just generated.\n        tfp.removeProtoTypeFiles(ctxt.getClassFileName());\n\n        return smapStr;\n    }",
                "    public boolean isOutDated(boolean checkClass) {\n\n        if (jsw != null\n                && (ctxt.getOptions().getModificationTestInterval() > 0)) {\n\n            if (jsw.getLastModificationTest()\n                    + (ctxt.getOptions().getModificationTestInterval() * 1000) > System\n                    .currentTimeMillis()) {\n                return false;\n            }\n            jsw.setLastModificationTest(System.currentTimeMillis());\n        }\n\n        Long jspRealLastModified = ctxt.getLastModified(ctxt.getJspFile());\n        if (jspRealLastModified.longValue() < 0) {\n            // Something went wrong - assume modification\n            return true;\n        }\n\n        long targetLastModified = 0;\n        File targetFile;\n\n        if (checkClass) {\n            targetFile = new File(ctxt.getClassFileName());\n        } else {\n            targetFile = new File(ctxt.getServletJavaFileName());\n        }\n\n        if (!targetFile.exists()) {\n            return true;\n        }\n\n        targetLastModified = targetFile.lastModified();\n        if (checkClass && jsw != null) {\n            jsw.setServletClassLastModifiedTime(targetLastModified);\n        }\n        if (targetLastModified != jspRealLastModified.longValue()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Compiler: outdated: \" + targetFile + \" \"\n                        + targetLastModified);\n            }\n            return true;\n        }\n\n        // determine if source dependent files (e.g. includes using include\n        // directives) have been changed.\n        if (jsw == null) {\n            return false;\n        }\n\n        Map<String,Long> depends = jsw.getDependants();\n        if (depends == null) {\n            return false;\n        }\n\n        Iterator<Entry<String,Long>> it = depends.entrySet().iterator();\n        while (it.hasNext()) {\n            Entry<String,Long> include = it.next();\n            try {\n                String key = include.getKey();\n                URL includeUrl;\n                if (key.startsWith(\"jar:\") || key.startsWith(\"file:\")) {\n                    includeUrl = new URL(key);\n                } else {\n                    includeUrl = ctxt.getResource(include.getKey());\n                }\n                if (includeUrl == null) {\n                    return true;\n                }\n\n                URLConnection iuc = includeUrl.openConnection();\n                long includeLastModified = 0;\n                if (iuc instanceof JarURLConnection) {\n                    includeLastModified =\n                        ((JarURLConnection) iuc).getJarEntry().getTime();\n                } else {\n                    includeLastModified = iuc.getLastModified();\n                }\n                iuc.getInputStream().close();\n\n                if (includeLastModified != include.getValue().longValue()) {\n                    return true;\n                }\n            } catch (Exception e) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Problem accessing resource. Treat as outdated.\",\n                            e);\n                return true;\n            }\n        }\n\n        return false;\n\n    }",
                "    public void removeGeneratedFiles() {\n        removeGeneratedClassFiles();\n\n        try {\n            String javaFileName = ctxt.getServletJavaFileName();\n            if (javaFileName != null) {\n                File javaFile = new File(javaFileName);\n                if (log.isDebugEnabled())\n                    log.debug(\"Deleting \" + javaFile);\n                if (javaFile.exists()) {\n                    if (!javaFile.delete()) {\n                        log.warn(Localizer.getMessage(\n                                \"jsp.warning.compiler.javafile.delete.fail\",\n                                javaFile.getAbsolutePath()));\n                    }\n                }\n            }\n        } catch (Exception e) {\n            // Remove as much as possible, log possible exceptions\n            log.warn(Localizer.getMessage(\"jsp.warning.compiler.classfile.delete.fail.unknown\"),\n                     e);\n        }\n    }",
                "    public void removeGeneratedClassFiles() {\n        try {\n            String classFileName = ctxt.getClassFileName();\n            if (classFileName != null) {\n                File classFile = new File(classFileName);\n                if (log.isDebugEnabled())\n                    log.debug(\"Deleting \" + classFile);\n                if (classFile.exists()) {\n                    if (!classFile.delete()) {\n                        log.warn(Localizer.getMessage(\n                                \"jsp.warning.compiler.classfile.delete.fail\",\n                                classFile.getAbsolutePath()));\n                    }\n                }\n            }\n        } catch (Exception e) {\n            // Remove as much as possible, log possible exceptions\n            log.warn(Localizer.getMessage(\"jsp.warning.compiler.classfile.delete.fail.unknown\"),\n                     e);\n        }\n    }"
            ],
            "test\\org\\apache\\catalina\\startup\\TestTomcat.java": [
                "    public void testProgrammatic() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        org.apache.catalina.Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n        // You can customize the context by calling\n        // its API\n\n        Tomcat.addServlet(ctx, \"myServlet\", new HelloWorld());\n        ctx.addServletMapping(\"/\", \"myServlet\");\n\n        tomcat.start();\n\n        ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/\");\n        assertEquals(\"Hello world\", res.toString());\n    }\n\n    public void testSingleWebapp() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        File appDir = new File(getBuildDirectory(), \"webapps/examples\");\n        // app dir is relative to server home\n        tomcat.addWebapp(null, \"/examples\", appDir.getAbsolutePath());\n\n        tomcat.start();\n\n        ByteChunk res = getUrl(\"http://localhost:\" + getPort() +\n                \"/examples/servlets/servlet/HelloWorldExample\");\n        assertTrue(res.toString().indexOf(\"<h1>Hello World!</h1>\") > 0);\n    }",
                "    public void testJsps() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        File appDir = new File(getBuildDirectory(), \"webapps/examples\");\n        // app dir is relative to server home\n        tomcat.addWebapp(null, \"/examples\", appDir.getAbsolutePath());\n\n        tomcat.start();\n\n        ByteChunk res = getUrl(\"http://localhost:\" + getPort() +\n                \"/examples/jsp/jsp2/el/basic-arithmetic.jsp\");\n        assertTrue(res.toString().indexOf(\"<td>${(1==2) ? 3 : 4}</td>\") > 0);\n    }\n\n    public void testSession() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        org.apache.catalina.Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n        // You can customize the context by calling\n        // its API\n\n        Tomcat.addServlet(ctx, \"myServlet\", new HelloWorldSession());\n        ctx.addServletMapping(\"/\", \"myServlet\");\n\n        tomcat.start();\n\n        ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/\");\n        assertEquals(\"Hello world\", res.toString());\n    }\n\n    public void testLaunchTime() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n        long t0 = System.currentTimeMillis();\n        tomcat.addContext(null, \"/\", \".\");\n        tomcat.start();\n        System.err.println(\"Test time: \" +\n                (System.currentTimeMillis() - t0));\n     }",
                "    public void testEnableNaming() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        org.apache.catalina.Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        // You can customise the context by calling its API\n\n        // Enable JNDI - it is disabled by default\n        tomcat.enableNaming();\n\n        ContextEnvironment environment = new ContextEnvironment();\n        environment.setType(\"java.lang.String\");\n        environment.setName(HelloWorldJndi.JNDI_ENV_NAME);\n        environment.setValue(\"Tomcat User\");\n        ctx.getNamingResources().addEnvironment(environment);\n\n        Tomcat.addServlet(ctx, \"jndiServlet\", new HelloWorldJndi());\n        ctx.addServletMapping(\"/\", \"jndiServlet\");\n\n        tomcat.start();\n\n        ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/\");\n        assertEquals(\"Hello, Tomcat User\", res.toString());\n    }",
                "    public void testEnableNamingGlobal() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        org.apache.catalina.Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        // You can customise the context by calling its API\n\n        // Enable JNDI - it is disabled by default\n        tomcat.enableNaming();\n\n        ContextEnvironment environment = new ContextEnvironment();\n        environment.setType(\"java.lang.String\");\n        environment.setName(\"globalTest\");\n        environment.setValue(\"Tomcat User\");\n        tomcat.getServer().getGlobalNamingResources().addEnvironment(environment);\n\n        ContextResourceLink link = new ContextResourceLink();\n        link.setGlobal(\"globalTest\");\n        link.setName(HelloWorldJndi.JNDI_ENV_NAME);\n        ctx.getNamingResources().addResourceLink(link);\n\n        Tomcat.addServlet(ctx, \"jndiServlet\", new HelloWorldJndi());\n        ctx.addServletMapping(\"/\", \"jndiServlet\");\n\n        tomcat.start();\n\n        ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/\");\n        assertEquals(\"Hello, Tomcat User\", res.toString());\n    }",
                "    public void testGetResource() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        String contextPath = \"/examples\";\n\n        File appDir = new File(getBuildDirectory(), \"webapps\" + contextPath);\n        // app dir is relative to server home\n        org.apache.catalina.Context ctx =\n            tomcat.addWebapp(null, \"/examples\", appDir.getAbsolutePath());\n\n        Tomcat.addServlet(ctx, \"testGetResource\", new GetResource());\n        ctx.addServletMapping(\"/testGetResource\", \"testGetResource\");\n\n        tomcat.start();\n\n        ByteChunk res = new ByteChunk();\n\n        int rc =getUrl(\"http://localhost:\" + getPort() + contextPath +\n                \"/testGetResource\", res, null);\n        assertEquals(HttpServletResponse.SC_OK, rc);\n        assertTrue(res.toString().contains(\"<?xml version=\\\"1.0\\\" \"));\n    }\n\n    public void testBug50826() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n        String contextPath = \"/examples\";\n\n        File appDir = new File(getBuildDirectory(), \"webapps\" + contextPath);\n        // app dir is relative to server home\n        tomcat.addWebapp(null, \"/examples\", appDir.getAbsolutePath());\n\n        Exception e = null;\n        try {\n            tomcat.destroy();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            e = ex;\n        }\n        assertNull(e);\n    }",
                "    public void testBug53301() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        org.apache.catalina.Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        InitCount initCount = new InitCount();\n        Tomcat.addServlet(ctx, \"initCount\", initCount);\n        ctx.addServletMapping(\"/\", \"initCount\");\n\n        tomcat.start();\n\n        ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/\");\n        assertEquals(\"OK\", res.toString());\n\n        assertEquals(1, initCount.getCallCount());\n    }\n\n    public void testBug51526() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        File appFile = new File(\"test/deployment/context.war\");\n        StandardContext context = (StandardContext) tomcat.addWebapp(null, \"/test\",\n                appFile.getAbsolutePath());\n\n        tomcat.start();\n\n        assertEquals(\"WAR_CONTEXT\", context.getSessionCookieName());\n    }"
            ],
            "java\\org\\apache\\catalina\\core\\ApplicationContextFacade.java": [
                "    private void initClassCache(){\n        Class<?>[] clazz = new Class[]{String.class};\n        classCache.put(\"getContext\", clazz);\n        classCache.put(\"getMimeType\", clazz);\n        classCache.put(\"getResourcePaths\", clazz);\n        classCache.put(\"getResource\", clazz);\n        classCache.put(\"getResourceAsStream\", clazz);\n        classCache.put(\"getRequestDispatcher\", clazz);\n        classCache.put(\"getNamedDispatcher\", clazz);\n        classCache.put(\"getServlet\", clazz);\n        classCache.put(\"setInitParameter\", new Class[]{String.class, String.class});\n        classCache.put(\"createServlet\", new Class[]{Class.class});\n        classCache.put(\"addServlet\", new Class[]{String.class, String.class});\n        classCache.put(\"createFilter\", new Class[]{Class.class});\n        classCache.put(\"addFilter\", new Class[]{String.class, String.class});\n        classCache.put(\"createListener\", new Class[]{Class.class});\n        classCache.put(\"addListener\", clazz);\n        classCache.put(\"getFilterRegistration\", clazz);\n        classCache.put(\"getServletRegistration\", clazz);\n        classCache.put(\"getInitParameter\", clazz);\n        classCache.put(\"setAttribute\", new Class[]{String.class, Object.class});\n        classCache.put(\"removeAttribute\", clazz);\n        classCache.put(\"getRealPath\", clazz);\n        classCache.put(\"getAttribute\", clazz);\n        classCache.put(\"log\", clazz);\n        classCache.put(\"setSessionTrackingModes\", new Class[]{Set.class} );\n    }\n\n    public void log(String msg) {\n        if (SecurityUtil.isPackageProtectionEnabled()) {\n            doPrivileged(\"log\", new Object[]{msg} );\n        } else {\n            context.log(msg);\n        }\n    }",
                "    public void log(Exception exception, String msg) {\n        if (SecurityUtil.isPackageProtectionEnabled()) {\n            doPrivileged(\"log\", new Class[]{Exception.class, String.class}, \n                         new Object[]{exception,msg});\n        } else {\n            context.log(exception, msg);\n        }\n    }\n\n    public void log(String message, Throwable throwable) {\n        if (SecurityUtil.isPackageProtectionEnabled()) {\n            doPrivileged(\"log\", new Class[]{String.class, Throwable.class}, \n                         new Object[]{message, throwable});\n        } else {\n            context.log(message, throwable);\n        }\n    }\n\n    public void removeAttribute(String name) {\n        if (SecurityUtil.isPackageProtectionEnabled()) {\n            doPrivileged(\"removeAttribute\", new Object[]{name});\n        } else {\n            context.removeAttribute(name);\n        }\n    }",
                "    public void addListener(Class<? extends EventListener> listenerClass) {\n        if (SecurityUtil.isPackageProtectionEnabled()) {\n            doPrivileged(\"addListener\",\n                    new Class[]{Class.class},\n                    new Object[]{listenerClass});\n        } else {\n            context.addListener(listenerClass);\n        }\n    }\n\n    public void addListener(String className) {\n        if (SecurityUtil.isPackageProtectionEnabled()) {\n            doPrivileged(\"addListener\",\n                    new Object[]{className});\n        } else {\n            context.addListener(className);\n        }\n    }\n\n    public <T extends EventListener> void addListener(T t) {\n        if (SecurityUtil.isPackageProtectionEnabled()) {\n            doPrivileged(\"addListener\",\n                    new Class[]{EventListener.class},\n                    new Object[]{t});\n        } else {\n            context.addListener(t);\n        }\n    }",
                "    public void declareRoles(String... roleNames) {\n        if (SecurityUtil.isPackageProtectionEnabled()) {\n            doPrivileged(\"declareRoles\", new Object[]{roleNames});\n        } else {\n            context.declareRoles(roleNames);\n        }\n    }\n\n    private Object doPrivileged(final String methodName, final Object[] params) {\n        try{\n            return invokeMethod(context, methodName, params);\n        }catch(Throwable t){\n            ExceptionUtils.handleThrowable(t);\n            throw new RuntimeException(t.getMessage(), t);\n        }\n    }"
            ],
            "java\\org\\apache\\naming\\resources\\Resource.java": [
                "    public InputStream streamContent() throws IOException {\n        if (binaryContent != null) {\n            return new ByteArrayInputStream(binaryContent);\n        }\n        return inputStream;\n    }"
            ],
            "java\\org\\apache\\catalina\\core\\ApplicationContext.java": [
                "    public void log(String message) {\n\n        context.getLogger().info(message);\n\n    }\n\n    public void log(Exception exception, String message) {\n\n        context.getLogger().error(message, exception);\n\n    }\n\n    public void log(String message, Throwable throwable) {\n\n        context.getLogger().error(message, throwable);\n\n    }",
                "    public void removeAttribute(String name) {\n\n        Object value = null;\n\n        // Remove the specified attribute\n        // Check for read only attribute\n        if (readOnlyAttributes.containsKey(name)){\n            return;\n        }\n        value = attributes.remove(name);\n        if (value == null) {\n            return;\n        }\n\n        // Notify interested application event listeners\n        Object listeners[] = context.getApplicationEventListeners();\n        if ((listeners == null) || (listeners.length == 0))\n            return;\n        ServletContextAttributeEvent event =\n          new ServletContextAttributeEvent(context.getServletContext(),\n                                            name, value);\n        for (int i = 0; i < listeners.length; i++) {\n            if (!(listeners[i] instanceof ServletContextAttributeListener))\n                continue;\n            ServletContextAttributeListener listener =\n                (ServletContextAttributeListener) listeners[i];\n            try {\n                context.fireContainerEvent(\"beforeContextAttributeRemoved\",\n                                           listener);\n                listener.attributeRemoved(event);\n                context.fireContainerEvent(\"afterContextAttributeRemoved\",\n                                           listener);\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                context.fireContainerEvent(\"afterContextAttributeRemoved\",\n                                           listener);\n                // FIXME - should we do anything besides log these?\n                log(sm.getString(\"applicationContext.attributeEvent\"), t);\n            }\n        }\n\n    }",
                "    private void populateSessionTrackingModes() {\n        // URL re-writing is always enabled by default\n        defaultSessionTrackingModes = EnumSet.of(SessionTrackingMode.URL);\n        supportedSessionTrackingModes = EnumSet.of(SessionTrackingMode.URL);\n\n        if (context.getCookies()) {\n            defaultSessionTrackingModes.add(SessionTrackingMode.COOKIE);\n            supportedSessionTrackingModes.add(SessionTrackingMode.COOKIE);\n        }\n\n        // SSL not enabled by default as it can only used on its own\n        // Context > Host > Engine > Service\n        Service s = ((Engine) context.getParent().getParent()).getService();\n        Connector[] connectors = s.findConnectors();\n        // Need at least one SSL enabled connector to use the SSL session ID.\n        for (Connector connector : connectors) {\n            if (Boolean.TRUE.equals(connector.getAttribute(\"SSLEnabled\"))) {\n                supportedSessionTrackingModes.add(SessionTrackingMode.SSL);\n                break;\n            }\n        }\n    }\n\n    public void addListener(Class<? extends EventListener> listenerClass) {\n        EventListener listener;\n        try {\n            listener = createListener(listenerClass);\n        } catch (ServletException e) {\n            throw new IllegalArgumentException(sm.getString(\n                    \"applicationContext.addListener.iae.init\",\n                    listenerClass.getName()), e);\n        }\n        addListener(listener);\n    }",
                "    public void addListener(String className) {\n\n        try {\n            Object obj = context.getInstanceManager().newInstance(className);\n\n            if (!(obj instanceof EventListener)) {\n                throw new IllegalArgumentException(sm.getString(\n                        \"applicationContext.addListener.iae.wrongType\",\n                        className));\n            }\n\n            EventListener listener = (EventListener) obj;\n            addListener(listener);\n        } catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(sm.getString(\n                    \"applicationContext.addListener.iae.cnfe\", className),\n                    e);\n        } catch (InvocationTargetException e) {\n            ExceptionUtils.handleThrowable(e.getCause());\n            throw new IllegalArgumentException(sm.getString(\n                    \"applicationContext.addListener.iae.cnfe\", className),\n                    e);\n        } catch (NamingException e) {\n            throw new IllegalArgumentException(sm.getString(\n                    \"applicationContext.addListener.iae.cnfe\", className),\n                    e);\n        } catch (InstantiationException e) {\n            throw new IllegalArgumentException(sm.getString(\n                    \"applicationContext.addListener.iae.cnfe\", className),\n                    e);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalArgumentException(sm.getString(\n                    \"applicationContext.addListener.iae.cnfe\", className),\n                    e);\n        }\n\n    }",
                "    public <T extends EventListener> void addListener(T t) {\n        if (!context.getState().equals(LifecycleState.STARTING_PREP)) {\n            throw new IllegalStateException(\n                    sm.getString(\"applicationContext.addListener.ise\",\n                            getContextPath()));\n        }\n\n        boolean match = false;\n        if (t instanceof ServletContextAttributeListener ||\n                t instanceof ServletRequestListener ||\n                t instanceof ServletRequestAttributeListener ||\n                t instanceof HttpSessionAttributeListener) {\n            context.addApplicationEventListener(t);\n            match = true;\n        }\n\n        if (t instanceof HttpSessionListener\n                || (t instanceof ServletContextListener &&\n                        newServletContextListenerAllowed)) {\n            // Add listener directly to the list of instances rather than to\n            // the list of class names.\n            context.addApplicationLifecycleListener(t);\n            match = true;\n        }\n\n        if (match) return;\n\n        if (t instanceof ServletContextListener) {\n            throw new IllegalArgumentException(sm.getString(\n                    \"applicationContext.addListener.iae.sclNotAllowed\",\n                    t.getClass().getName()));\n        } else {\n            throw new IllegalArgumentException(sm.getString(\n                    \"applicationContext.addListener.iae.wrongType\",\n                    t.getClass().getName()));\n        }\n    }",
                "    public void declareRoles(String... roleNames) {\n\n        if (!context.getState().equals(LifecycleState.STARTING_PREP)) {\n            //TODO Spec breaking enhancement to ignore this restriction\n            throw new IllegalStateException(\n                    sm.getString(\"applicationContext.addRole.ise\",\n                            getContextPath()));\n        }\n\n        if (roleNames == null) {\n            throw new IllegalArgumentException(\n                    sm.getString(\"applicationContext.roles.iae\",\n                            getContextPath()));\n        }\n\n        for (String role : roleNames) {\n            if (role == null || \"\".equals(role)) {\n                throw new IllegalArgumentException(\n                        sm.getString(\"applicationContext.role.iae\",\n                                getContextPath()));\n            }\n            context.addSecurityRole(role);\n        }\n    }"
            ],
            "java\\org\\apache\\naming\\resources\\DirContextURLConnection.java": [
                "    public void connect() throws IOException {\n\n        if (!connected) {\n\n            try {\n                date = System.currentTimeMillis();\n                path = URL_DECODER.convert(getURL().getFile(), false);\n                if (context instanceof ProxyDirContext) {\n                    ProxyDirContext proxyDirContext =\n                        (ProxyDirContext) context;\n                    String hostName = proxyDirContext.getHostName();\n                    String contextPath = proxyDirContext.getContextPath();\n                    if (hostName != null) {\n                        if (!path.startsWith(\"/\" + hostName + \"/\"))\n                            return;\n                        path = path.substring(hostName.length()+ 1);\n                    }\n                    if (contextPath != null) {\n                        if (!path.startsWith(contextPath + \"/\")) {\n                            return;\n                        }\n                        path = path.substring(contextPath.length());\n                    }\n                }\n                object = context.lookup(path);\n                attributes = context.getAttributes(path);\n                if (object instanceof Resource)\n                    resource = (Resource) object;\n                if (object instanceof DirContext)\n                    collection = (DirContext) object;\n            } catch (NamingException e) {\n                // Object not found\n            }\n\n            connected = true;\n        }\n    }"
            ]
        }
    },
    "55893": {
        "summary": "Bug 55893 Split AccessLogValve and extract the formatting logic in an AbstractAccessLogValve",
        "code_segments": {
            "test\\org\\apache\\catalina\\valves\\TesterAccessLogValve.java": [
                "    public void invoke(Request request, Response response) throws IOException,"
            ],
            "java\\org\\apache\\catalina\\valves\\AccessLogValve.java": [
                "    public synchronized void backgroundProcess() {\n        if (getState().isAvailable() && getEnabled() && writer != null &&\n                buffered) {\n            writer.flush();\n        }\n    }\n\n    public void invoke(Request request, Response response) throws IOException,\n\n    public void log(Request request, Response response, long time) {\n        if (!getState().isAvailable() || !getEnabled() || logElements == null\n                || condition != null\n                && null != request.getRequest().getAttribute(condition)\n                || conditionIf != null\n                && null == request.getRequest().getAttribute(conditionIf)) {\n            return;\n        }\n\n        /**\n         * XXX This is a bit silly, but we want to have start and stop time and\n         * duration consistent. It would be better to keep start and stop\n         * simply in the request and/or response object and remove time\n         * (duration) from the interface.\n         */\n        long start = request.getCoyoteRequest().getStartTime();\n        Date date = getDate(start + time);\n\n        StringBuilder result = new StringBuilder(128);\n\n        for (int i = 0; i < logElements.length; i++) {\n            logElements[i].addElement(result, date, request, response, time);\n        }\n\n        log(result.toString());\n    }",
                "    public void rotate() {\n        if (rotatable) {\n            // Only do a logfile switch check once a second, max.\n            long systime = System.currentTimeMillis();\n            if ((systime - rotationLastChecked) > 1000) {\n                synchronized(this) {\n                    if ((systime - rotationLastChecked) > 1000) {\n                        rotationLastChecked = systime;\n\n                        String tsDate;\n                        // Check for a change of date\n                        tsDate = fileDateFormatter.format(new Date(systime));\n\n                        // If the date has changed, switch log files\n                        if (!dateStamp.equals(tsDate)) {\n                            close(true);\n                            dateStamp = tsDate;\n                            open();\n                        }\n                    }\n                }\n            }\n        }\n    }",
                "    public synchronized boolean rotate(String newFileName) {\n\n        if (currentLogFile != null) {\n            File holder = currentLogFile;\n            close(false);\n            try {\n                holder.renameTo(new File(newFileName));\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                log.error(sm.getString(\"accessLogValve.rotateFail\"), e);\n            }\n\n            /* Make sure date is correct */\n            dateStamp = fileDateFormatter.format(\n                    new Date(System.currentTimeMillis()));\n\n            open();\n            return true;\n        } else {\n            return false;\n        }\n\n    }\n\n    private void restore() {\n        File newLogFile = getLogFile(false);\n        File rotatedLogFile = getLogFile(true);\n        if (rotatedLogFile.exists() && !newLogFile.exists() &&\n            !rotatedLogFile.equals(newLogFile)) {\n            try {\n                if (!rotatedLogFile.renameTo(newLogFile)) {\n                    log.error(sm.getString(\"accessLogValve.renameFail\", rotatedLogFile, newLogFile));\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                log.error(sm.getString(\"accessLogValve.renameFail\", rotatedLogFile, newLogFile), e);\n            }\n        }\n    }",
                "    private synchronized void close(boolean rename) {\n        if (writer == null) {\n            return;\n        }\n        writer.flush();\n        writer.close();\n        if (rename && renameOnRotate) {\n            File newLogFile = getLogFile(true);\n            if (!newLogFile.exists()) {\n                try {\n                    if (!currentLogFile.renameTo(newLogFile)) {\n                        log.error(sm.getString(\"accessLogValve.renameFail\", currentLogFile, newLogFile));\n                    }\n                } catch (Throwable e) {\n                    ExceptionUtils.handleThrowable(e);\n                    log.error(sm.getString(\"accessLogValve.renameFail\", currentLogFile, newLogFile), e);\n                }\n            } else {\n                log.error(sm.getString(\"accessLogValve.alreadyExists\", currentLogFile, newLogFile));\n            }\n        }\n        writer = null;\n        dateStamp = \"\";\n        currentLogFile = null;\n    }",
                "    public void log(String message) {\n\n        rotate();\n\n        /* In case something external rotated the file instead */\n        if (checkExists) {\n            synchronized (this) {\n                if (currentLogFile != null && !currentLogFile.exists()) {\n                    try {\n                        close(false);\n                    } catch (Throwable e) {\n                        ExceptionUtils.handleThrowable(e);\n                        log.info(sm.getString(\"accessLogValve.closeFail\"), e);\n                    }\n\n                    /* Make sure date is correct */\n                    dateStamp = fileDateFormatter.format(\n                            new Date(System.currentTimeMillis()));\n\n                    open();\n                }\n            }\n        }\n\n        // Log this message\n        synchronized(this) {\n            if (writer != null) {\n                writer.println(message);\n                if (!buffered) {\n                    writer.flush();\n                }\n            }\n        }\n\n    }",
                "    protected synchronized void open() {\n        // Open the current log file\n        // If no rotate - no need for dateStamp in fileName\n        File pathname = getLogFile(rotatable && !renameOnRotate);\n\n        Charset charset = null;\n        if (encoding != null) {\n            try {\n                charset = B2CConverter.getCharset(encoding);\n            } catch (UnsupportedEncodingException ex) {\n                log.error(sm.getString(\n                        \"accessLogValve.unsupportedEncoding\", encoding), ex);\n            }\n        }\n        if (charset == null) {\n            charset = Charset.defaultCharset();\n        }\n\n        try {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(\n                    new FileOutputStream(pathname, true), charset), 128000),\n                    false);\n\n            currentLogFile = pathname;\n        } catch (IOException e) {\n            writer = null;\n            currentLogFile = null;\n            log.error(sm.getString(\"accessLogValve.openFail\", pathname), e);\n        }\n    }",
                "    protected static Locale findLocale(String name, Locale fallback) {\n        if (name == null || name.isEmpty()) {\n            return Locale.getDefault();\n        } else {\n            for (Locale l: Locale.getAvailableLocales()) {\n                if (name.equals(l.toString())) {\n                    return(l);\n                }\n            }\n        }\n        log.error(sm.getString(\"accessLogValve.invalidLocale\", name));\n        return fallback;\n    }\n\n    protected synchronized void startInternal() throws LifecycleException {\n\n        // Initialize the Date formatters\n        String format = getFileDateFormat();\n        fileDateFormatter = new SimpleDateFormat(format, Locale.US);\n        fileDateFormatter.setTimeZone(TimeZone.getDefault());\n        dateStamp = fileDateFormatter.format(new Date(System.currentTimeMillis()));\n        if (rotatable && renameOnRotate) {\n            restore();\n        }\n        open();\n\n        setState(LifecycleState.STARTING);\n    }\n\n    protected synchronized void stopInternal() throws LifecycleException {\n\n        setState(LifecycleState.STOPPING);\n        close(false);\n    }",
                "    protected AccessLogElement[] createLogElements() {\n        List<AccessLogElement> list = new ArrayList<AccessLogElement>();\n        boolean replace = false;\n        StringBuilder buf = new StringBuilder();\n        for (int i = 0; i < pattern.length(); i++) {\n            char ch = pattern.charAt(i);\n            if (replace) {\n                /*\n                 * For code that processes {, the behavior will be ... if I do\n                 * not encounter a closing } - then I ignore the {\n                 */\n                if ('{' == ch) {\n                    StringBuilder name = new StringBuilder();\n                    int j = i + 1;\n                    for (; j < pattern.length() && '}' != pattern.charAt(j); j++) {\n                        name.append(pattern.charAt(j));\n                    }\n                    if (j + 1 < pattern.length()) {\n                        /* the +1 was to account for } which we increment now */\n                        j++;\n                        list.add(createAccessLogElement(name.toString(),\n                                pattern.charAt(j)));\n                        i = j; /* Since we walked more than one character */\n                    } else {\n                        // D'oh - end of string - pretend we never did this\n                        // and do processing the \"old way\"\n                        list.add(createAccessLogElement(ch));\n                    }\n                } else {\n                    list.add(createAccessLogElement(ch));\n                }\n                replace = false;\n            } else if (ch == '%') {\n                replace = true;\n                list.add(new StringElement(buf.toString()));\n                buf = new StringBuilder();\n            } else {\n                buf.append(ch);\n            }\n        }\n        if (buf.length() > 0) {\n            list.add(new StringElement(buf.toString()));\n        }\n        return list.toArray(new AccessLogElement[0]);\n    }",
                "    protected AccessLogElement createAccessLogElement(String header, char pattern) {\n        switch (pattern) {\n        case 'i':\n            return new HeaderElement(header);\n        case 'c':\n            return new CookieElement(header);\n        case 'o':\n            return new ResponseHeaderElement(header);\n        case 'r':\n            return new RequestAttributeElement(header);\n        case 's':\n            return new SessionAttributeElement(header);\n        case 't':\n            return new DateAndTimeElement(header);\n        default:\n            return new StringElement(\"???\");\n        }\n    }",
                "    protected AccessLogElement createAccessLogElement(char pattern) {\n        switch (pattern) {\n        case 'a':\n            return new RemoteAddrElement();\n        case 'A':\n            return new LocalAddrElement();\n        case 'b':\n            return new ByteSentElement(true);\n        case 'B':\n            return new ByteSentElement(false);\n        case 'D':\n            return new ElapsedTimeElement(true);\n        case 'F':\n            return new FirstByteTimeElement();\n        case 'h':\n            return new HostElement();\n        case 'H':\n            return new ProtocolElement();\n        case 'l':\n            return new LogicalUserNameElement();\n        case 'm':\n            return new MethodElement();\n        case 'p':\n            return new LocalPortElement();\n        case 'q':\n            return new QueryElement();\n        case 'r':\n            return new RequestElement();\n        case 's':\n            return new HttpStatusCodeElement();\n        case 'S':\n            return new SessionIdElement();\n        case 't':\n            return new DateAndTimeElement();\n        case 'T':\n            return new ElapsedTimeElement(false);\n        case 'u':\n            return new UserElement();\n        case 'U':\n            return new RequestURIElement();\n        case 'v':\n            return new LocalServerNameElement();\n        case 'I':\n            return new ThreadNameElement();\n        default:\n            return new StringElement(\"???\" + pattern + \"???\");\n        }\n    }"
            ],
            "java\\org\\apache\\catalina\\valves\\ExtendedAccessLogValve.java": [
                "    private String wrap(Object value) {\n        String svalue;\n        // Does the value contain a \" ? If so must encode it\n        if (value == null || \"-\".equals(value)) {\n            return \"-\";\n        }\n\n        try {\n            svalue = value.toString();\n            if (\"\".equals(svalue)) {\n                return \"-\";\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            /* Log error */\n            return \"-\";\n        }\n\n        /* Wrap all quotes in double quotes. */\n        StringBuilder buffer = new StringBuilder(svalue.length() + 2);\n        buffer.append('\\'');\n        int i = 0;\n        while (i < svalue.length()) {\n            int j = svalue.indexOf('\\'', i);\n            if (j == -1) {\n                buffer.append(svalue.substring(i));\n                i = svalue.length();\n            } else {\n                buffer.append(svalue.substring(i, j + 1));\n                buffer.append('\"');\n                i = j + 2;\n            }\n        }\n\n        buffer.append('\\'');\n        return buffer.toString();\n    }",
                "    protected synchronized void open() {\n        super.open();\n        if (currentLogFile.length()==0) {\n            writer.println(\"#Fields: \" + pattern);\n            writer.println(\"#Version: 2.0\");\n            writer.println(\"#Software: \" + ServerInfo.getServerInfo());\n        }\n    }",
                "    protected AccessLogElement[] createLogElements() {\n        if (log.isDebugEnabled()) {\n            log.debug(\"decodePattern, pattern =\" + pattern);\n        }\n        List<AccessLogElement> list = new ArrayList<AccessLogElement>();\n\n        PatternTokenizer tokenizer = new PatternTokenizer(pattern);\n        try {\n\n            // Ignore leading whitespace.\n            tokenizer.getWhiteSpaces();\n\n            if (tokenizer.isEnded()) {\n                log.info(\"pattern was just empty or whitespace\");\n                return null;\n            }\n\n            String token = tokenizer.getToken();\n            while (token != null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"token = \" + token);\n                }\n                AccessLogElement element = getLogElement(token, tokenizer);\n                if (element == null) {\n                    break;\n                }\n                list.add(element);\n                String whiteSpaces = tokenizer.getWhiteSpaces();\n                if (whiteSpaces.length() > 0) {\n                    list.add(new StringElement(whiteSpaces));\n                }\n                if (tokenizer.isEnded()) {\n                    break;\n                }\n                token = tokenizer.getToken();\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"finished decoding with element size of: \" + list.size());\n            }\n            return list.toArray(new AccessLogElement[0]);\n        } catch (IOException e) {\n            log.error(\"parse error\", e);\n            return null;\n        }\n    }"
            ],
            "java\\org\\apache\\catalina\\valves\\JDBCAccessLogValve.java": [
                "    public void invoke(Request request, Response response) throws IOException,",
                "    public void log(Request request, Response response, long time) {\n        if (!getState().isAvailable()) {\n            return;\n        }\n\n        final String EMPTY = \"\" ;\n\n        String remoteHost;\n        if(resolveHosts) {\n            if (requestAttributesEnabled) {\n                Object host = request.getAttribute(REMOTE_HOST_ATTRIBUTE);\n                if (host == null) {\n                    remoteHost = request.getRemoteHost();\n                } else {\n                    remoteHost = (String) host;\n                }\n            } else {\n                remoteHost = request.getRemoteHost();\n            }\n        } else {\n            if (requestAttributesEnabled) {\n                Object addr = request.getAttribute(REMOTE_ADDR_ATTRIBUTE);\n                if (addr == null) {\n                    remoteHost = request.getRemoteAddr();\n                } else {\n                    remoteHost = (String) addr;\n                }\n            } else {\n                remoteHost = request.getRemoteAddr();\n            }\n        }\n        String user = request.getRemoteUser();\n        String query=request.getRequestURI();\n\n        long bytes = response.getBytesWritten(true);\n        if(bytes < 0) {\n            bytes = 0;\n        }\n        int status = response.getStatus();\n        String virtualHost = EMPTY;\n        String method = EMPTY;\n        String referer = EMPTY;\n        String userAgent = EMPTY;\n        String logPattern = pattern;\n        if (logPattern.equals(\"combined\")) {\n            virtualHost = request.getServerName();\n            method = request.getMethod();\n            referer = request.getHeader(\"referer\");\n            userAgent = request.getHeader(\"user-agent\");\n        }\n        synchronized (this) {\n          int numberOfTries = 2;\n          while (numberOfTries>0) {\n            try {\n                open();\n\n                ps.setString(1, remoteHost);\n                ps.setString(2, user);\n                ps.setTimestamp(3, new Timestamp(getCurrentTimeMillis()));\n                ps.setString(4, query);\n                ps.setInt(5, status);\n\n                if(useLongContentLength) {\n                    ps.setLong(6, bytes);\n                } else {\n                    if (bytes > Integer.MAX_VALUE) {\n                        bytes = -1 ;\n                    }\n                    ps.setInt(6, (int) bytes);\n                }\n                if (logPattern.equals(\"combined\")) {\n                      ps.setString(7, virtualHost);\n                      ps.setString(8, method);\n                      ps.setString(9, referer);\n                      ps.setString(10, userAgent);\n                }\n                ps.executeUpdate();\n                return;\n              } catch (SQLException e) {\n                // Log the problem for posterity\n                  container.getLogger().error(sm.getString(\"jdbcAccessLogValve.exception\"), e);\n\n                // Close the connection so that it gets reopened next time\n                if (conn != null) {\n                    close();\n                }\n              }\n              numberOfTries--;\n           }\n        }\n\n    }",
                "    protected void open() throws SQLException {\n\n        // Do nothing if there is a database connection already open\n        if (conn != null) {\n            return ;\n        }\n\n        // Instantiate our database driver if necessary\n        if (driver == null) {\n            try {\n                Class<?> clazz = Class.forName(driverName);\n                driver = (Driver) clazz.newInstance();\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                throw new SQLException(e.getMessage(), e);\n            }\n        }\n\n        // Open a new connection\n        Properties props = new Properties();\n        props.put(\"autoReconnect\", \"true\");\n        if (connectionName != null) {\n            props.put(\"user\", connectionName);\n        }\n        if (connectionPassword != null) {\n            props.put(\"password\", connectionPassword);\n        }\n        conn = driver.connect(connectionURL, props);\n        conn.setAutoCommit(true);\n        String logPattern = pattern;\n        if (logPattern.equals(\"common\")) {\n                ps = conn.prepareStatement\n                    (\"INSERT INTO \" + tableName + \" (\"\n                     + remoteHostField + \", \" + userField + \", \"\n                     + timestampField +\", \" + queryField + \", \"\n                     + statusField + \", \" + bytesField\n                     + \") VALUES(?, ?, ?, ?, ?, ?)\");\n        } else if (logPattern.equals(\"combined\")) {\n                ps = conn.prepareStatement\n                    (\"INSERT INTO \" + tableName + \" (\"\n                     + remoteHostField + \", \" + userField + \", \"\n                     + timestampField + \", \" + queryField + \", \"\n                     + statusField + \", \" + bytesField + \", \"\n                     + virtualHostField + \", \" + methodField + \", \"\n                     + refererField + \", \" + userAgentField\n                     + \") VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\");\n        }\n    }",
                "    protected void close() {\n\n        // Do nothing if the database connection is already closed\n        if (conn == null) {\n            return;\n        }\n\n        // Close our prepared statements (if any)\n        try {\n            ps.close();\n        } catch (Throwable f) {\n            ExceptionUtils.handleThrowable(f);\n        }\n        this.ps = null;\n\n\n\n        // Close this database connection, and log any errors\n        try {\n            conn.close();\n        } catch (SQLException e) {\n            container.getLogger().error(sm.getString(\"jdbcAccessLogValeve.close\"), e); // Just log it here\n        } finally {\n           this.conn = null;\n        }\n\n    }\n\n    protected synchronized void startInternal() throws LifecycleException {\n\n        try {\n            open() ;\n        } catch (SQLException e) {\n            throw new LifecycleException(e);\n        }\n\n        setState(LifecycleState.STARTING);\n    }",
                "    protected synchronized void stopInternal() throws LifecycleException {\n\n        setState(LifecycleState.STOPPING);\n\n        close() ;\n    }"
            ],
            "java\\org\\apache\\juli\\OneLineFormatter.java": [
                "    public String format(LogRecord record) {\n        StringBuilder sb = new StringBuilder();\n\n        // Timestamp\n        addTimestamp(sb, record.getMillis());\n\n        // Severity\n        sb.append(' ');\n        sb.append(record.getLevel());\n\n        // Thread\n        sb.append(' ');\n        sb.append('[');\n        sb.append(Thread.currentThread().getName());\n        sb.append(']');\n\n        // Source\n        sb.append(' ');\n        sb.append(record.getSourceClassName());\n        sb.append('.');\n        sb.append(record.getSourceMethodName());\n\n        // Message\n        sb.append(' ');\n        sb.append(formatMessage(record));\n\n        // Stack trace\n        if (record.getThrown() != null) {\n            sb.append(ST_SEP);\n            StringWriter sw = new StringWriter();\n            PrintWriter pw = new PrintWriter(sw);\n            record.getThrown().printStackTrace(pw);\n            pw.close();\n            sb.append(sw.getBuffer());\n        }\n\n        // New line for next record\n        sb.append(LINE_SEP);\n\n        return sb.toString();\n    }",
                "    protected void addTimestamp(StringBuilder buf, long timestamp) {\n        buf.append(localDateCache.get().getFormat(timestamp));\n        long frac = timestamp % 1000;\n        buf.append('.');\n        if (frac < 100) {\n            if (frac < 10) {\n                buf.append('0');\n                buf.append('0');\n            } else {\n                buf.append('0');\n            }\n        }\n        buf.append(frac);\n    }"
            ],
            "java\\org\\apache\\juli\\VerbatimFormatter.java": [
                "    public String format(LogRecord record) {\n        // Timestamp\n        StringBuilder sb = new StringBuilder(record.getMessage());\n        \n        // New line for next record\n        sb.append(LINE_SEP);\n\n        return sb.toString();\n    }"
            ],
            "java\\org\\apache\\catalina\\tribes\\tipis\\ReplicatedMapEntry.java": [
                "    public void applyDiff(byte[] diff, int offset, int length) throws IOException, ClassNotFoundException;"
            ],
            "webapps\\examples\\WEB-INF\\classes\\examples\\LogTag.java": [
                "    public int doAfterBody() throws JspException {\n        try {\n            String s = bodyOut.getString();\n            System.err.println(s);\n            if (toBrowser)\n                bodyOut.writeOut(bodyOut.getEnclosingWriter());\n            return SKIP_BODY;\n        } catch (IOException ex) {\n            throw new JspTagException(ex.toString());\n        }\n    }"
            ],
            "test\\org\\apache\\catalina\\valves\\Benchmarks.java": [
                "    public void testAccessLogGetDate() throws Exception {\n        // Is it better to use a sync or a thread local here?\n        BenchmarkTest benchmark = new BenchmarkTest();\n        Runnable[] tests = new Runnable[] { new GetDateBenchmarkTest_Sync(),\n                new GetDateBenchmarkTest_Local(),\n                new GetDateBenchmarkTest_LocalMutableLong(),\n                new GetDateBenchmarkTest_LocalStruct() };\n        benchmark.doTest(5, tests);\n    }\n\n    public void testAccessLogTimeDateElement() throws Exception {\n        // Is it better to use a sync or a thread local here?\n        BenchmarkTest benchmark = new BenchmarkTest();\n        Runnable[] tests = new Runnable[] {\n                new TimeDateElementBenchmarkTest_Sync(),\n                new TimeDateElementBenchmarkTest_Local(),\n                new TimeDateElementBenchmarkTest_LocalStruct(),\n                new TimeDateElementBenchmarkTest_LocalStruct_SBuilder() };\n        benchmark.doTest(5, tests);\n    }"
            ],
            "test\\org\\apache\\juli\\TestDateFormatCache.java": [
                "    public void testBug54044() throws Exception {\n\n        final String timeFormat = \"dd-MMM-yyyy HH:mm:ss\";\n        final int cacheSize = 10;\n\n        SimpleDateFormat sdf = new SimpleDateFormat(timeFormat, Locale.US);\n        sdf.setTimeZone(TimeZone.getDefault());\n\n        DateFormatCache dfc = new DateFormatCache(cacheSize, timeFormat, null);\n\n        // Get dfc.cache.cache field\n        Object dfcCache;\n        Field dfcCacheArray;\n        {\n            Field dfcCacheField = dfc.getClass().getDeclaredField(\"cache\");\n            dfcCacheField.setAccessible(true);\n            dfcCache = dfcCacheField.get(dfc);\n            dfcCacheArray = dfcCache.getClass().getDeclaredField(\"cache\");\n            dfcCacheArray.setAccessible(true);\n        }\n\n        // Create an array to hold the expected values\n        String[] expected = new String[cacheSize];\n\n        // Fill the cache & populate the expected values\n        for (int secs = 0; secs < (cacheSize); secs++) {\n            dfc.getFormat(secs * 1000);\n            expected[secs] = generateExpected(sdf, secs);\n        }\n        Assert.assertArrayEquals(expected,\n                (String[]) dfcCacheArray.get(dfcCache));\n\n        // Cause the cache to roll-around by one and then confirm\n        dfc.getFormat(cacheSize * 1000);\n        expected[0] = generateExpected(sdf, cacheSize);\n        Assert.assertArrayEquals(expected,\n                (String[]) dfcCacheArray.get(dfcCache));\n\n        // Jump 2 ahead and then confirm (skipped value should be null)\n        dfc.getFormat((cacheSize + 2) * 1000);\n        expected[1] = null;\n        expected[2] = generateExpected(sdf, cacheSize + 2);\n        Assert.assertArrayEquals(expected,\n                (String[]) dfcCacheArray.get(dfcCache));\n\n        // Back 1 to fill in the gap\n        dfc.getFormat((cacheSize + 1) * 1000);\n        expected[1] = generateExpected(sdf, cacheSize + 1);\n        Assert.assertArrayEquals(expected,\n                (String[]) dfcCacheArray.get(dfcCache));\n\n        // Return to 1 and confirm skipped value is null\n        dfc.getFormat(1 * 1000);\n        expected[1] = generateExpected(sdf, 1);\n        expected[2] = null;\n        Assert.assertArrayEquals(expected,\n                (String[]) dfcCacheArray.get(dfcCache));\n\n        // Go back one further\n        dfc.getFormat(0);\n        expected[0] = generateExpected(sdf, 0);\n        Assert.assertArrayEquals(expected,\n                (String[]) dfcCacheArray.get(dfcCache));\n\n        // Jump ahead far enough that the entire cache will need to be cleared\n        dfc.getFormat(42 * 1000);\n        for (int i = 0; i < cacheSize; i++) {\n            expected[i] = null;\n        }\n        expected[0] = generateExpected(sdf, 42);\n        Assert.assertArrayEquals(expected,\n                (String[]) dfcCacheArray.get(dfcCache));\n    }"
            ],
            "test\\org\\apache\\catalina\\valves\\TestRemoteIpValve.java": [
                "    public void testInvokeAllowedRemoteAddrWithNullRemoteIpHeader() throws Exception {\n        // PREPARE\n        RemoteIpValve remoteIpValve = new RemoteIpValve();\n        remoteIpValve.setInternalProxies(\"192\\\\.168\\\\.0\\\\.10, 192\\\\.168\\\\.0\\\\.11\");\n        remoteIpValve.setTrustedProxies(\"proxy1, proxy2, proxy3\");\n        remoteIpValve.setRemoteIpHeader(\"x-forwarded-for\");\n        remoteIpValve.setProxiesHeader(\"x-forwarded-by\");\n        RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve();\n        remoteIpValve.setNext(remoteAddrAndHostTrackerValve);\n\n        Request request = new MockRequest();\n        request.setCoyoteRequest(new org.apache.coyote.Request());\n        request.setRemoteAddr(\"192.168.0.10\");\n        request.setRemoteHost(\"remote-host-original-value\");\n\n        // TEST\n        remoteIpValve.invoke(request, null);\n\n        // VERIFY\n        String actualXForwardedFor = request.getHeader(\"x-forwarded-for\");\n        assertNull(\"x-forwarded-for must be null\", actualXForwardedFor);\n\n        String actualXForwardedBy = request.getHeader(\"x-forwarded-by\");\n        assertNull(\"x-forwarded-by must be null\", actualXForwardedBy);\n\n        String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr();\n        assertEquals(\"remoteAddr\", \"192.168.0.10\", actualRemoteAddr);\n\n        String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost();\n        assertEquals(\"remoteHost\", \"remote-host-original-value\", actualRemoteHost);\n\n        String actualPostInvokeRemoteAddr = request.getRemoteAddr();\n        assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteAddr);\n\n        String actualPostInvokeRemoteHost = request.getRemoteHost();\n        assertEquals(\"postInvoke remoteAddr\", \"remote-host-original-value\", actualPostInvokeRemoteHost);\n\n    }",
                "    public void testInvokeAllProxiesAreTrusted() throws Exception {\n\n        // PREPARE\n        RemoteIpValve remoteIpValve = new RemoteIpValve();\n        remoteIpValve.setInternalProxies(\"192\\\\.168\\\\.0\\\\.10|192\\\\.168\\\\.0\\\\.11\");\n        remoteIpValve.setTrustedProxies(\"proxy1|proxy2|proxy3\");\n        remoteIpValve.setRemoteIpHeader(\"x-forwarded-for\");\n        remoteIpValve.setProxiesHeader(\"x-forwarded-by\");\n        RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve();\n        remoteIpValve.setNext(remoteAddrAndHostTrackerValve);\n\n        Request request = new MockRequest();\n        request.setCoyoteRequest(new org.apache.coyote.Request());\n        request.setRemoteAddr(\"192.168.0.10\");\n        request.setRemoteHost(\"remote-host-original-value\");\n        request.getCoyoteRequest().getMimeHeaders().addValue(\"x-forwarded-for\").setString(\"140.211.11.130, proxy1, proxy2\");\n\n        // TEST\n        remoteIpValve.invoke(request, null);\n\n        // VERIFY\n        String actualXForwardedFor = request.getHeader(\"x-forwarded-for\");\n        assertNull(\"all proxies are trusted, x-forwarded-for must be null\", actualXForwardedFor);\n\n        String actualXForwardedBy = request.getHeader(\"x-forwarded-by\");\n        assertEquals(\"all proxies are trusted, they must appear in x-forwarded-by\", \"proxy1, proxy2\", actualXForwardedBy);\n\n        String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr();\n        assertEquals(\"remoteAddr\", \"140.211.11.130\", actualRemoteAddr);\n\n        String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost();\n        assertEquals(\"remoteHost\", \"140.211.11.130\", actualRemoteHost);\n\n        String actualPostInvokeRemoteAddr = request.getRemoteAddr();\n        assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteAddr);\n\n        String actualPostInvokeRemoteHost = request.getRemoteHost();\n        assertEquals(\"postInvoke remoteAddr\", \"remote-host-original-value\", actualPostInvokeRemoteHost);\n    }",
                "    public void testInvokeAllProxiesAreTrustedOrInternal() throws Exception {\n\n        // PREPARE\n        RemoteIpValve remoteIpValve = new RemoteIpValve();\n        remoteIpValve.setInternalProxies(\"192\\\\.168\\\\.0\\\\.10|192\\\\.168\\\\.0\\\\.11\");\n        remoteIpValve.setTrustedProxies(\"proxy1|proxy2|proxy3\");\n        remoteIpValve.setRemoteIpHeader(\"x-forwarded-for\");\n        remoteIpValve.setProxiesHeader(\"x-forwarded-by\");\n        RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve();\n        remoteIpValve.setNext(remoteAddrAndHostTrackerValve);\n\n        Request request = new MockRequest();\n        request.setCoyoteRequest(new org.apache.coyote.Request());\n        request.setRemoteAddr(\"192.168.0.10\");\n        request.setRemoteHost(\"remote-host-original-value\");\n        request.getCoyoteRequest().getMimeHeaders().addValue(\"x-forwarded-for\")\n            .setString(\"140.211.11.130, proxy1, proxy2, 192.168.0.10, 192.168.0.11\");\n\n        // TEST\n        remoteIpValve.invoke(request, null);\n\n        // VERIFY\n        String actualXForwardedFor = request.getHeader(\"x-forwarded-for\");\n        assertNull(\"all proxies are trusted, x-forwarded-for must be null\", actualXForwardedFor);\n\n        String actualXForwardedBy = request.getHeader(\"x-forwarded-by\");\n        assertEquals(\"all proxies are trusted, they must appear in x-forwarded-by\", \"proxy1, proxy2\", actualXForwardedBy);\n\n        String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr();\n        assertEquals(\"remoteAddr\", \"140.211.11.130\", actualRemoteAddr);\n\n        String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost();\n        assertEquals(\"remoteHost\", \"140.211.11.130\", actualRemoteHost);\n\n        String actualPostInvokeRemoteAddr = request.getRemoteAddr();\n        assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteAddr);\n\n        String actualPostInvokeRemoteHost = request.getRemoteHost();\n        assertEquals(\"postInvoke remoteAddr\", \"remote-host-original-value\", actualPostInvokeRemoteHost);\n    }",
                "    public void testInvokeAllProxiesAreInternal() throws Exception {\n\n        // PREPARE\n        RemoteIpValve remoteIpValve = new RemoteIpValve();\n        remoteIpValve.setInternalProxies(\"192\\\\.168\\\\.0\\\\.10|192\\\\.168\\\\.0\\\\.11\");\n        remoteIpValve.setTrustedProxies(\"proxy1|proxy2|proxy3\");\n        remoteIpValve.setRemoteIpHeader(\"x-forwarded-for\");\n        remoteIpValve.setProxiesHeader(\"x-forwarded-by\");\n        RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve();\n        remoteIpValve.setNext(remoteAddrAndHostTrackerValve);\n\n        Request request = new MockRequest();\n        request.setCoyoteRequest(new org.apache.coyote.Request());\n        request.setRemoteAddr(\"192.168.0.10\");\n        request.setRemoteHost(\"remote-host-original-value\");\n        request.getCoyoteRequest().getMimeHeaders().addValue(\"x-forwarded-for\").setString(\"140.211.11.130, 192.168.0.10, 192.168.0.11\");\n\n        // TEST\n        remoteIpValve.invoke(request, null);\n\n        // VERIFY\n        String actualXForwardedFor = request.getHeader(\"x-forwarded-for\");\n        assertNull(\"all proxies are internal, x-forwarded-for must be null\", actualXForwardedFor);\n\n        String actualXForwardedBy = request.getHeader(\"x-forwarded-by\");\n        assertNull(\"all proxies are internal, x-forwarded-by must be null\", actualXForwardedBy);\n\n        String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr();\n        assertEquals(\"remoteAddr\", \"140.211.11.130\", actualRemoteAddr);\n\n        String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost();\n        assertEquals(\"remoteHost\", \"140.211.11.130\", actualRemoteHost);\n\n        String actualPostInvokeRemoteAddr = request.getRemoteAddr();\n        assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteAddr);\n\n        String actualPostInvokeRemoteHost = request.getRemoteHost();\n        assertEquals(\"postInvoke remoteAddr\", \"remote-host-original-value\", actualPostInvokeRemoteHost);\n    }",
                "    public void testInvokeAllProxiesAreTrustedAndRemoteAddrMatchRegexp() throws Exception {\n\n        // PREPARE\n        RemoteIpValve remoteIpValve = new RemoteIpValve();\n        remoteIpValve.setInternalProxies(\"127\\\\.0\\\\.0\\\\.1|192\\\\.168\\\\..*|another-internal-proxy\");\n        remoteIpValve.setTrustedProxies(\"proxy1|proxy2|proxy3\");\n        remoteIpValve.setRemoteIpHeader(\"x-forwarded-for\");\n        remoteIpValve.setProxiesHeader(\"x-forwarded-by\");\n        RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve();\n        remoteIpValve.setNext(remoteAddrAndHostTrackerValve);\n\n        Request request = new MockRequest();\n        request.setCoyoteRequest(new org.apache.coyote.Request());\n        request.setRemoteAddr(\"192.168.0.10\");\n        request.setRemoteHost(\"remote-host-original-value\");\n        request.getCoyoteRequest().getMimeHeaders().addValue(\"x-forwarded-for\").setString(\"140.211.11.130\");\n        request.getCoyoteRequest().getMimeHeaders().addValue(\"x-forwarded-for\").setString(\"proxy1\");\n        request.getCoyoteRequest().getMimeHeaders().addValue(\"x-forwarded-for\").setString(\"proxy2\");\n\n        // TEST\n        remoteIpValve.invoke(request, null);\n\n        // VERIFY\n        String actualXForwardedFor = request.getHeader(\"x-forwarded-for\");\n        assertNull(\"all proxies are trusted, x-forwarded-for must be null\", actualXForwardedFor);\n\n        String actualXForwardedBy = request.getHeader(\"x-forwarded-by\");\n        assertEquals(\"all proxies are trusted, they must appear in x-forwarded-by\", \"proxy1, proxy2\", actualXForwardedBy);\n\n        String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr();\n        assertEquals(\"remoteAddr\", \"140.211.11.130\", actualRemoteAddr);\n\n        String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost();\n        assertEquals(\"remoteHost\", \"140.211.11.130\", actualRemoteHost);\n\n        String actualPostInvokeRemoteAddr = request.getRemoteAddr();\n        assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteAddr);\n\n        String actualPostInvokeRemoteHost = request.getRemoteHost();\n        assertEquals(\"postInvoke remoteAddr\", \"remote-host-original-value\", actualPostInvokeRemoteHost);\n    }",
                "    public void testInvokeXforwardedProtoSaysHttpsForIncomingHttpRequest() throws Exception {\n\n        // PREPARE\n        RemoteIpValve remoteIpValve = new RemoteIpValve();\n        remoteIpValve.setRemoteIpHeader(\"x-forwarded-for\");\n        remoteIpValve.setProtocolHeader(\"x-forwarded-proto\");\n        RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve();\n        remoteIpValve.setNext(remoteAddrAndHostTrackerValve);\n\n        Request request = new MockRequest();\n        request.setCoyoteRequest(new org.apache.coyote.Request());\n        // client ip\n        request.setRemoteAddr(\"192.168.0.10\");\n        request.setRemoteHost(\"192.168.0.10\");\n        request.getCoyoteRequest().getMimeHeaders().addValue(\"x-forwarded-for\").setString(\"140.211.11.130\");\n        // protocol\n        request.getCoyoteRequest().getMimeHeaders().addValue(\"x-forwarded-proto\").setString(\"https\");\n        request.setSecure(false);\n        request.setServerPort(8080);\n        request.getCoyoteRequest().scheme().setString(\"http\");\n\n        // TEST\n        remoteIpValve.invoke(request, null);\n\n        // VERIFY\n        // client ip\n        String actualXForwardedFor = request.getHeader(\"x-forwarded-for\");\n        assertNull(\"no intermediate non-trusted proxy, x-forwarded-for must be null\", actualXForwardedFor);\n\n        String actualXForwardedBy = request.getHeader(\"x-forwarded-by\");\n        assertNull(\"no intermediate trusted proxy\", actualXForwardedBy);\n\n        String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr();\n        assertEquals(\"remoteAddr\", \"140.211.11.130\", actualRemoteAddr);\n\n        String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost();\n        assertEquals(\"remoteHost\", \"140.211.11.130\", actualRemoteHost);\n\n        String actualPostInvokeRemoteAddr = request.getRemoteAddr();\n        assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteAddr);\n\n        String actualPostInvokeRemoteHost = request.getRemoteHost();\n        assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteHost);\n\n        // protocol\n        String actualScheme = remoteAddrAndHostTrackerValve.getScheme();\n        assertEquals(\"x-forwarded-proto says https\", \"https\", actualScheme);\n\n        int actualServerPort = remoteAddrAndHostTrackerValve.getServerPort();\n        assertEquals(\"x-forwarded-proto says https\", 443, actualServerPort);\n\n        boolean actualSecure = remoteAddrAndHostTrackerValve.isSecure();\n        assertTrue(\"x-forwarded-proto says https\", actualSecure);\n\n        boolean actualPostInvokeSecure = request.isSecure();\n        assertFalse(\"postInvoke secure\", actualPostInvokeSecure);\n\n        int actualPostInvokeServerPort = request.getServerPort();\n        assertEquals(\"postInvoke serverPort\", 8080, actualPostInvokeServerPort);\n\n        String actualPostInvokeScheme = request.getScheme();\n        assertEquals(\"postInvoke scheme\", \"http\", actualPostInvokeScheme);\n    }",
                "    public void testInvokeXforwardedProtoIsNullForIncomingHttpRequest() throws Exception {\n\n        // PREPARE\n        RemoteIpValve remoteIpValve = new RemoteIpValve();\n        remoteIpValve.setRemoteIpHeader(\"x-forwarded-for\");\n        remoteIpValve.setProtocolHeader(\"x-forwarded-proto\");\n        RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve();\n        remoteIpValve.setNext(remoteAddrAndHostTrackerValve);\n\n        Request request = new MockRequest();\n        request.setCoyoteRequest(new org.apache.coyote.Request());\n        // client ip\n        request.setRemoteAddr(\"192.168.0.10\");\n        request.setRemoteHost(\"192.168.0.10\");\n        request.getCoyoteRequest().getMimeHeaders().addValue(\"x-forwarded-for\").setString(\"140.211.11.130\");\n        // protocol\n        // null \"x-forwarded-proto\"\n        request.setSecure(false);\n        request.setServerPort(8080);\n        request.getCoyoteRequest().scheme().setString(\"http\");\n\n        // TEST\n        remoteIpValve.invoke(request, null);\n\n        // VERIFY\n        // client ip\n        String actualXForwardedFor = request.getHeader(\"x-forwarded-for\");\n        assertNull(\"no intermediate non-trusted proxy, x-forwarded-for must be null\", actualXForwardedFor);\n\n        String actualXForwardedBy = request.getHeader(\"x-forwarded-by\");\n        assertNull(\"no intermediate trusted proxy\", actualXForwardedBy);\n\n        String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr();\n        assertEquals(\"remoteAddr\", \"140.211.11.130\", actualRemoteAddr);\n\n        String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost();\n        assertEquals(\"remoteHost\", \"140.211.11.130\", actualRemoteHost);\n\n        String actualPostInvokeRemoteAddr = request.getRemoteAddr();\n        assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteAddr);\n\n        String actualPostInvokeRemoteHost = request.getRemoteHost();\n        assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteHost);\n\n        // protocol\n        String actualScheme = remoteAddrAndHostTrackerValve.getScheme();\n        assertEquals(\"x-forwarded-proto is null\", \"http\", actualScheme);\n\n        int actualServerPort = remoteAddrAndHostTrackerValve.getServerPort();\n        assertEquals(\"x-forwarded-proto is null\", 8080, actualServerPort);\n\n        boolean actualSecure = remoteAddrAndHostTrackerValve.isSecure();\n        assertFalse(\"x-forwarded-proto is null\", actualSecure);\n\n        boolean actualPostInvokeSecure = request.isSecure();\n        assertFalse(\"postInvoke secure\", actualPostInvokeSecure);\n\n        int actualPostInvokeServerPort = request.getServerPort();\n        assertEquals(\"postInvoke serverPort\", 8080, actualPostInvokeServerPort);\n\n        String actualPostInvokeScheme = request.getScheme();\n        assertEquals(\"postInvoke scheme\", \"http\", actualPostInvokeScheme);\n    }",
                "    public void testInvokeXforwardedProtoSaysHttpForIncomingHttpsRequest() throws Exception {\n\n        // PREPARE\n        RemoteIpValve remoteIpValve = new RemoteIpValve();\n        remoteIpValve.setRemoteIpHeader(\"x-forwarded-for\");\n        remoteIpValve.setProtocolHeader(\"x-forwarded-proto\");\n        RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve();\n        remoteIpValve.setNext(remoteAddrAndHostTrackerValve);\n\n        Request request = new MockRequest();\n        request.setCoyoteRequest(new org.apache.coyote.Request());\n        // client ip\n        request.setRemoteAddr(\"192.168.0.10\");\n        request.setRemoteHost(\"192.168.0.10\");\n        request.getCoyoteRequest().getMimeHeaders().addValue(\"x-forwarded-for\").setString(\"140.211.11.130\");\n        // protocol\n        request.getCoyoteRequest().getMimeHeaders().addValue(\"x-forwarded-proto\").setString(\"http\");\n        request.setSecure(true);\n        request.setServerPort(8443);\n        request.getCoyoteRequest().scheme().setString(\"https\");\n\n        // TEST\n        remoteIpValve.invoke(request, null);\n\n        // VERIFY\n        // client ip\n        String actualXForwardedFor = request.getHeader(\"x-forwarded-for\");\n        assertNull(\"no intermediate non-trusted proxy, x-forwarded-for must be null\", actualXForwardedFor);\n\n        String actualXForwardedBy = request.getHeader(\"x-forwarded-by\");\n        assertNull(\"no intermediate trusted proxy\", actualXForwardedBy);\n\n        String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr();\n        assertEquals(\"remoteAddr\", \"140.211.11.130\", actualRemoteAddr);\n\n        String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost();\n        assertEquals(\"remoteHost\", \"140.211.11.130\", actualRemoteHost);\n\n        String actualPostInvokeRemoteAddr = request.getRemoteAddr();\n        assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteAddr);\n\n        String actualPostInvokeRemoteHost = request.getRemoteHost();\n        assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteHost);\n\n        // protocol\n        String actualScheme = remoteAddrAndHostTrackerValve.getScheme();\n        assertEquals(\"x-forwarded-proto says http\", \"http\", actualScheme);\n\n        int actualServerPort = remoteAddrAndHostTrackerValve.getServerPort();\n        assertEquals(\"x-forwarded-proto says http\", 80, actualServerPort);\n\n        boolean actualSecure = remoteAddrAndHostTrackerValve.isSecure();\n        assertFalse(\"x-forwarded-proto says http\", actualSecure);\n\n        boolean actualPostInvokeSecure = request.isSecure();\n        assertTrue(\"postInvoke secure\", actualPostInvokeSecure);\n\n        int actualPostInvokeServerPort = request.getServerPort();\n        assertEquals(\"postInvoke serverPort\", 8443, actualPostInvokeServerPort);\n\n        String actualPostInvokeScheme = request.getScheme();\n        assertEquals(\"postInvoke scheme\", \"https\", actualPostInvokeScheme);\n    }",
                "    public void testInvokeXforwardedProtoIsNullForIncomingHttpsRequest() throws Exception {\n\n        // PREPARE\n        RemoteIpValve remoteIpValve = new RemoteIpValve();\n        remoteIpValve.setRemoteIpHeader(\"x-forwarded-for\");\n        remoteIpValve.setProtocolHeader(\"x-forwarded-proto\");\n        RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve();\n        remoteIpValve.setNext(remoteAddrAndHostTrackerValve);\n\n        Request request = new MockRequest();\n        request.setCoyoteRequest(new org.apache.coyote.Request());\n        // client ip\n        request.setRemoteAddr(\"192.168.0.10\");\n        request.setRemoteHost(\"192.168.0.10\");\n        request.getCoyoteRequest().getMimeHeaders().addValue(\"x-forwarded-for\").setString(\"140.211.11.130\");\n        // protocol\n        // Don't declare \"x-forwarded-proto\"\n        request.setSecure(true);\n        request.setServerPort(8443);\n        request.getCoyoteRequest().scheme().setString(\"https\");\n\n        // TEST\n        remoteIpValve.invoke(request, null);\n\n        // VERIFY\n        // client ip\n        String actualXForwardedFor = request.getHeader(\"x-forwarded-for\");\n        assertNull(\"no intermediate non-trusted proxy, x-forwarded-for must be null\", actualXForwardedFor);\n\n        String actualXForwardedBy = request.getHeader(\"x-forwarded-by\");\n        assertNull(\"no intermediate trusted proxy\", actualXForwardedBy);\n\n        String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr();\n        assertEquals(\"remoteAddr\", \"140.211.11.130\", actualRemoteAddr);\n\n        String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost();\n        assertEquals(\"remoteHost\", \"140.211.11.130\", actualRemoteHost);\n\n        String actualPostInvokeRemoteAddr = request.getRemoteAddr();\n        assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteAddr);\n\n        String actualPostInvokeRemoteHost = request.getRemoteHost();\n        assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteHost);\n\n        // protocol\n        String actualScheme = remoteAddrAndHostTrackerValve.getScheme();\n        assertEquals(\"x-forwarded-proto is null\", \"https\", actualScheme);\n\n        int actualServerPort = remoteAddrAndHostTrackerValve.getServerPort();\n        assertEquals(\"x-forwarded-proto is null\", 8443, actualServerPort);\n\n        boolean actualSecure = remoteAddrAndHostTrackerValve.isSecure();\n        assertTrue(\"x-forwarded-proto is null\", actualSecure);\n\n        boolean actualPostInvokeSecure = request.isSecure();\n        assertTrue(\"postInvoke secure\", actualPostInvokeSecure);\n\n        int actualPostInvokeServerPort = request.getServerPort();\n        assertEquals(\"postInvoke serverPort\", 8443, actualPostInvokeServerPort);\n\n        String actualPostInvokeScheme = request.getScheme();\n        assertEquals(\"postInvoke scheme\", \"https\", actualPostInvokeScheme);\n    }",
                "    public void testInvokeNotAllowedRemoteAddr() throws Exception {\n        // PREPARE\n        RemoteIpValve remoteIpValve = new RemoteIpValve();\n        remoteIpValve.setInternalProxies(\"192\\\\.168\\\\.0\\\\.10|192\\\\.168\\\\.0\\\\.11\");\n        remoteIpValve.setTrustedProxies(\"proxy1|proxy2|proxy3\");\n        remoteIpValve.setRemoteIpHeader(\"x-forwarded-for\");\n        remoteIpValve.setProxiesHeader(\"x-forwarded-by\");\n        RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve();\n        remoteIpValve.setNext(remoteAddrAndHostTrackerValve);\n\n        Request request = new MockRequest();\n        request.setCoyoteRequest(new org.apache.coyote.Request());\n        request.setRemoteAddr(\"not-allowed-internal-proxy\");\n        request.setRemoteHost(\"not-allowed-internal-proxy-host\");\n        request.getCoyoteRequest().getMimeHeaders().addValue(\"x-forwarded-for\").setString(\"140.211.11.130, proxy1, proxy2\");\n\n        // TEST\n        remoteIpValve.invoke(request, null);\n\n        // VERIFY\n        String actualXForwardedFor = request.getHeader(\"x-forwarded-for\");\n        assertEquals(\"x-forwarded-for must be unchanged\", \"140.211.11.130, proxy1, proxy2\", actualXForwardedFor);\n\n        String actualXForwardedBy = request.getHeader(\"x-forwarded-by\");\n        assertNull(\"x-forwarded-by must be null\", actualXForwardedBy);\n\n        String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr();\n        assertEquals(\"remoteAddr\", \"not-allowed-internal-proxy\", actualRemoteAddr);\n\n        String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost();\n        assertEquals(\"remoteHost\", \"not-allowed-internal-proxy-host\", actualRemoteHost);\n\n        String actualPostInvokeRemoteAddr = request.getRemoteAddr();\n        assertEquals(\"postInvoke remoteAddr\", \"not-allowed-internal-proxy\", actualPostInvokeRemoteAddr);\n\n        String actualPostInvokeRemoteHost = request.getRemoteHost();\n        assertEquals(\"postInvoke remoteAddr\", \"not-allowed-internal-proxy-host\", actualPostInvokeRemoteHost);\n    }",
                "    public void testInvokeUntrustedProxyInTheChain() throws Exception {\n        // PREPARE\n        RemoteIpValve remoteIpValve = new RemoteIpValve();\n        remoteIpValve.setInternalProxies(\"192\\\\.168\\\\.0\\\\.10|192\\\\.168\\\\.0\\\\.11\");\n        remoteIpValve.setTrustedProxies(\"proxy1|proxy2|proxy3\");\n        remoteIpValve.setRemoteIpHeader(\"x-forwarded-for\");\n        remoteIpValve.setProxiesHeader(\"x-forwarded-by\");\n        RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve();\n        remoteIpValve.setNext(remoteAddrAndHostTrackerValve);\n\n        Request request = new MockRequest();\n        request.setCoyoteRequest(new org.apache.coyote.Request());\n        request.setRemoteAddr(\"192.168.0.10\");\n        request.setRemoteHost(\"remote-host-original-value\");\n        request.getCoyoteRequest().getMimeHeaders().addValue(\"x-forwarded-for\")\n            .setString(\"140.211.11.130, proxy1, untrusted-proxy, proxy2\");\n\n        // TEST\n        remoteIpValve.invoke(request, null);\n\n        // VERIFY\n        String actualXForwardedFor = request.getHeader(\"x-forwarded-for\");\n        assertEquals(\"ip/host before untrusted-proxy must appear in x-forwarded-for\", \"140.211.11.130, proxy1\", actualXForwardedFor);\n\n        String actualXForwardedBy = request.getHeader(\"x-forwarded-by\");\n        assertEquals(\"ip/host after untrusted-proxy must appear in  x-forwarded-by\", \"proxy2\", actualXForwardedBy);\n\n        String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr();\n        assertEquals(\"remoteAddr\", \"untrusted-proxy\", actualRemoteAddr);\n\n        String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost();\n        assertEquals(\"remoteHost\", \"untrusted-proxy\", actualRemoteHost);\n\n        String actualPostInvokeRemoteAddr = request.getRemoteAddr();\n        assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteAddr);\n\n        String actualPostInvokeRemoteHost = request.getRemoteHost();\n        assertEquals(\"postInvoke remoteAddr\", \"remote-host-original-value\", actualPostInvokeRemoteHost);\n    }",
                "    public void testRequestAttributesForAccessLog() throws Exception {\n\n        // PREPARE\n        RemoteIpValve remoteIpValve = new RemoteIpValve();\n        remoteIpValve.setRemoteIpHeader(\"x-forwarded-for\");\n        remoteIpValve.setProtocolHeader(\"x-forwarded-proto\");\n        RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve();\n        remoteIpValve.setNext(remoteAddrAndHostTrackerValve);\n\n        Request request = new MockRequest();\n        request.setCoyoteRequest(new org.apache.coyote.Request());\n        // client ip\n        request.setRemoteAddr(\"192.168.0.10\");\n        request.setRemoteHost(\"192.168.0.10\");\n        request.getCoyoteRequest().getMimeHeaders().addValue(\"x-forwarded-for\").setString(\"140.211.11.130\");\n        // protocol\n        request.setServerPort(8080);\n        request.getCoyoteRequest().scheme().setString(\"http\");\n\n        // TEST\n        remoteIpValve.invoke(request, null);\n\n        // VERIFY\n        Assert.assertEquals(\"org.apache.catalina.AccessLog.ServerPort\",\n                Integer.valueOf(8080),\n                request.getAttribute(AccessLog.SERVER_PORT_ATTRIBUTE));\n\n        Assert.assertEquals(\"org.apache.catalina.AccessLog.RemoteAddr\",\n                \"140.211.11.130\",\n                request.getAttribute(AccessLog.REMOTE_ADDR_ATTRIBUTE));\n\n        Assert.assertEquals(\"org.apache.catalina.AccessLog.RemoteHost\",\n                \"140.211.11.130\",\n                request.getAttribute(AccessLog.REMOTE_HOST_ATTRIBUTE));\n    }",
                "    private void assertArrayEquals(String[] expected, String[] actual) {\n        if (expected == null) {\n            assertNull(actual);\n            return;\n        }\n        assertNotNull(actual);\n        assertEquals(expected.length, actual.length);\n        List<String> e = new ArrayList<String>();\n        e.addAll(Arrays.asList(expected));\n        List<String> a = new ArrayList<String>();\n        a.addAll(Arrays.asList(actual));\n\n        for (String entry : e) {\n            assertTrue(a.remove(entry));\n        }\n        assertTrue(a.isEmpty());\n    }"
            ],
            "java\\org\\apache\\catalina\\core\\AccessLogAdapter.java": [
                "    public void add(AccessLog log) {\n        if (log == null) {\n            throw new NullPointerException();\n        }\n        AccessLog newArray[] = Arrays.copyOf(logs, logs.length + 1);\n        newArray[newArray.length - 1] = log;\n        logs = newArray;\n    }\n\n    public void log(Request request, Response response, long time) {\n        for (AccessLog log: logs) {\n            log.log(request, response, time);\n        }\n    }"
            ],
            "java\\org\\apache\\catalina\\valves\\ValveBase.java": [
                "    protected void initInternal() throws LifecycleException {\n        super.initInternal();\n\n        containerLog = getContainer().getLogger();\n    }\n\n    protected synchronized void startInternal() throws LifecycleException {\n\n        setState(LifecycleState.STARTING);\n    }\n\n    protected synchronized void stopInternal() throws LifecycleException {\n\n        setState(LifecycleState.STOPPING);\n    }"
            ],
            "java\\org\\apache\\catalina\\core\\StandardPipeline.java": [
                "    public boolean isAsyncSupported() {\n        Valve valve = (first!=null)?first:basic;\n        boolean supported = true;\n        while (supported && valve!=null) {\n            supported = supported & valve.isAsyncSupported();\n            valve = valve.getNext();\n        }\n        return supported; \n    }\n\n    protected synchronized void startInternal() throws LifecycleException {\n\n        // Start the Valves in our pipeline (including the basic), if any\n        Valve current = first;\n        if (current == null) {\n            current = basic;\n        }\n        while (current != null) {\n            if (current instanceof Lifecycle)\n                ((Lifecycle) current).start();\n            current = current.getNext();\n        }\n\n        setState(LifecycleState.STARTING);\n    }\n\n    protected synchronized void stopInternal() throws LifecycleException {\n\n        setState(LifecycleState.STOPPING);\n\n        // Stop the Valves in our pipeline (including the basic), if any\n        Valve current = first;\n        if (current == null) {\n            current = basic;\n        }\n        while (current != null) {\n            if (current instanceof Lifecycle)\n                ((Lifecycle) current).stop();\n            current = current.getNext();\n        }\n    }",
                "    public void addValve(Valve valve) {\n    \n        // Validate that we can add this Valve\n        if (valve instanceof Contained)\n            ((Contained) valve).setContainer(this.container);\n\n        // Start the new component if necessary\n        if (getState().isAvailable()) {\n            if (valve instanceof Lifecycle) {\n                try {\n                    ((Lifecycle) valve).start();\n                } catch (LifecycleException e) {\n                    log.error(\"StandardPipeline.addValve: start: \", e);\n                }\n            }\n        }\n\n        // Add this Valve to the set associated with this Pipeline\n        if (first == null) {\n            first = valve;\n            valve.setNext(basic);\n        } else {\n            Valve current = first;\n            while (current != null) {\n                if (current.getNext() == basic) {\n                    current.setNext(valve);\n                    valve.setNext(basic);\n                    break;\n                }\n                current = current.getNext();\n            }\n        }\n        \n        container.fireContainerEvent(Container.ADD_VALVE_EVENT, valve);\n    }",
                "    public void removeValve(Valve valve) {\n\n        Valve current;\n        if(first == valve) {\n            first = first.getNext();\n            current = null;\n        } else {\n            current = first;\n        }\n        while (current != null) {\n            if (current.getNext() == valve) {\n                current.setNext(valve.getNext());\n                break;\n            }\n            current = current.getNext();\n        }\n\n        if (first == basic) first = null;\n\n        if (valve instanceof Contained)\n            ((Contained) valve).setContainer(null);\n\n        if (valve instanceof Lifecycle) {\n            // Stop this valve if necessary\n            if (getState().isAvailable()) {\n                try {\n                    ((Lifecycle) valve).stop();\n                } catch (LifecycleException e) {\n                    log.error(\"StandardPipeline.removeValve: stop: \", e);\n                }\n            }\n            try {\n                ((Lifecycle) valve).destroy();\n            } catch (LifecycleException e) {\n                log.error(\"StandardPipeline.removeValve: destroy: \", e);\n            }\n        }\n        \n        container.fireContainerEvent(Container.REMOVE_VALVE_EVENT, valve);\n    }"
            ],
            "test\\org\\apache\\catalina\\core\\TestAsyncContextImpl.java": [
                "    public void testBug49528() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        Bug49528Servlet servlet = new Bug49528Servlet();\n\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"servlet\", servlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        // Call the servlet once\n        ByteChunk bc = getUrl(\"http://localhost:\" + getPort() + \"/\");\n        assertEquals(\"OK\", bc.toString());\n\n        // Give the async thread a chance to finish (but not too long)\n        int counter = 0;\n        while (!servlet.isDone() && counter < 10) {\n            Thread.sleep(1000);\n            counter++;\n        }\n\n        assertEquals(\"1false2true3true4true5false\", servlet.getResult());\n\n        // Check the access log\n        alv.validateAccessLog(1, 200, Bug49528Servlet.THREAD_SLEEP_TIME,\n                Bug49528Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);\n    }",
                "    public void testBug49567() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        Bug49567Servlet servlet = new Bug49567Servlet();\n\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"servlet\", servlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        // Call the servlet once\n        ByteChunk bc = getUrl(\"http://localhost:\" + getPort() + \"/\");\n        assertEquals(\"OK\", bc.toString());\n\n        // Give the async thread a chance to finish (but not too long)\n        int counter = 0;\n        while (!servlet.isDone() && counter < 10) {\n            Thread.sleep(1000);\n            counter++;\n        }\n\n        assertEquals(\"1false2true3true4true5false\", servlet.getResult());\n\n        // Check the access log\n        alv.validateAccessLog(1, 200, Bug49567Servlet.THREAD_SLEEP_TIME,\n                Bug49567Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);\n    }",
                "    public void testAsyncStartNoComplete() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Minimise pauses during test\n        tomcat.getConnector().setAttribute(\n                \"connectionTimeout\", Integer.valueOf(3000));\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        AsyncStartNoCompleteServlet servlet =\n            new AsyncStartNoCompleteServlet();\n\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"servlet\", servlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        // Call the servlet the first time\n        ByteChunk bc1 = getUrl(\"http://localhost:\" + getPort() +\n                \"/?echo=run1\");\n        assertEquals(\"OK-run1\", bc1.toString());\n\n        // Call the servlet the second time with a request parameter\n        ByteChunk bc2 = getUrl(\"http://localhost:\" + getPort() +\n                \"/?echo=run2\");\n        assertEquals(\"OK-run2\", bc2.toString());\n\n        // Check the access log\n        alv.validateAccessLog(2, 500,\n                AsyncStartNoCompleteServlet.ASYNC_TIMEOUT,\n                AsyncStartNoCompleteServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN +\n                        REQUEST_TIME);\n    }",
                "    public void testAsyncStartWithComplete() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        AsyncStartWithCompleteServlet servlet =\n            new AsyncStartWithCompleteServlet();\n\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"servlet\", servlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        // Call the servlet once\n        ByteChunk bc = getUrl(\"http://localhost:\" + getPort() + \"/\");\n        assertEquals(\"OK\", bc.toString());\n\n        // Check the access log\n        alv.validateAccessLog(1, 200, 0, REQUEST_TIME);\n    }\n\n    public void testTimeoutListenerCompleteNoDispatch() throws Exception {\n        // Should work\n        doTestTimeout(Boolean.TRUE, null);\n    }\n\n    public void testTimeoutListenerNoCompleteNoDispatch() throws Exception {\n        // Should trigger an error - must do one or other\n        doTestTimeout(Boolean.FALSE, null);\n    }",
                "    public void testTimeoutListenerCompleteNonAsyncDispatch() throws Exception {\n        // Should trigger an error - can't do both\n        doTestTimeout(Boolean.TRUE, Boolean.FALSE);\n    }\n\n    public void testTimeoutListenerCompleteAsyncDispatch() throws Exception {\n        // Should trigger an error - can't do both\n        doTestTimeout(Boolean.TRUE, Boolean.TRUE);\n    }\n\n    public void testTimeoutNoListener() throws Exception {\n        // Should work\n        doTestTimeout(null, null);\n    }",
                "    public void testDispatchDouble() throws Exception {\n        doTestDispatch(2, false);\n    }\n\n    public void testDispatchWithThreadSingle() throws Exception {\n        doTestDispatch(1, true);\n    }\n\n    public void testDispatchWithThreadDouble() throws Exception {\n        doTestDispatch(2, true);\n    }",
                "    public void testDispatchWithThreadMultiple() throws Exception {\n        doTestDispatch(5, true);\n    }",
                "    private void doTestDispatch(int iter, boolean useThread) throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        DispatchingServlet dispatch = new DispatchingServlet(false, false);\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"dispatch\", dispatch);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/stage1\", \"dispatch\");\n\n        NonAsyncServlet nonasync = new NonAsyncServlet();\n        Wrapper wrapper2 = Tomcat.addServlet(ctx, \"nonasync\", nonasync);\n        wrapper2.setAsyncSupported(true);\n        ctx.addServletMapping(\"/stage2\", \"nonasync\");\n\n        ctx.addApplicationListener(new ApplicationListener(\n                TrackingRequestListener.class.getName(), false));\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/stage1?iter=\");\n        url.append(iter);\n        if (useThread) {\n            url.append(\"&useThread=y\");\n        }\n        ByteChunk res = getUrl(url.toString());\n\n        StringBuilder expected = new StringBuilder(\"requestInitialized-\");\n        int loop = iter;\n        while (loop > 0) {\n            expected.append(\"DispatchingServletGet-\");\n            loop--;\n        }\n        expected.append(\"NonAsyncServletGet-\");\n        expected.append(\"requestDestroyed\");\n        assertEquals(expected.toString(), res.toString());\n\n        // Check the access log\n        alv.validateAccessLog(1, 200, 0, REQUEST_TIME);\n    }",
                "    public void testListeners() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        TrackingServlet tracking = new TrackingServlet();\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"tracking\", tracking);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/stage1\", \"tracking\");\n\n        TimeoutServlet timeout = new TimeoutServlet(Boolean.TRUE, null);\n        Wrapper wrapper2 = Tomcat.addServlet(ctx, \"timeout\", timeout);\n        wrapper2.setAsyncSupported(true);\n        ctx.addServletMapping(\"/stage2\", \"timeout\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/stage1\");\n\n        ByteChunk res = getUrl(url.toString());\n\n        assertEquals(\n                \"DispatchingServletGet-DispatchingServletGet-onStartAsync-\" +\n                \"TimeoutServletGet-onStartAsync-onTimeout-onComplete-\",\n                res.toString());\n\n        // Check the access log\n        alv.validateAccessLog(1, 200, TimeoutServlet.ASYNC_TIMEOUT,\n                TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN + REQUEST_TIME);\n    }",
                "    public void testDispatchErrorDouble() throws Exception {\n        doTestDispatchError(2, false, false);\n    }\n\n    public void testDispatchErrorWithThreadSingle() throws Exception {\n        doTestDispatchError(1, true, false);\n    }\n\n    public void testDispatchErrorWithThreadDouble() throws Exception {\n        doTestDispatchError(2, true, false);\n    }",
                "    public void testDispatchErrorWithThreadMultiple() throws Exception {\n        doTestDispatchError(5, true, false);\n    }\n\n    public void testDispatchErrorDoubleThenComplete() throws Exception {\n        doTestDispatchError(2, false, true);\n    }\n\n    public void testBug50352() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        AsyncStartRunnable servlet = new AsyncStartRunnable();\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"servlet\", servlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/\");\n\n        assertEquals(\"Runnable-onComplete-\", res.toString());\n\n        // Check the access log\n        alv.validateAccessLog(1, 200, AsyncStartRunnable.THREAD_SLEEP_TIME,\n                AsyncStartRunnable.THREAD_SLEEP_TIME + REQUEST_TIME);\n    }",
                "    public void testBug50753() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        Bug50753Servlet servlet = new Bug50753Servlet();\n\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"servlet\", servlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        // Call the servlet once\n        Map<String,List<String>> headers =\n            new LinkedHashMap<String,List<String>>();\n        ByteChunk bc = new ByteChunk();\n        int rc = getUrl(\"http://localhost:\" + getPort() + \"/\", bc, headers);\n        assertEquals(200, rc);\n        assertEquals(\"OK\", bc.toString());\n        List<String> testHeader = headers.get(\"A\");\n        assertNotNull(testHeader);\n        assertEquals(1, testHeader.size());\n        assertEquals(\"xyz\",testHeader.get(0));\n\n        // Check the access log\n        alv.validateAccessLog(1, 200, Bug50753Servlet.THREAD_SLEEP_TIME,\n                Bug50753Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);\n    }",
                "    public void testErrorHandling() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        ErrorServlet error = new ErrorServlet(false);\n        Tomcat.addServlet(ctx, \"error\", error);\n        ctx.addServletMapping(\"/error\", \"error\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/error\");\n\n        int rc = getUrl(url.toString(), new ByteChunk(), null);\n\n        assertEquals(500, rc);\n\n        // Without this test may complete before access log has a chance to log\n        // the request\n        Thread.sleep(REQUEST_TIME);\n\n        // Check the access log\n        alv.validateAccessLog(1, 500, 0, REQUEST_TIME);\n    }",
                "    public void testCommitOnComplete() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        AsyncStatusServlet asyncStatusServlet =\n            new AsyncStatusServlet(HttpServletResponse.SC_BAD_REQUEST);\n        Wrapper wrapper =\n            Tomcat.addServlet(ctx, \"asyncStatusServlet\", asyncStatusServlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/asyncStatusServlet\", \"asyncStatusServlet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/asyncStatusServlet\");\n\n        int rc = getUrl(url.toString(), new ByteChunk(), null);\n\n        assertEquals(HttpServletResponse.SC_BAD_REQUEST, rc);\n\n        // Without this test may complete before access log has a chance to log\n        // the request\n        Thread.sleep(REQUEST_TIME);\n\n        // Check the access log\n        alv.validateAccessLog(1, HttpServletResponse.SC_BAD_REQUEST, 0,\n                REQUEST_TIME);\n\n    }",
                "    private void doTestBug51197(boolean threaded) throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        AsyncErrorServlet asyncErrorServlet =\n            new AsyncErrorServlet(HttpServletResponse.SC_BAD_REQUEST, threaded);\n        Wrapper wrapper =\n            Tomcat.addServlet(ctx, \"asyncErrorServlet\", asyncErrorServlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/asyncErrorServlet\", \"asyncErrorServlet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/asyncErrorServlet\");\n\n        ByteChunk res = new ByteChunk();\n        int rc = getUrl(url.toString(), res, null);\n\n        assertEquals(HttpServletResponse.SC_BAD_REQUEST, rc);\n\n        // SRV 10.9.2 - Writing the response is entirely the application's\n        // responsibility when an error occurs on an application thread.\n        // The test servlet writes no content in this case.\n        if (threaded) {\n            assertEquals(0, res.getLength());\n        } else {\n            assertTrue(res.getLength() > 0);\n        }\n\n        // Without this test may complete before access log has a chance to log\n        // the request\n        Thread.sleep(REQUEST_TIME);\n\n        // Check the access log\n        alv.validateAccessLog(1, HttpServletResponse.SC_BAD_REQUEST, 0,\n                REQUEST_TIME);\n    }",
                "    public void testBug53337() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n        Wrapper a = Tomcat.addServlet(ctx, \"ServletA\", new Bug53337ServletA());\n        a.setAsyncSupported(true);\n        Wrapper b = Tomcat.addServlet(ctx, \"ServletB\", new Bug53337ServletB());\n        b.setAsyncSupported(true);\n        Tomcat.addServlet(ctx, \"ServletC\", new Bug53337ServletC());\n        ctx.addServletMapping(\"/ServletA\", \"ServletA\");\n        ctx.addServletMapping(\"/ServletB\", \"ServletB\");\n        ctx.addServletMapping(\"/ServletC\", \"ServletC\");\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/ServletA\");\n\n        ByteChunk body = new ByteChunk();\n        int rc = getUrl(url.toString(), body, null);\n\n        assertEquals(HttpServletResponse.SC_OK, rc);\n        assertEquals(\"OK\", body.toString());\n    }",
                "    public void testBug53843() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n        Bug53843ServletA servletA = new Bug53843ServletA();\n        Wrapper a = Tomcat.addServlet(ctx, \"ServletA\", servletA);\n        a.setAsyncSupported(true);\n        Tomcat.addServlet(ctx, \"ServletB\", new Bug53843ServletB());\n\n        ctx.addServletMapping(\"/ServletA\", \"ServletA\");\n        ctx.addServletMapping(\"/ServletB\", \"ServletB\");\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/ServletA\");\n\n        ByteChunk body = new ByteChunk();\n        int rc = getUrl(url.toString(), body, null);\n\n        assertEquals(HttpServletResponse.SC_OK, rc);\n        assertEquals(\"OK\", body.toString());\n        assertTrue(servletA.isAsyncWhenExpected());\n    }\n\n    public void testTimeoutErrorDispatchNone() throws Exception {\n        doTestTimeoutErrorDispatch(null, null);\n    }\n\n    public void testTimeoutErrorDispatchNonAsync() throws Exception {\n        doTestTimeoutErrorDispatch(Boolean.FALSE, null);\n    }",
                "    public void testBug54178() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        Bug54178ServletA bug54178ServletA = new Bug54178ServletA();\n        Wrapper wrapper =\n            Tomcat.addServlet(ctx, \"bug54178ServletA\", bug54178ServletA);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/bug54178ServletA\", \"bug54178ServletA\");\n\n        Bug54178ServletB bug54178ServletB = new Bug54178ServletB();\n        Tomcat.addServlet(ctx, \"bug54178ServletB\", bug54178ServletB);\n        ctx.addServletMapping(\"/bug54178ServletB\", \"bug54178ServletB\");\n\n        tomcat.start();\n\n        ByteChunk body = new ByteChunk();\n        int rc = -1;\n\n        try {\n            rc = getUrl(\"http://localhost:\" + getPort() + \"/bug54178ServletA?\" +\n                    Bug54178ServletA.PARAM_NAME + \"=bar\",\n                    body, null);\n        } catch (IOException ioe) {\n            // This may happen if test fails. Output the exception in case it is\n            // useful and let asserts handle the failure\n            ioe.printStackTrace();\n        }\n\n        assertEquals(HttpServletResponse.SC_OK, rc);\n\n        body.recycle();\n\n        rc = getUrl(\"http://localhost:\" + getPort() + \"/bug54178ServletB\",\n                body, null);\n\n        assertEquals(HttpServletResponse.SC_OK, rc);\n        assertEquals(\"OK\", body.toString());\n    }",
                "    public void testForbiddenDispatching() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        NonAsyncServlet nonAsyncServlet = new NonAsyncServlet();\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"nonAsyncServlet\",\n                nonAsyncServlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/target\", \"nonAsyncServlet\");\n\n        DispatchingGenericServlet forbiddenDispatchingServlet = new DispatchingGenericServlet();\n        Wrapper wrapper1 = Tomcat.addServlet(ctx,\n                \"forbiddenDispatchingServlet\", forbiddenDispatchingServlet);\n        wrapper1.setAsyncSupported(true);\n        ctx.addServletMapping(\"/forbiddenDispatchingServlet\",\n                \"forbiddenDispatchingServlet\");\n\n        tomcat.start();\n\n        ByteChunk body = new ByteChunk();\n\n        try {\n            getUrl(\"http://localhost:\" + getPort()\n                    + \"/forbiddenDispatchingServlet\", body, null);\n        } catch (IOException ioe) {\n            // This may happen if test fails. Output the exception in case it is\n            // useful and let asserts handle the failure\n            ioe.printStackTrace();\n        }\n\n        assertTrue(body.toString().contains(\"OK\"));\n        assertTrue(body.toString().contains(\"NonAsyncServletGet\"));\n    }",
                "    public void testDispatchWithCustomRequestResponse() throws Exception {\n        prepareApplicationWithGenericServlet(\"\");\n\n        StringBuilder expected = new StringBuilder();\n        expected.append(\"OK\");\n        expected.append(\"CustomGenericServletGet-\");\n        requestApplicationWithGenericServlet(\"/dispatch?crr=y\", expected);\n\n        expected = new StringBuilder();\n        expected.append(\"OK\");\n        expected.append(\"DispatchingGenericServletGet-\");\n        requestApplicationWithGenericServlet(\"/dispatch?crr=y&empty=y\",\n                expected);\n    }\n\n    public void testEmptyDispatch() throws Exception {\n        prepareApplicationWithGenericServlet(\"/fo o\");\n        StringBuilder expected = new StringBuilder();\n        expected.append(\"OK\");\n        expected.append(\"DispatchingGenericServletGet-\");\n        requestApplicationWithGenericServlet(\"/fo%20o/dispatch?empty=y\",\n                expected);\n        requestApplicationWithGenericServlet(\"//fo%20o/dispatch?empty=y\",\n                expected);\n        requestApplicationWithGenericServlet(\"/./fo%20o/dispatch?empty=y\",\n                expected);\n        requestApplicationWithGenericServlet(\"/fo%20o//dispatch?empty=y\",\n                expected);\n        requestApplicationWithGenericServlet(\"/fo%20o/./dispatch?empty=y\",\n                expected);\n        requestApplicationWithGenericServlet(\"/fo%20o/c/../dispatch?empty=y\",\n                expected);\n    }",
                "    public void testEmptyDispatchWithCustomRequestResponse() throws Exception {\n        prepareApplicationWithGenericServlet(\"/fo o\");\n        StringBuilder expected = new StringBuilder();\n        expected.append(\"OK\");\n        expected.append(\"DispatchingGenericServletGet-\");\n        requestApplicationWithGenericServlet(\"/fo%20o/dispatch?crr=y&empty=y\",\n                expected);\n        requestApplicationWithGenericServlet(\"//fo%20o/dispatch?crr=y&empty=y\",\n                expected);\n        requestApplicationWithGenericServlet(\n                \"/./fo%20o/dispatch?crr=y&empty=y\", expected);\n        requestApplicationWithGenericServlet(\"/fo%20o//dispatch?crr=y&empty=y\",\n                expected);\n        requestApplicationWithGenericServlet(\n                \"/fo%20o/./dispatch?crr=y&empty=y\", expected);\n        requestApplicationWithGenericServlet(\n                \"/fo%20o/c/../dispatch?crr=y&empty=y\", expected);\n    }"
            ],
            "java\\org\\apache\\catalina\\valves\\CometConnectionManagerValve.java": [
                "    protected synchronized void startInternal() throws LifecycleException {\n\n        if (container instanceof Context) {\n            container.addLifecycleListener(this);\n        }\n\n        setState(LifecycleState.STARTING);\n    }\n\n    protected synchronized void stopInternal() throws LifecycleException {\n\n        setState(LifecycleState.STOPPING);\n\n        if (container instanceof Context) {\n            container.removeLifecycleListener(this);\n        }\n    }",
                "    public void lifecycleEvent(LifecycleEvent event) {\n        if (Lifecycle.BEFORE_STOP_EVENT.equals(event.getType())) {\n            // The container is getting stopped, close all current connections\n            Iterator<Request> iterator = cometRequests.iterator();\n            while (iterator.hasNext()) {\n                Request request = iterator.next();\n                // Remove the session tracking attribute as it isn't\n                // serializable or required.\n                HttpSession session = request.getSession(false);\n                if (session != null) {\n                    session.removeAttribute(cometRequestsAttribute);\n                }\n                // Close the comet connection\n                CometEventImpl cometEvent = request.getEvent();\n                try {\n                    cometEvent.setEventType(CometEvent.EventType.END);\n                    cometEvent.setEventSubType(\n                            CometEvent.EventSubType.WEBAPP_RELOAD);\n                    getNext().event(request, request.getResponse(), cometEvent);\n                } catch (Exception e) {\n                    container.getLogger().warn(\n                            sm.getString(\"cometConnectionManagerValve.event\"),\n                            e);\n                } finally {\n                    try {\n                        cometEvent.close();\n                    } catch (IOException e) {\n                        container.getLogger().warn(sm.getString(\n                                \"cometConnectionManagerValve.event\"), e);\n                    }\n                }\n            }\n            cometRequests.clear();\n        }\n    }",
                "    public void sessionDestroyed(HttpSessionEvent se) {\n        // Close all Comet connections associated with this session\n        Request[] reqs = (Request[])\n            se.getSession().getAttribute(cometRequestsAttribute);\n        if (reqs != null) {\n            for (int i = 0; i < reqs.length; i++) {\n                Request req = reqs[i];\n                try {\n                    CometEventImpl event = req.getEvent();\n                    event.setEventType(CometEvent.EventType.END);\n                    event.setEventSubType(CometEvent.EventSubType.SESSION_END);\n                    ((CometProcessor)\n                            req.getWrapper().getServlet()).event(event);\n                    event.close();\n                } catch (Exception e) {\n                    req.getWrapper().getParent().getLogger().warn(sm.getString(\n                            \"cometConnectionManagerValve.listenerEvent\"), e);\n                }\n            }\n        }\n    }"
            ],
            "java\\org\\apache\\catalina\\valves\\RemoteIpValve.java": [
                "    protected static String listToCommaDelimitedString(List<String> stringList) {\n        if (stringList == null) {\n            return \"\";\n        }\n        StringBuilder result = new StringBuilder();\n        for (Iterator<String> it = stringList.iterator(); it.hasNext();) {\n            Object element = it.next();\n            if (element != null) {\n                result.append(element);\n                if (it.hasNext()) {\n                    result.append(\", \");\n                }\n            }\n        }\n        return result.toString();\n    }",
                "    public void invoke(Request request, Response response) throws IOException, ServletException {\n        final String originalRemoteAddr = request.getRemoteAddr();\n        final String originalRemoteHost = request.getRemoteHost();\n        final String originalScheme = request.getScheme();\n        final boolean originalSecure = request.isSecure();\n        final int originalServerPort = request.getServerPort();\n\n        if (internalProxies !=null &&\n                internalProxies.matcher(originalRemoteAddr).matches()) {\n            String remoteIp = null;\n            // In java 6, proxiesHeaderValue should be declared as a java.util.Deque\n            LinkedList<String> proxiesHeaderValue = new LinkedList<String>();\n            StringBuilder concatRemoteIpHeaderValue = new StringBuilder();\n\n            for (Enumeration<String> e = request.getHeaders(remoteIpHeader); e.hasMoreElements();) {\n                if (concatRemoteIpHeaderValue.length() > 0) {\n                    concatRemoteIpHeaderValue.append(\", \");\n                }\n\n                concatRemoteIpHeaderValue.append(e.nextElement());\n            }\n\n            String[] remoteIpHeaderValue = commaDelimitedListToStringArray(concatRemoteIpHeaderValue.toString());\n            int idx;\n            // loop on remoteIpHeaderValue to find the first trusted remote ip and to build the proxies chain\n            for (idx = remoteIpHeaderValue.length - 1; idx >= 0; idx--) {\n                String currentRemoteIp = remoteIpHeaderValue[idx];\n                remoteIp = currentRemoteIp;\n                if (internalProxies.matcher(currentRemoteIp).matches()) {\n                    // do nothing, internalProxies IPs are not appended to the\n                } else if (trustedProxies != null &&\n                        trustedProxies.matcher(currentRemoteIp).matches()) {\n                    proxiesHeaderValue.addFirst(currentRemoteIp);\n                } else {\n                    idx--; // decrement idx because break statement doesn't do it\n                    break;\n                }\n            }\n            // continue to loop on remoteIpHeaderValue to build the new value of the remoteIpHeader\n            LinkedList<String> newRemoteIpHeaderValue = new LinkedList<String>();\n            for (; idx >= 0; idx--) {\n                String currentRemoteIp = remoteIpHeaderValue[idx];\n                newRemoteIpHeaderValue.addFirst(currentRemoteIp);\n            }\n            if (remoteIp != null) {\n\n                request.setRemoteAddr(remoteIp);\n                request.setRemoteHost(remoteIp);\n\n                // use request.coyoteRequest.mimeHeaders.setValue(str).setString(str) because request.addHeader(str, str) is no-op in Tomcat\n                // 6.0\n                if (proxiesHeaderValue.size() == 0) {\n                    request.getCoyoteRequest().getMimeHeaders().removeHeader(proxiesHeader);\n                } else {\n                    String commaDelimitedListOfProxies = listToCommaDelimitedString(proxiesHeaderValue);\n                    request.getCoyoteRequest().getMimeHeaders().setValue(proxiesHeader).setString(commaDelimitedListOfProxies);\n                }\n                if (newRemoteIpHeaderValue.size() == 0) {\n                    request.getCoyoteRequest().getMimeHeaders().removeHeader(remoteIpHeader);\n                } else {\n                    String commaDelimitedRemoteIpHeaderValue = listToCommaDelimitedString(newRemoteIpHeaderValue);\n                    request.getCoyoteRequest().getMimeHeaders().setValue(remoteIpHeader).setString(commaDelimitedRemoteIpHeaderValue);\n                }\n            }\n\n            if (protocolHeader != null) {\n                String protocolHeaderValue = request.getHeader(protocolHeader);\n                if (protocolHeaderValue == null) {\n                    // don't modify the secure,scheme and serverPort attributes\n                    // of the request\n                } else if (protocolHeaderHttpsValue.equalsIgnoreCase(protocolHeaderValue)) {\n                    request.setSecure(true);\n                    // use request.coyoteRequest.scheme instead of request.setScheme() because request.setScheme() is no-op in Tomcat 6.0\n                    request.getCoyoteRequest().scheme().setString(\"https\");\n\n                    setPorts(request, httpsServerPort);\n                } else {\n                    request.setSecure(false);\n                    // use request.coyoteRequest.scheme instead of request.setScheme() because request.setScheme() is no-op in Tomcat 6.0\n                    request.getCoyoteRequest().scheme().setString(\"http\");\n\n                    setPorts(request, httpServerPort);\n                }\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Incoming request \" + request.getRequestURI() + \" with originalRemoteAddr '\" + originalRemoteAddr\n                          + \"', originalRemoteHost='\" + originalRemoteHost + \"', originalSecure='\" + originalSecure + \"', originalScheme='\"\n                          + originalScheme + \"' will be seen as newRemoteAddr='\" + request.getRemoteAddr() + \"', newRemoteHost='\"\n                          + request.getRemoteHost() + \"', newScheme='\" + request.getScheme() + \"', newSecure='\" + request.isSecure() + \"'\");\n            }\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Skip RemoteIpValve for request \" + request.getRequestURI() + \" with originalRemoteAddr '\"\n                        + request.getRemoteAddr() + \"'\");\n            }\n        }\n        if (requestAttributesEnabled) {\n            request.setAttribute(AccessLog.REMOTE_ADDR_ATTRIBUTE,\n                    request.getRemoteAddr());\n            request.setAttribute(Globals.REMOTE_ADDR_ATTRIBUTE,\n                    request.getRemoteAddr());\n            request.setAttribute(AccessLog.REMOTE_HOST_ATTRIBUTE,\n                    request.getRemoteHost());\n            request.setAttribute(AccessLog.PROTOCOL_ATTRIBUTE,\n                    request.getProtocol());\n            request.setAttribute(AccessLog.SERVER_PORT_ATTRIBUTE,\n                    Integer.valueOf(request.getServerPort()));\n        }\n        try {\n            getNext().invoke(request, response);\n        } finally {\n            request.setRemoteAddr(originalRemoteAddr);\n            request.setRemoteHost(originalRemoteHost);\n\n            request.setSecure(originalSecure);\n\n            // use request.coyoteRequest.scheme instead of request.setScheme() because request.setScheme() is no-op in Tomcat 6.0\n            request.getCoyoteRequest().scheme().setString(originalScheme);\n\n            request.setServerPort(originalServerPort);\n        }\n    }"
            ],
            "java\\org\\apache\\catalina\\mbeans\\MBeanDumper.java": [
                "    public static String escape(String value) {\n        // The only invalid char is \\n\n        // We also need to keep the string short and split it with \\nSPACE\n        // XXX TODO\n        int idx=value.indexOf( \"\\n\" );\n        if( idx < 0 ) return value;\n\n        int prev=0;\n        StringBuilder sb=new StringBuilder();\n        while( idx >= 0 ) {\n            appendHead(sb, value, prev, idx);\n\n            sb.append( \"\\\\n\\n \");\n            prev=idx+1;\n            if( idx==value.length() -1 ) break;\n            idx=value.indexOf('\\n', idx+1);\n        }\n        if( prev < value.length() )\n            appendHead( sb, value, prev, value.length());\n        return sb.toString();\n    }"
            ],
            "test\\org\\apache\\catalina\\startup\\TomcatBaseTest.java": [
                "    public void tearDown() throws Exception {\n        try {\n            // Some tests may call tomcat.destroy(), some tests may just call\n            // tomcat.stop(), some not call either method. Make sure that stop()\n            // & destroy() are called as necessary.\n            if (tomcat.server != null\n                    && tomcat.server.getState() != LifecycleState.DESTROYED) {\n                if (tomcat.server.getState() != LifecycleState.STOPPED) {\n                    tomcat.stop();\n                }\n                tomcat.destroy();\n            }\n        } finally {\n            super.tearDown();\n        }\n    }"
            ]
        }
    },
    "55978": {
        "summary": "Bug 55978 Initial call to onWritePossible() not made by container when using HTTP upgrade",
        "code_segments": {
            "java\\org\\apache\\tomcat\\websocket\\server\\WsHttpUpgradeHandler.java": [
                "    public void init(WebConnection connection) {\n        if (ep == null) {\n            throw new IllegalStateException(\n                    sm.getString(\"wsHttpUpgradeHandler.noPreInit\"));\n        }\n\n        this.connection = connection;\n\n        AbstractServletInputStream sis;\n        AbstractServletOutputStream sos;\n        try {\n            sis = connection.getInputStream();\n            sos = connection.getOutputStream();\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n\n        String httpSessionId = null;\n        Object session = handshakeRequest.getHttpSession();\n        if (session != null ) {\n            httpSessionId = ((HttpSession) session).getId();\n        }\n\n        // Need to call onOpen using the web application's class loader\n        // Create the frame using the application's class loader so it can pick\n        // up application specific config from the ServerContainerImpl\n        Thread t = Thread.currentThread();\n        ClassLoader cl = t.getContextClassLoader();\n        t.setContextClassLoader(applicationClassLoader);\n        try {\n            WsRemoteEndpointImplServer wsRemoteEndpointServer =\n                    new WsRemoteEndpointImplServer(sos, webSocketContainer);\n            wsSession = new WsSession(ep, wsRemoteEndpointServer,\n                    webSocketContainer, handshakeRequest.getRequestURI(),\n                    handshakeRequest.getParameterMap(),\n                    handshakeRequest.getQueryString(),\n                    handshakeRequest.getUserPrincipal(), httpSessionId,\n                    subProtocol, pathParameters, secure, endpointConfig);\n            WsFrameServer wsFrame = new WsFrameServer(\n                    sis,\n                    wsSession);\n            sos.setWriteListener(\n                    new WsWriteListener(this, wsRemoteEndpointServer));\n            ep.onOpen(wsSession, endpointConfig);\n            webSocketContainer.registerSession(ep, wsSession);\n            sis.setReadListener(new WsReadListener(this, wsFrame));\n        } catch (DeploymentException e) {\n            throw new IllegalArgumentException(e);\n        } finally {\n            t.setContextClassLoader(cl);\n        }\n    }",
                "    public void destroy() {\n        if (connection != null) {\n            try {\n                connection.close();\n            } catch (Exception e) {\n                log.error(sm.getString(\"wsHttpUpgradeHandler.destroyFailed\"), e);\n            }\n        }\n    }\n\n    private void onError(Throwable throwable) {\n        // Need to call onError using the web application's class loader\n        Thread t = Thread.currentThread();\n        ClassLoader cl = t.getContextClassLoader();\n        t.setContextClassLoader(applicationClassLoader);\n        try {\n            ep.onError(wsSession, throwable);\n        } finally {\n            t.setContextClassLoader(cl);\n        }\n    }\n\n    private void close(CloseReason cr) {\n        /*\n         * Any call to this method is a result of a problem reading from the\n         * client. At this point that state of the connection is unknown.\n         * Attempt to send a close frame to the client and then close the socket\n         * immediately. There is no point in waiting for a close frame from the\n         * client because there is no guarantee that we can recover from\n         * whatever messed up state the client put the connection into.\n         */\n        wsSession.onClose(cr);\n    }"
            ],
            "test\\org\\apache\\catalina\\startup\\TestListener.java": [
                "    public void testServletContainerInitializer() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        Context context = tomcat.addContext(\"/\",\n                System.getProperty(\"java.io.tmpdir\"));\n\n        context.addServletContainerInitializer(new SCI(), null);\n        tomcat.start();\n        assertTrue(SCL.initialized);\n    }\n\n    public void testServletContextListener() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        Context context = tomcat.addContext(\"/\",\n                System.getProperty(\"java.io.tmpdir\"));\n\n        // SCL2 pretends to be in web.xml, and tries to install a\n        // ServletContainerInitializer.\n        context.addApplicationListener(new ApplicationListener(\n                SCL2.class.getName(), false));\n        tomcat.start();\n\n        //check that the ServletContainerInitializer wasn't initialized.\n        assertFalse(SCL3.initialized);\n    }"
            ],
            "java\\org\\apache\\coyote\\http11\\upgrade\\AbstractServletOutputStream.java": [
                "    public final boolean isReady() {\n        if (listener == null) {\n            throw new IllegalStateException(\n                    sm.getString(\"upgrade.sos.canWrite.is\"));\n        }\n\n        // Make sure isReady() and onWritePossible() have a consistent view of\n        // buffer and fireListener when determining if the listener should fire\n        synchronized (fireListenerLock) {\n            boolean result = (buffer == null);\n            fireListener = !result;\n            return result;\n        }\n    }\n\n    public void write(int b) throws IOException {\n        synchronized (writeLock) {\n            preWriteChecks();\n            writeInternal(new byte[] { (byte) b }, 0, 1);\n        }\n    }\n\n    public void write(byte[] b, int off, int len) throws IOException {\n        synchronized (writeLock) {\n            preWriteChecks();\n            writeInternal(b, off, len);\n        }\n    }",
                "    public void close() throws IOException {\n        closeRequired = true;\n        doClose();\n    }\n\n    private void preWriteChecks() {\n        if (buffer != null) {\n            throw new IllegalStateException(\n                    sm.getString(\"upgrade.sis.write.ise\"));\n        }\n    }\n\n    private void writeInternal(byte[] b, int off, int len) throws IOException {\n        if (listener == null) {\n            // Simple case - blocking IO\n            doWrite(true, b, off, len);\n        } else {\n            // Non-blocking IO\n            // If the non-blocking read does not complete, doWrite() will add\n            // the socket back into the poller. The poller may trigger a new\n            // write event before this method has finished updating buffer. The\n            // writeLock sync makes sure that buffer is updated before the next\n            // write executes.\n            int written = doWrite(false, b, off, len);\n            if (written < len) {\n                // TODO: - Reuse the buffer\n                //       - Only reallocate if it gets too big (>8k?)\n                buffer = new byte[len - written];\n                System.arraycopy(b, off + written, buffer, 0, len - written);\n            } else {\n                buffer = null;\n            }\n        }\n    }",
                "    protected final void onWritePossible() throws IOException {\n        synchronized (writeLock) {\n            try {\n                writeInternal(buffer, 0, buffer.length);\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                Thread thread = Thread.currentThread();\n                ClassLoader originalClassLoader = thread.getContextClassLoader();\n                try {\n                    thread.setContextClassLoader(applicationLoader);\n                    listener.onError(t);\n                } finally {\n                    thread.setContextClassLoader(originalClassLoader);\n                }\n                if (t instanceof IOException) {\n                    throw (IOException) t;\n                } else {\n                    throw new IOException(t);\n                }\n            }\n\n           // Make sure isReady() and onWritePossible() have a consistent view of\n            // buffer and fireListener when determining if the listener should fire\n            boolean fire = false;\n\n            synchronized (fireListenerLock) {\n                if (buffer == null && fireListener) {\n                    fireListener = false;\n                    fire = true;\n                }\n            }\n            if (fire) {\n                Thread thread = Thread.currentThread();\n                ClassLoader originalClassLoader = thread.getContextClassLoader();\n                try {\n                    thread.setContextClassLoader(applicationLoader);\n                    listener.onWritePossible();\n                } finally {\n                    thread.setContextClassLoader(originalClassLoader);\n                }\n            }\n        }\n    }",
                "    protected abstract void doFlush() throws IOException;\n\n    protected abstract void doClose() throws IOException;"
            ],
            "java\\org\\apache\\coyote\\http11\\upgrade\\AbstractServletInputStream.java": [
                "    public final boolean isFinished() {\n        if (listener == null) {\n            throw new IllegalStateException(\n                    sm.getString(\"upgrade.sis.isFinished.ise\"));\n        }\n        // The only way to finish an HTTP Upgrade connection is to close the\n        // socket.\n        return false;\n    }\n\n    public final boolean isReady() {\n        if (listener == null) {\n            throw new IllegalStateException(\n                    sm.getString(\"upgrade.sis.isReady.ise\"));\n        }\n\n        // If we already know the current state, return it.\n        if (ready != null) {\n            return ready.booleanValue();\n        }\n\n        try {\n            ready = Boolean.valueOf(doIsReady());\n        } catch (IOException e) {\n            Thread thread = Thread.currentThread();\n            ClassLoader originalClassLoader = thread.getContextClassLoader();\n            try {\n                thread.setContextClassLoader(applicationLoader);\n                listener.onError(e);\n            } finally {\n                thread.setContextClassLoader(originalClassLoader);\n            }\n            ready = Boolean.FALSE;\n        }\n        return ready.booleanValue();\n    }\n\n    public final int read() throws IOException {\n        preReadChecks();\n\n        return readInternal();\n    }",
                "    public final int readLine(byte[] b, int off, int len) throws IOException {\n        preReadChecks();\n\n        if (len <= 0) {\n            return 0;\n        }\n        int count = 0, c;\n\n        while ((c = readInternal()) != -1) {\n            b[off++] = (byte) c;\n            count++;\n            if (c == '\\n' || count == len) {\n                break;\n            }\n        }\n        return count > 0 ? count : -1;\n    }\n\n    public final int read(byte[] b, int off, int len) throws IOException {\n        preReadChecks();\n\n        try {\n            return doRead(listener == null, b, off, len);\n        } catch (IOException ioe) {\n            closeRequired = true;\n            throw ioe;\n        }\n    }\n\n    public void close() throws IOException {\n        closeRequired = true;\n        doClose();\n    }",
                "    private void preReadChecks() {\n        if (listener != null && (ready == null || !ready.booleanValue())) {\n            throw new IllegalStateException(\n                    sm.getString(\"upgrade.sis.read.ise\"));\n        }\n        // No longer know if data is available\n        ready = null;\n    }\n\n    private int readInternal() throws IOException {\n        // Single byte reads for non-blocking need special handling so all\n        // single byte reads run through this method.\n        byte[] b = new byte[1];\n        int result;\n        try {\n            result = doRead(listener == null, b, 0, 1);\n        } catch (IOException ioe) {\n            closeRequired = true;\n            throw ioe;\n        }\n        if (result == 0) {\n            return -1;\n        } else if (result == -1) {\n            // Will never happen with a network socket. An IOException will be\n            // thrown when the client closes the connection.\n            // Echo back the -1 to be safe.\n            return -1;\n        } else {\n            return b[0] & 0xFF;\n        }\n    }",
                "    protected final void onDataAvailable() throws IOException {\n        ready = Boolean.TRUE;\n        Thread thread = Thread.currentThread();\n        ClassLoader originalClassLoader = thread.getContextClassLoader();\n        try {\n            thread.setContextClassLoader(applicationLoader);\n            listener.onDataAvailable();\n        } finally {\n            thread.setContextClassLoader(originalClassLoader);\n        }\n    }\n\n    protected abstract boolean doIsReady() throws IOException;\n\n    protected abstract void doClose() throws IOException;"
            ],
            "java\\org\\apache\\tomcat\\util\\net\\NioSelectorPool.java": [
                "    public void put(Selector s) throws IOException {\n        if ( SHARED ) return;\n        if ( enabled ) active.decrementAndGet();\n        if ( enabled && (maxSpareSelectors==-1 || spare.get() < Math.min(maxSpareSelectors,maxSelectors)) ) {\n            spare.incrementAndGet();\n            selectors.offer(s);\n        }\n        else s.close();\n    }\n\n    public void close() throws IOException {\n        enabled = false;\n        Selector s;\n        while ( (s = selectors.poll()) != null ) s.close();\n        spare.set(0);\n        active.set(0);\n        if (blockingSelector!=null) {\n            blockingSelector.close();\n        }\n        if ( SHARED && getSharedSelector()!=null ) {\n            getSharedSelector().close();\n            SHARED_SELECTOR = null;\n        }\n    }\n\n    public void open() throws IOException {\n        enabled = true;\n        getSharedSelector();\n        if (SHARED) {\n            blockingSelector = new NioBlockingSelector();\n            blockingSelector.open(getSharedSelector());\n        }\n\n    }",
                "    public int write(ByteBuffer buf, NioChannel socket, Selector selector, long writeTimeout) throws IOException {\n        return write(buf,socket,selector,writeTimeout,true);\n    }\n\n    public int read(ByteBuffer buf, NioChannel socket, Selector selector, long readTimeout) throws IOException {\n        return read(buf,socket,selector,readTimeout,true);\n    }",
                "    public int read(ByteBuffer buf, NioChannel socket, Selector selector, long readTimeout, boolean block) throws IOException {\n        if ( SHARED && block ) {\n            return blockingSelector.read(buf,socket,readTimeout);\n        }\n        SelectionKey key = null;\n        int read = 0;\n        boolean timedout = false;\n        int keycount = 1; //assume we can write\n        long time = System.currentTimeMillis(); //start the timeout timer\n        try {\n            while ( (!timedout) ) {\n                int cnt = 0;\n                if ( keycount > 0 ) { //only read if we were registered for a read\n                    cnt = socket.read(buf);\n                    if (cnt == -1) throw new EOFException();\n                    read += cnt;\n                    if (cnt > 0) continue; //read some more\n                    if (cnt==0 && (read>0 || (!block) ) ) break; //we are done reading\n                }\n                if ( selector != null ) {//perform a blocking read\n                    //register OP_WRITE to the selector\n                    if (key==null) key = socket.getIOChannel().register(selector, SelectionKey.OP_READ);\n                    else key.interestOps(SelectionKey.OP_READ);\n                    keycount = selector.select(readTimeout);\n                }\n                if (readTimeout > 0 && (selector == null || keycount == 0) ) timedout = (System.currentTimeMillis()-time)>=readTimeout;\n            }//while\n            if ( timedout ) throw new SocketTimeoutException();\n        } finally {\n            if (key != null) {\n                key.cancel();\n                if (selector != null) selector.selectNow();//removes the key from this selector\n            }\n        }\n        return read;\n    }"
            ],
            "java\\org\\apache\\catalina\\core\\JasperListener.java": [
                "    public void lifecycleEvent(LifecycleEvent event) {\n\n        if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {\n            try {\n                // Set JSP factory\n                Class.forName(\"org.apache.jasper.compiler.JspRuntimeContext\",\n                              true,\n                              this.getClass().getClassLoader());\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                // Should not occur, obviously\n                log.warn(\"Couldn't initialize Jasper\", t);\n            }\n            // Another possibility is to do directly:\n            // JspFactory.setDefaultFactory(new JspFactoryImpl());\n        }\n\n    }"
            ],
            "java\\org\\apache\\tomcat\\util\\net\\SocketWrapper.java": [
                "    public void reset(E socket, long timeout) {\n        async = false;\n        blockingStatus = true;\n        comet = false;\n        error = false;\n        keepAliveLeft = 100;\n        lastAccess = System.currentTimeMillis();\n        this.socket = socket;\n        this.timeout = timeout;\n        upgraded = false;\n    }"
            ],
            "java\\org\\apache\\tomcat\\websocket\\server\\WsRemoteEndpointImplServer.java": [
                "    protected void doWrite(SendHandler handler, ByteBuffer... buffers) {\n        this.handler = handler;\n        this.buffers = buffers;\n        // This is definitely the same thread that triggered the write so a\n        // dispatch will be required.\n        onWritePossible(true);\n    }",
                "    public void onWritePossible(boolean useDispatch) {\n        boolean complete = true;\n        try {\n            // If this is false there will be a call back when it is true\n            while (sos.isReady()) {\n                complete = true;\n                for (ByteBuffer buffer : buffers) {\n                    if (buffer.hasRemaining()) {\n                        complete = false;\n                        sos.write(buffer.array(), buffer.arrayOffset(),\n                                buffer.limit());\n                        buffer.position(buffer.limit());\n                        break;\n                    }\n                }\n                if (complete) {\n                    wsWriteTimeout.unregister(this);\n                    clearHandler(null, useDispatch);\n                    if (close) {\n                        close();\n                    }\n                    break;\n                }\n            }\n\n        } catch (IOException ioe) {\n            wsWriteTimeout.unregister(this);\n            clearHandler(ioe, useDispatch);\n            close();\n        }\n        if (!complete) {\n            // Async write is in progress\n\n            long timeout = getSendTimeout();\n            if (timeout > 0) {\n                // Register with timeout thread\n                timeoutExpiry = timeout + System.currentTimeMillis();\n                wsWriteTimeout.register(this);\n            }\n        }\n    }",
                "    protected void doClose() {\n        if (handler != null) {\n            // close() can be triggered by a wide range of scenarios. It is far\n            // simpler just to always use a dispatch than it is to try and track\n            // whether or not this method was called by the same thread that\n            // triggered the write\n            clearHandler(new EOFException(), true);\n        }\n        try {\n            sos.close();\n        } catch (IOException e) {\n            if (log.isInfoEnabled()) {\n                log.info(sm.getString(\"wsRemoteEndpointServer.closeFailed\"), e);\n            }\n        }\n        wsWriteTimeout.unregister(this);\n    }\n\n    protected void onTimeout(boolean useDispatch) {\n        if (handler != null) {\n            clearHandler(new SocketTimeoutException(), useDispatch);\n        }\n        close();\n    }",
                "    private void clearHandler(Throwable t, boolean useDispatch) {\n        // Setting the result marks this (partial) message as\n        // complete which means the next one may be sent which\n        // could update the value of the handler. Therefore, keep a\n        // local copy before signalling the end of the (partial)\n        // message.\n        SendHandler sh = handler;\n        handler = null;\n        if (sh != null) {\n            if (useDispatch) {\n                OnResultRunnable r = onResultRunnables.poll();\n                if (r == null) {\n                    r = new OnResultRunnable(onResultRunnables);\n                }\n                r.init(sh, t);\n                if (executorService == null || executorService.isShutdown()) {\n                    // Can't use the executor so call the runnable directly.\n                    // This may not be strictly specification compliant in all\n                    // cases but during shutdown only close messages are going\n                    // to be sent so there should not be the issue of nested\n                    // calls leading to stack overflow as described in bug\n                    // 55715. The issues with nested calls was the reason for\n                    // the separate thread requirement in the specification.\n                    r.run();\n                } else {\n                    executorService.execute(r);\n                }\n            } else {\n                if (t == null) {\n                    sh.onResult(new SendResult());\n                } else {\n                    sh.onResult(new SendResult(t));\n                }\n            }\n        }\n    }"
            ],
            "modules\\jdbc-pool\\src\\test\\java\\org\\apache\\tomcat\\jdbc\\test\\Bug50805.java": [
                "    public void test50805() throws Exception {\n        this.datasource.setInitialSize(0);\n        this.datasource.setMaxActive(10);\n        this.datasource.setMinIdle(1);\n\n        Assert.assertEquals(\"Current size should be 0.\", 0, this.datasource.getSize());\n\n        this.datasource.getConnection().close();\n\n        Assert.assertEquals(\"Current size should be 1.\", 1, this.datasource.getSize());\n        Assert.assertEquals(\"Idle size should be 1.\", 1, this.datasource.getIdle());\n        Assert.assertEquals(\"Busy size should be 0.\", 0, this.datasource.getActive());\n\n        Future<Connection> fc = this.datasource.getConnectionAsync();\n\n        Connection con = fc.get();\n\n        Assert.assertEquals(\"Current size should be 1.\", 1, this.datasource.getSize());\n        Assert.assertEquals(\"Idle size should be 0.\", 0, this.datasource.getIdle());\n        Assert.assertEquals(\"Busy size should be 1.\", 1, this.datasource.getActive());\n\n        con.close();\n        Assert.assertEquals(\"Current size should be 1.\", 1, this.datasource.getSize());\n        Assert.assertEquals(\"Idle size should be 1.\", 1, this.datasource.getIdle());\n        Assert.assertEquals(\"Busy size should be 0.\", 0, this.datasource.getActive());\n    }"
            ],
            "java\\org\\apache\\coyote\\AbstractProcessor.java": [
                "    public abstract SocketState event(SocketStatus status) throws IOException;\n\n    public abstract SocketState upgradeDispatch() throws IOException;"
            ],
            "test\\org\\apache\\coyote\\http11\\filters\\TestFlushableGZIPOutputStream.java": [
                "    public void testBug52121() throws Exception {\n\n        ByteArrayOutputStream byteOutStream = new ByteArrayOutputStream();\n        OutputStream output = new FlushableGZIPOutputStream(byteOutStream);\n\n        File sourcesDir = new File(\"test/org/apache/coyote/http11/filters/\");\n        List<byte[]> parts = new ArrayList<byte[]>();\n        byte[] part;\n\n        part = loadFile(new File(sourcesDir, \"bug52121-part1\"));\n        parts.add(part);\n        flowBytes(part, output);\n        output.flush();\n\n        part = loadFile(new File(sourcesDir, \"bug52121-part2\"));\n        parts.add(part);\n        flowBytes(part, output);\n        output.flush();\n\n        part = \"data2\".getBytes(\"ASCII\");\n        parts.add(part);\n        output.write(part);\n        output.flush();\n\n        output.close();\n\n        ByteArrayInputStream byteInStream =\n                new ByteArrayInputStream(byteOutStream.toByteArray());\n\n        GZIPInputStream inflaterStream = new GZIPInputStream(byteInStream);\n        ByteArrayOutputStream sink = new ByteArrayOutputStream();\n        try {\n            IOTools.flow(inflaterStream, sink);\n        } finally {\n            sink.close();\n        }\n\n        byte[] decompressedBytes = sink.toByteArray();\n        int originalLength = 0;\n        for (byte[] bytes : parts) {\n            assertArrayEquals(bytes, Arrays.copyOfRange(decompressedBytes,\n                    originalLength, originalLength + bytes.length));\n            originalLength += bytes.length;\n        }\n        assertEquals(originalLength, decompressedBytes.length);\n    }",
                "    public void testWriteChar() throws Exception {\n        String phrase = \"Apache Tomcat \"\n                + \"\\u0410\\u043f\\u0430\\u0447\\u0435 \\u0422\\u043e\\u043c\\u043a\\u0430\\u0442 \";\n        byte[] data = phrase.getBytes(\"UTF-8\");\n\n        ByteArrayOutputStream byteOutStream = new ByteArrayOutputStream();\n        OutputStream output = new FlushableGZIPOutputStream(byteOutStream);\n\n        output.write(data);\n        for (int i=0; i<data.length; i++) {\n            output.write(data[i]);\n        }\n        output.flush();\n        for (int i=0; i<data.length; i++) {\n            output.write(data[i]);\n        }\n        output.write(data);\n        output.close();\n\n        ByteArrayInputStream byteInStream =\n                new ByteArrayInputStream(byteOutStream.toByteArray());\n\n        GZIPInputStream inflaterStream = new GZIPInputStream(byteInStream);\n        ByteArrayOutputStream sink = new ByteArrayOutputStream();\n        try {\n            IOTools.flow(inflaterStream, sink);\n        } finally {\n            sink.close();\n        }\n\n        byte[] decompressedBytes = sink.toByteArray();\n        assertEquals(data.length * 4, decompressedBytes.length);\n        for (int i = 0; i < 4; i++) {\n            assertArrayEquals(data, Arrays.copyOfRange(decompressedBytes,\n                    data.length * i, data.length * (i + 1)));\n        }\n    }",
                "    private byte[] loadFile(File file) throws IOException {\n        ByteArrayOutputStream byteOutStream = new ByteArrayOutputStream();\n        FileInputStream input = new FileInputStream(file);\n        try {\n            IOTools.flow(input, byteOutStream);\n        } finally {\n            input.close();\n        }\n        return byteOutStream.toByteArray();\n    }"
            ],
            "java\\org\\apache\\tomcat\\websocket\\WsWebSocketContainer.java": [
                "    protected void registerSession(Endpoint endpoint, WsSession wsSession) {\n\n        Class<?> endpointClazz = endpoint.getClass();\n\n        if (!wsSession.isOpen()) {\n            // The session was closed during onOpen. No need to register it.\n            return;\n        }\n        synchronized (endPointSessionMapLock) {\n            if (endpointSessionMap.size() == 0) {\n                BackgroundProcessManager.getInstance().register(this);\n            }\n            Set<WsSession> wsSessions = endpointSessionMap.get(endpointClazz);\n            if (wsSessions == null) {\n                wsSessions = new HashSet<WsSession>();\n                endpointSessionMap.put(endpointClazz, wsSessions);\n            }\n            wsSessions.add(wsSession);\n        }\n        sessions.put(wsSession, wsSession);\n    }\n\n    protected void unregisterSession(Endpoint endpoint, WsSession wsSession) {\n\n        Class<?> endpointClazz = endpoint.getClass();\n\n        synchronized (endPointSessionMapLock) {\n            Set<WsSession> wsSessions = endpointSessionMap.get(endpointClazz);\n            if (wsSessions != null) {\n                wsSessions.remove(wsSession);\n                if (wsSessions.size() == 0) {\n                    endpointSessionMap.remove(endpointClazz);\n                }\n            }\n            if (endpointSessionMap.size() == 0) {\n                BackgroundProcessManager.getInstance().unregister(this);\n            }\n        }\n        sessions.remove(wsSession);\n    }",
                "    private List<String> generateExtensionHeaders(List<Extension> extensions) {\n        List<String> result = new ArrayList<String>(extensions.size());\n        for (Extension extension : extensions) {\n            StringBuilder header = new StringBuilder();\n            header.append(extension.getName());\n            for (Extension.Parameter param : extension.getParameters()) {\n                header.append(';');\n                header.append(param.getName());\n                String value = param.getValue();\n                if (value != null && value.length() > 0) {\n                    header.append('=');\n                    header.append(value);\n                }\n            }\n        }\n        return result;\n    }\n\n    private void parseStatus(String line) throws DeploymentException {\n        // This client only understands HTTP 1.1\n        // RFC2616 is case specific\n        if (!line.startsWith(\"HTTP/1.1 101\")) {\n            throw new DeploymentException(sm.getString(\n                    \"wsWebSocketContainer.invalidStatus\", line));\n        }\n    }",
                "    private void parseHeaders(String line, Map<String,List<String>> headers) {\n        // Treat headers as single values by default.\n\n        int index = line.indexOf(':');\n        if (index == -1) {\n            log.warn(sm.getString(\"wsWebSocketContainer.invalidHeader\", line));\n            return;\n        }\n        // Header names are case insensitive so always use lower case\n        String headerName = line.substring(0, index).trim().toLowerCase();\n        // TODO handle known multi-value headers\n        String headerValue = line.substring(index + 1).trim();\n\n        List<String> values = headers.get(headerName);\n        if (values == null) {\n            values = new ArrayList<String>(1);\n            headers.put(headerName, values);\n        }\n        values.add(headerValue);\n    }\n\n    private String readLine(ByteBuffer response) {\n        // All ISO-8859-1\n        StringBuilder sb = new StringBuilder();\n\n        char c = 0;\n        while (response.hasRemaining()) {\n            c = (char) response.get();\n            sb.append(c);\n            if (c == 10) {\n                break;\n            }\n        }\n\n        return sb.toString();\n    }",
                "    public void destroy() {\n        CloseReason cr = new CloseReason(\n                CloseCodes.GOING_AWAY, sm.getString(\"wsWebSocketContainer.shutdown\"));\n\n        for (WsSession session : sessions.keySet()) {\n            try {\n                session.close(cr);\n            } catch (IOException ioe) {\n                log.debug(sm.getString(\n                        \"wsWebSocketContainer.sessionCloseFail\", session.getId()), ioe);\n            }\n        }\n    }\n\n    public void backgroundProcess() {\n        // This method gets called once a second.\n        backgroundProcessCount ++;\n\n        if (backgroundProcessCount >= processPeriod) {\n            backgroundProcessCount = 0;\n\n            for (WsSession wsSession : sessions.keySet()) {\n                wsSession.checkExpiration();\n            }\n        }\n\n    }"
            ],
            "java\\org\\apache\\coyote\\http11\\upgrade\\UpgradeProcessor.java": [
                "    public final SocketState upgradeDispatch() throws IOException {\n        return upgradeInbound.onData();\n    }\n\n    public SocketState upgradeDispatch(SocketStatus status) throws IOException {\n        return null;\n    }\n\n    public final SocketState event(SocketStatus status) throws IOException {\n        return null;\n    }"
            ],
            "test\\org\\apache\\catalina\\ha\\session\\TestSerializablePrincipal.java": [
                "    public void testWriteReadPrincipal() {\n        // Get a temporary file to use for the serialization test\n        File file = null;\n        try {\n            file = File.createTempFile(\"ser\", null);\n            file.deleteOnExit();\n        } catch (IOException e) {\n            e.printStackTrace();\n            fail(\"ioe creating temporary file\");\n        }\n\n        // Create the Principal to serialize\n        List<String> roles = new ArrayList<String>();\n        roles.add(\"RoleA\");\n        roles.add(\"RoleB\");\n        TesterPrincipal tpOriginal = new TesterPrincipal(\"inner\");\n        GenericPrincipal gpOriginal =\n            new GenericPrincipal(\"usr\", \"pwd\", roles, tpOriginal);\n\n        // Do the serialization\n        try {\n            FileOutputStream fos = new FileOutputStream(file);\n            ObjectOutputStream oos = new ObjectOutputStream(fos);\n            SerializablePrincipal.writePrincipal(gpOriginal, oos);\n            oos.close();\n            fos.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            fail(\"fnfe creating object output stream\");\n        } catch (IOException e) {\n            e.printStackTrace();\n            fail(\"ioe serializing principal\");\n        }\n\n        // De-serialize the Principal\n        GenericPrincipal gpNew = null;\n        try {\n            FileInputStream fis = new FileInputStream(file);\n            ObjectInputStream ois = new ObjectInputStream(fis);\n            gpNew = SerializablePrincipal.readPrincipal(ois);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            fail(\"fnfe reading object output stream\");\n        } catch (IOException e) {\n            e.printStackTrace();\n            fail(\"ioe de-serializing principal\");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            fail(\"cnfe de-serializing principal\");\n        }\n\n        // Now test how similar original and de-serialized versions are\n        assertEquals(\"User names different\", gpOriginal.getName(),\n                gpNew.getName());\n        assertEquals(\"Passwords different\", gpOriginal.getPassword(),\n                gpNew.getPassword());\n        assertEquals(\"Number of roles different\", gpOriginal.getRoles().length,\n                gpNew.getRoles().length);\n        for (int i = 0; i < gpOriginal.getRoles().length; i++) {\n            assertEquals(\"Role name index \" + i + \"different\",\n                    gpOriginal.getRoles()[i], gpNew.getRoles()[i]);\n        }\n        // These are the key tests for bug 43840\n        assertNotSame(\"Inner principal not present\", gpNew,\n                gpNew.getUserPrincipal());\n        assertEquals(\"Inner user names are different\", tpOriginal.getName(),\n                gpNew.getUserPrincipal().getName());\n    }"
            ],
            "java\\org\\apache\\tomcat\\util\\digester\\PathCallParamRule.java": [
                "    public void begin(String namespace, String name, Attributes attributes) throws Exception {\n\n        String param = getDigester().getMatch();\n        \n        if(param != null) {\n            Object parameters[] = (Object[]) digester.peekParams();\n            parameters[paramIndex] = param;\n        }\n        \n    }"
            ],
            "java\\org\\apache\\catalina\\startup\\WebappServiceLoader.java": [
                "    public List<T> load(Class<T> serviceType) throws IOException {\n        String configFile = SERVICES + serviceType.getName();\n\n        LinkedHashSet<String> applicationServicesFound = new LinkedHashSet<String>();\n        LinkedHashSet<String> containerServicesFound = new LinkedHashSet<String>();\n\n        ClassLoader loader = context.getClassLoader();\n\n        // if the ServletContext has ORDERED_LIBS, then use that to specify the\n        // set of JARs from WEB-INF/lib that should be used for loading services\n        @SuppressWarnings(\"unchecked\")\n        List<String> orderedLibs =\n                (List<String>) context.getAttribute(ServletContext.ORDERED_LIBS);\n        if (orderedLibs != null) {\n            // handle ordered libs directly, ...\n            for (String lib : orderedLibs) {\n                URL jarUrl = context.getResource(LIB + lib);\n                if (jarUrl == null) {\n                    // should not happen, just ignore\n                    continue;\n                }\n\n                String base = jarUrl.toExternalForm();\n                URL url;\n                if (base.endsWith(\"/\")) {\n                    url = new URL(base + configFile);\n                } else {\n                    url = new URL(\"jar:\" + base + \"!/\" + configFile);\n                }\n                try {\n                    parseConfigFile(applicationServicesFound, url);\n                } catch (FileNotFoundException e) {\n                    // no provider file found, this is OK\n                }\n            }\n\n            // and the parent ClassLoader for all others\n            loader = loader.getParent();\n        }\n\n        Enumeration<URL> resources;\n        if (loader == null) {\n            resources = ClassLoader.getSystemResources(configFile);\n        } else {\n            resources = loader.getResources(configFile);\n        }\n        while (resources.hasMoreElements()) {\n            parseConfigFile(containerServicesFound, resources.nextElement());\n        }\n\n        // Filter the discovered container SCIs if required\n        if (containerSciFilterPattern != null) {\n            Iterator<String> iter = containerServicesFound.iterator();\n            while (iter.hasNext()) {\n                if (containerSciFilterPattern.matcher(iter.next()).find()) {\n                    iter.remove();\n                }\n            }\n        }\n\n        // Add the application services after the container services to ensure\n        // that the container services are loaded first\n        containerServicesFound.addAll(applicationServicesFound);\n\n        // load the discovered services\n        if (containerServicesFound.isEmpty()) {\n            return Collections.emptyList();\n        }\n        return loadServices(serviceType, containerServicesFound);\n    }"
            ],
            "test\\org\\apache\\tomcat\\websocket\\server\\TestWsServerContainer.java": [
                "    public void testBug54807() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n        ctx.addApplicationListener(new ApplicationListener(\n                Bug54807Config.class.getName(), false));\n        Tomcat.addServlet(ctx, \"default\", new DefaultServlet());\n        ctx.addServletMapping(\"/\", \"default\");\n\n        tomcat.start();\n\n        Assert.assertEquals(LifecycleState.STARTED, ctx.getState());\n    }\n\n    public void testSpecExample3() throws Exception {\n        WsServerContainer sc =\n                new WsServerContainer(new TesterServletContext());\n\n        ServerEndpointConfig configA = ServerEndpointConfig.Builder.create(\n                Object.class, \"/a/{var}/c\").build();\n        ServerEndpointConfig configB = ServerEndpointConfig.Builder.create(\n                Object.class, \"/a/b/c\").build();\n        ServerEndpointConfig configC = ServerEndpointConfig.Builder.create(\n                Object.class, \"/a/{var1}/{var2}\").build();\n\n        sc.addEndpoint(configA);\n        sc.addEndpoint(configB);\n        sc.addEndpoint(configC);\n\n        Assert.assertEquals(configB, sc.findMapping(\"/a/b/c\").getConfig());\n        Assert.assertEquals(configA, sc.findMapping(\"/a/d/c\").getConfig());\n        Assert.assertEquals(configC, sc.findMapping(\"/a/x/y\").getConfig());\n    }",
                "    public void testSpecExample4() throws Exception {\n        WsServerContainer sc =\n                new WsServerContainer(new TesterServletContext());\n\n        ServerEndpointConfig configA = ServerEndpointConfig.Builder.create(\n                Object.class, \"/{var1}/d\").build();\n        ServerEndpointConfig configB = ServerEndpointConfig.Builder.create(\n                Object.class, \"/b/{var2}\").build();\n\n        sc.addEndpoint(configA);\n        sc.addEndpoint(configB);\n\n        Assert.assertEquals(configB, sc.findMapping(\"/b/d\").getConfig());\n    }\n\n    public void testDuplicatePaths_01() throws Exception {\n        WsServerContainer sc =\n                new WsServerContainer(new TesterServletContext());\n\n        ServerEndpointConfig configA = ServerEndpointConfig.Builder.create(\n                Object.class, \"/a/b/c\").build();\n        ServerEndpointConfig configB = ServerEndpointConfig.Builder.create(\n                Object.class, \"/a/b/c\").build();\n\n        sc.addEndpoint(configA);\n        sc.addEndpoint(configB);\n    }\n\n    public void testDuplicatePaths_02() throws Exception {\n        WsServerContainer sc =\n                new WsServerContainer(new TesterServletContext());\n\n        ServerEndpointConfig configA = ServerEndpointConfig.Builder.create(\n                Object.class, \"/a/b/{var}\").build();\n        ServerEndpointConfig configB = ServerEndpointConfig.Builder.create(\n                Object.class, \"/a/b/{var}\").build();\n\n        sc.addEndpoint(configA);\n        sc.addEndpoint(configB);\n    }",
                "    public void testDuplicatePaths_03() throws Exception {\n        WsServerContainer sc =\n                new WsServerContainer(new TesterServletContext());\n\n        ServerEndpointConfig configA = ServerEndpointConfig.Builder.create(\n                Object.class, \"/a/b/{var1}\").build();\n        ServerEndpointConfig configB = ServerEndpointConfig.Builder.create(\n                Object.class, \"/a/b/{var2}\").build();\n\n        sc.addEndpoint(configA);\n        sc.addEndpoint(configB);\n    }\n\n    public void testDuplicatePaths_04() throws Exception {\n        WsServerContainer sc =\n                new WsServerContainer(new TesterServletContext());\n\n        ServerEndpointConfig configA = ServerEndpointConfig.Builder.create(\n                Object.class, \"/a/{var1}/{var2}\").build();\n        ServerEndpointConfig configB = ServerEndpointConfig.Builder.create(\n                Object.class, \"/a/b/{var2}\").build();\n\n        sc.addEndpoint(configA);\n        sc.addEndpoint(configB);\n\n        Assert.assertEquals(configA, sc.findMapping(\"/a/x/y\").getConfig());\n        Assert.assertEquals(configB, sc.findMapping(\"/a/b/y\").getConfig());\n    }"
            ]
        }
    },
    "55976": {
        "summary": "Bug 55976 Broken response from NIO connector in Tomcat 7.0.50",
        "code_segments": {
            "test\\org\\apache\\catalina\\connector\\TestConnector.java": [
                "    public void testStop() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Wrapper w =\n            Tomcat.addServlet(root, \"tester\", new TesterServlet());\n        w.setAsyncSupported(true);\n        root.addServletMapping(\"/\", \"tester\");\n\n        Connector connector = tomcat.getConnector();\n\n        tomcat.start();\n\n        ByteChunk bc = new ByteChunk();\n        int rc = getUrl(\"http://localhost:\" + getPort() + \"/\", bc, null, null);\n\n        assertEquals(200, rc);\n        assertEquals(\"OK\", bc.toString());\n\n        rc = -1;\n        bc.recycle();\n\n        connector.stop();\n\n        try {\n            rc = getUrl(\"http://localhost:\" + getPort() + \"/\", bc, 1000,\n                    null, null);\n        } catch (SocketTimeoutException ste) {\n            // May also see this with NIO\n            // Make sure the test passes if we do\n            rc = 503;\n        }\n        assertEquals(503, rc);\n    }",
                "    public void testPort() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        Connector connector1 = tomcat.getConnector();\n        connector1.setPort(0);\n\n        Connector connector2 = new Connector();\n        connector2.setPort(0);\n\n        tomcat.getService().addConnector(connector2);\n\n        tomcat.start();\n\n        int localPort1 = connector1.getLocalPort();\n        int localPort2 = connector2.getLocalPort();\n\n        assertTrue(localPort1 > 0);\n        assertTrue(localPort2 > 0);\n    }"
            ],
            "java\\org\\apache\\tomcat\\util\\net\\NioChannel.java": [
                "    public void reset() throws IOException {\n        bufHandler.getReadBuffer().clear();\n        bufHandler.getWriteBuffer().clear();\n        this.sendFile = false;\n    }\n\n    public void close() throws IOException {\n        getIOChannel().socket().close();\n        getIOChannel().close();\n    }\n\n    public void close(boolean force) throws IOException {\n        if (isOpen() || force ) close();\n    }"
            ],
            "java\\org\\apache\\tomcat\\util\\net\\SecureNioChannel.java": [
                "    public void reset() throws IOException {\n        super.reset();\n        netOutBuffer.position(0);\n        netOutBuffer.limit(0);\n        netInBuffer.position(0);\n        netInBuffer.limit(0);\n        handshakeComplete = false;\n        closed = false;\n        closing = false;\n        //initiate handshake\n        sslEngine.beginHandshake();\n        handshakeStatus = sslEngine.getHandshakeStatus();\n    }\n\n    protected boolean flush(ByteBuffer buf) throws IOException {\n        int remaining = buf.remaining();\n        if ( remaining > 0 ) {\n            int written = sc.write(buf);\n            return written >= remaining;\n        }else {\n            return true;\n        }\n    }",
                "    public int handshake(boolean read, boolean write) throws IOException {\n        if ( handshakeComplete ) return 0; //we have done our initial handshake\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; //we still have data to write\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    //should never happen\n                    throw new IOException(\"NOT_HANDSHAKING during handshake\");\n                }\n                case FINISHED: {\n                    //we are complete if we have delivered the last package\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    //return 0 if we are complete, otherwise we still have data to write\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    //perform the wrap function\n                    handshake = handshakeWrap(write);\n                    if ( handshake.getStatus() == Status.OK ){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        //wrap should always work with our buffers\n                        throw new IOException(\"Unexpected status:\" + handshake.getStatus() + \" during handshake WRAP.\");\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        //should actually return OP_READ if we have NEED_UNWRAP\n                        return SelectionKey.OP_WRITE;\n                    }\n                    //fall down to NEED_UNWRAP on the same call, will result in a\n                    //BUFFER_UNDERFLOW if it needs data\n                }\n                //$FALL-THROUGH$\n                case NEED_UNWRAP: {\n                    //perform the unwrap function\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        //read more data, reregister for OP_READ\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(\"Invalid handshake status:\"+handshakeStatus+\" during handshake UNWRAP.\");\n                    }//switch\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(\"Invalid handshake status:\"+handshakeStatus);\n            }//switch\n        }//while\n        //return 0 if we are complete, otherwise reregister for any activity that\n        //would cause this method to be called again.\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }",
                "    public void rehandshake(long timeout) throws IOException {\n        //validate the network buffers are empty\n        if (netInBuffer.position() > 0 && netInBuffer.position()<netInBuffer.limit()) throw new IOException(\"Network input buffer still contains data. Handshake will fail.\");\n        if (netOutBuffer.position() > 0 && netOutBuffer.position()<netOutBuffer.limit()) throw new IOException(\"Network output buffer still contains data. Handshake will fail.\");\n        if (getBufHandler().getReadBuffer().position()>0 && getBufHandler().getReadBuffer().position()<getBufHandler().getReadBuffer().limit()) throw new IOException(\"Application input buffer still contains data. Data would have been lost.\");\n        if (getBufHandler().getWriteBuffer().position()>0 && getBufHandler().getWriteBuffer().position()<getBufHandler().getWriteBuffer().limit()) throw new IOException(\"Application output buffer still contains data. Data would have been lost.\");\n        reset();\n        boolean isReadable = true;\n        boolean isWriteable = true;\n        boolean handshaking = true;\n        Selector selector = null;\n        SelectionKey key = null;\n        try {\n            while (handshaking) {\n                int hsStatus = this.handshake(isReadable, isWriteable);\n                switch (hsStatus) {\n                    case -1 : throw new EOFException(\"EOF during handshake.\");\n                    case  0 : handshaking = false; break;\n                    default : {\n                        long now = System.currentTimeMillis();\n                        if (selector==null) {\n                            synchronized (Selector.class) {\n                                // Selector.open() isn't thread safe\n                                // http://bugs.sun.com/view_bug.do?bug_id=6427854\n                                // Affects 1.6.0_29, fixed in 1.7.0_01\n                                selector = Selector.open();\n                            }\n                            key = getIOChannel().register(selector, hsStatus);\n                        } else {\n                            key.interestOps(hsStatus);\n                        }\n                        int keyCount = selector.select(timeout);\n                        if (keyCount == 0 && ((System.currentTimeMillis()-now) >= timeout)) {\n                            throw new SocketTimeoutException(\"Handshake operation timed out.\");\n                        }\n                        isReadable = key.isReadable();\n                        isWriteable = key.isWritable();\n                    }\n                }\n            }\n        } catch (IOException x) {\n            throw x;\n        } catch (Exception cx) {\n            IOException x = new IOException(cx);\n            throw x;\n        } finally {\n            if (key!=null) try {key.cancel();} catch (Exception ignore) {}\n            if (selector!=null) try {selector.close();} catch (Exception ignore) {}\n        }\n    }",
                "    protected SSLEngineResult.HandshakeStatus tasks() {\n        Runnable r = null;\n        while ( (r = sslEngine.getDelegatedTask()) != null) {\n            r.run();\n        }\n        return sslEngine.getHandshakeStatus();\n    }\n\n    protected SSLEngineResult handshakeWrap(boolean doWrite) throws IOException {\n        //this should never be called with a network buffer that contains data\n        //so we can clear it here.\n        netOutBuffer.clear();\n        //perform the wrap\n        SSLEngineResult result = sslEngine.wrap(bufHandler.getWriteBuffer(), netOutBuffer);\n        //prepare the results to be written\n        netOutBuffer.flip();\n        //set the status\n        handshakeStatus = result.getHandshakeStatus();\n        //optimization, if we do have a writable channel, write it now\n        if ( doWrite ) flush(netOutBuffer);\n        return result;\n    }",
                "    protected SSLEngineResult handshakeUnwrap(boolean doread) throws IOException {\n\n        if (netInBuffer.position() == netInBuffer.limit()) {\n            //clear the buffer if we have emptied it out on data\n            netInBuffer.clear();\n        }\n        if ( doread )  {\n            //if we have data to read, read it\n            int read = sc.read(netInBuffer);\n            if (read == -1) throw new IOException(\"EOF encountered during handshake.\");\n        }\n        SSLEngineResult result;\n        boolean cont = false;\n        //loop while we can perform pure SSLEngine data\n        do {\n            //prepare the buffer with the incoming data\n            netInBuffer.flip();\n            //call unwrap\n            result = sslEngine.unwrap(netInBuffer, bufHandler.getReadBuffer());\n            //compact the buffer, this is an optional method, wonder what would happen if we didn't\n            netInBuffer.compact();\n            //read in the status\n            handshakeStatus = result.getHandshakeStatus();\n            if ( result.getStatus() == SSLEngineResult.Status.OK &&\n                 result.getHandshakeStatus() == HandshakeStatus.NEED_TASK ) {\n                //execute tasks if we need to\n                handshakeStatus = tasks();\n            }\n            //perform another unwrap?\n            cont = result.getStatus() == SSLEngineResult.Status.OK &&\n                   handshakeStatus == HandshakeStatus.NEED_UNWRAP;\n        }while ( cont );\n        return result;\n    }",
                "    public void close() throws IOException {\n        if (closing) return;\n        closing = true;\n        sslEngine.closeOutbound();\n\n        if (!flush(netOutBuffer)) {\n            throw new IOException(\"Remaining data in the network buffer, can't send SSL close message, force a close with close(true) instead\");\n        }\n        //prep the buffer for the close message\n        netOutBuffer.clear();\n        //perform the close, since we called sslEngine.closeOutbound\n        SSLEngineResult handshake = sslEngine.wrap(getEmptyBuf(), netOutBuffer);\n        //we should be in a close state\n        if (handshake.getStatus() != SSLEngineResult.Status.CLOSED) {\n            throw new IOException(\"Invalid close state, will not send network data.\");\n        }\n        //prepare the buffer for writing\n        netOutBuffer.flip();\n        //if there is data to be written\n        flush(netOutBuffer);\n\n        //is the channel closed?\n        closed = (!netOutBuffer.hasRemaining() && (handshake.getHandshakeStatus() != HandshakeStatus.NEED_WRAP));\n    }\n\n    public void close(boolean force) throws IOException {\n        try {\n            close();\n        }finally {\n            if ( force || closed ) {\n                closed = true;\n                sc.socket().close();\n                sc.close();\n            }\n        }\n    }",
                "    public int read(ByteBuffer dst) throws IOException {\n        //if we want to take advantage of the expand function, make sure we only use the ApplicationBufferHandler's buffers\n        if ( dst != bufHandler.getReadBuffer() ) throw new IllegalArgumentException(\"You can only read using the application read buffer provided by the handler.\");\n        //are we in the middle of closing or closed?\n        if ( closing || closed) return -1;\n        //did we finish our handshake?\n        if (!handshakeComplete) throw new IllegalStateException(\"Handshake incomplete, you must complete handshake before reading data.\");\n\n        //read from the network\n        int netread = sc.read(netInBuffer);\n        //did we reach EOF? if so send EOF up one layer.\n        if (netread == -1) return -1;\n\n        //the data read\n        int read = 0;\n        //the SSL engine result\n        SSLEngineResult unwrap;\n        do {\n            //prepare the buffer\n            netInBuffer.flip();\n            //unwrap the data\n            unwrap = sslEngine.unwrap(netInBuffer, dst);\n            //compact the buffer\n            netInBuffer.compact();\n\n            if ( unwrap.getStatus()==Status.OK || unwrap.getStatus()==Status.BUFFER_UNDERFLOW ) {\n                //we did receive some data, add it to our total\n                read += unwrap.bytesProduced();\n                //perform any tasks if needed\n                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK) tasks();\n                //if we need more network data, then bail out for now.\n                if ( unwrap.getStatus() == Status.BUFFER_UNDERFLOW ) break;\n            }else if ( unwrap.getStatus()==Status.BUFFER_OVERFLOW && read>0 ) {\n                //buffer overflow can happen, if we have read data, then\n                //empty out the dst buffer before we do another read\n                break;\n            }else {\n                //here we should trap BUFFER_OVERFLOW and call expand on the buffer\n                //for now, throw an exception, as we initialized the buffers\n                //in the constructor\n                throw new IOException(\"Unable to unwrap data, invalid status: \" + unwrap.getStatus());\n            }\n        } while ( (netInBuffer.position() != 0)); //continue to unwrapping as long as the input buffer has stuff\n        return (read);\n    }",
                "    public int write(ByteBuffer src) throws IOException {\n        if ( src == this.netOutBuffer ) {\n            //we can get here through a recursive call\n            //by using the NioBlockingSelector\n            int written = sc.write(src);\n            return written;\n        } else {\n            //make sure we can handle expand, and that we only use on buffer\n            if ( (!this.isSendFile()) && (src != bufHandler.getWriteBuffer()) ) throw new IllegalArgumentException(\"You can only write using the application write buffer provided by the handler.\");\n            //are we closing or closed?\n            if ( closing || closed) throw new IOException(\"Channel is in closing state.\");\n\n            //the number of bytes written\n            int written = 0;\n\n            if (!flush(netOutBuffer)) {\n                //we haven't emptied out the buffer yet\n                return written;\n            }\n\n            /*\n             * The data buffer is empty, we can reuse the entire buffer.\n             */\n            netOutBuffer.clear();\n\n            SSLEngineResult result = sslEngine.wrap(src, netOutBuffer);\n            written = result.bytesConsumed();\n            netOutBuffer.flip();\n\n            if (result.getStatus() == Status.OK) {\n                if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) tasks();\n            } else {\n                throw new IOException(\"Unable to wrap data, invalid engine state: \" +result.getStatus());\n            }\n\n            //force a flush\n            flush(netOutBuffer);\n\n            return written;\n        }\n    }",
                "    public boolean flushOutbound() throws IOException {\n        int remaining = netOutBuffer.remaining();\n        flush(netOutBuffer);\n        int remaining2= netOutBuffer.remaining();\n        return remaining2 < remaining;\n    }"
            ],
            "test\\org\\apache\\tomcat\\util\\http\\TestCookiesDisallowEquals.java": [
                "    public void testWithEquals() throws Exception {\n        TestCookieEqualsClient client = new TestCookieEqualsClient();\n        client.doRequest();\n    }"
            ],
            "test\\org\\apache\\tomcat\\util\\http\\TestCookiesAllowHttpSeps.java": [
                "    public void testWithHttpSep() throws Exception {\n        System.setProperty(\n                \"org.apache.tomcat.util.http.ServerCookie.ALLOW_HTTP_SEPARATORS_IN_V0\",\n                \"true\");\n\n        TestCookieHttpSepClient client = new TestCookieHttpSepClient();\n        client.doRequest();\n    }"
            ],
            "test\\org\\apache\\tomcat\\util\\http\\TestCookiesAllowEquals.java": [
                "    public void testWithEquals() throws Exception {\n        System.setProperty(\n                \"org.apache.tomcat.util.http.ServerCookie.ALLOW_EQUALS_IN_VALUE\",\n                \"true\");\n\n        TestCookieEqualsClient client = new TestCookieEqualsClient();\n        client.doRequest();\n    }"
            ],
            "test\\org\\apache\\coyote\\http11\\filters\\TestChunkedInputFilter.java": [
                "    public void testTrailingHeadersSizeLimit() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        Tomcat.addServlet(ctx, \"servlet\", new EchoHeaderServlet());\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        // Limit the size of the trailing header\n        tomcat.getConnector().setProperty(\"maxTrailerSize\", \"10\");\n        tomcat.start();\n\n        String[] request = new String[]{\n            \"POST /echo-params.jsp HTTP/1.1\" + SimpleHttpClient.CRLF +\n            \"Host: any\" + SimpleHttpClient.CRLF +\n            \"Transfer-encoding: chunked\" + SimpleHttpClient.CRLF +\n            \"Content-Type: application/x-www-form-urlencoded\" +\n                    SimpleHttpClient.CRLF +\n            \"Connection: close\" + SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF +\n            \"3\" + SimpleHttpClient.CRLF +\n            \"a=0\" + SimpleHttpClient.CRLF +\n            \"4\" + SimpleHttpClient.CRLF +\n            \"&b=1\" + SimpleHttpClient.CRLF +\n            \"0\" + SimpleHttpClient.CRLF +\n            \"x-trailer: Test\" + SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF };\n\n        TrailerClient client =\n                new TrailerClient(tomcat.getConnector().getLocalPort());\n        client.setRequest(request);\n\n        client.connect();\n        client.processRequest();\n        // Expected to fail because the trailers are longer\n        // than the set limit of 10 bytes\n        assertTrue(client.isResponse500());\n    }",
                "    private void doTestExtensionSizeLimit(int len, boolean ok) throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        tomcat.getConnector().setProperty(\n                \"maxExtensionSize\", Integer.toString(EXT_SIZE_LIMIT));\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        Tomcat.addServlet(ctx, \"servlet\", new EchoHeaderServlet());\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        tomcat.start();\n\n        String extName = \";foo=\";\n        StringBuilder extValue = new StringBuilder(len);\n        for (int i = 0; i < (len - extName.length()); i++) {\n            extValue.append(\"x\");\n        }\n\n        String[] request = new String[]{\n            \"POST /echo-params.jsp HTTP/1.1\" + SimpleHttpClient.CRLF +\n            \"Host: any\" + SimpleHttpClient.CRLF +\n            \"Transfer-encoding: chunked\" + SimpleHttpClient.CRLF +\n            \"Content-Type: application/x-www-form-urlencoded\" +\n                    SimpleHttpClient.CRLF +\n            \"Connection: close\" + SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF +\n            \"3\" + extName + extValue.toString() + SimpleHttpClient.CRLF +\n            \"a=0\" + SimpleHttpClient.CRLF +\n            \"4\" + SimpleHttpClient.CRLF +\n            \"&b=1\" + SimpleHttpClient.CRLF +\n            \"0\" + SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF };\n\n        TrailerClient client =\n                new TrailerClient(tomcat.getConnector().getLocalPort());\n        client.setRequest(request);\n\n        client.connect();\n        client.processRequest();\n\n        if (ok) {\n            assertTrue(client.isResponse200());\n        } else {\n            assertTrue(client.isResponse500());\n        }\n    }",
                "    public void testNoTrailingHeaders() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        Tomcat.addServlet(ctx, \"servlet\", new EchoHeaderServlet());\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        tomcat.start();\n\n        String request =\n            \"POST /echo-params.jsp HTTP/1.1\" + SimpleHttpClient.CRLF +\n            \"Host: any\" + SimpleHttpClient.CRLF +\n            \"Transfer-encoding: chunked\" + SimpleHttpClient.CRLF +\n            \"Content-Type: application/x-www-form-urlencoded\" +\n                    SimpleHttpClient.CRLF +\n            \"Connection: close\" + SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF +\n            \"3\" + SimpleHttpClient.CRLF +\n            \"a=0\" + SimpleHttpClient.CRLF +\n            \"4\" + SimpleHttpClient.CRLF +\n            \"&b=1\" + SimpleHttpClient.CRLF +\n            \"0\" + SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF;\n\n        TrailerClient client =\n                new TrailerClient(tomcat.getConnector().getLocalPort());\n        client.setRequest(new String[] {request});\n\n        client.connect();\n        client.processRequest();\n        assertEquals(\"nullnull7nullnull\", client.getResponseBody());\n    }"
            ],
            "test\\org\\apache\\coyote\\http11\\TestInternalInputBuffer.java": [
                "    public void testBug48839() {\n\n        Bug48839Client client = new Bug48839Client();\n\n        client.doRequest();\n        assertTrue(client.isResponse200());\n        assertTrue(client.isResponseBodyOK());\n    }\n\n    public void testBug51557NoColon() {\n\n        Bug51557Client client = new Bug51557Client(\"X-Bug51557NoColon\");\n\n        client.doRequest();\n        assertTrue(client.isResponse200());\n        assertEquals(\"abcd\", client.getResponseBody());\n        assertTrue(client.isResponseBodyOK());\n    }\n\n    public void testBug51557Separators() throws Exception {\n        char httpSeparators[] = new char[] {\n                '\\t', ' ', '\\\"', '(', ')', ',', '/', ':', ';', '<',\n                '=', '>', '?', '@', '[', '\\\\', ']', '{', '}' };\n\n        for (char s : httpSeparators) {\n            doTestBug51557Char(s);\n            tearDown();\n            setUp();\n        }\n    }",
                "    public void testBug51557Ctl() throws Exception {\n        for (int i = 0; i < 31; i++) {\n            doTestBug51557Char((char) i);\n            tearDown();\n            setUp();\n        }\n        doTestBug51557Char((char) 127);\n    }\n\n    public void testBug51557Continuation() {\n\n        Bug51557Client client = new Bug51557Client(\"X-Bug=51557NoColon\",\n                \"foo\" + SimpleHttpClient.CRLF + \" bar\");\n\n        client.doRequest();\n        assertTrue(client.isResponse200());\n        assertEquals(\"abcd\", client.getResponseBody());\n        assertTrue(client.isResponseBodyOK());\n    }\n\n    public void testBug51557BoundaryStart() {\n\n        Bug51557Client client = new Bug51557Client(\"=X-Bug51557\",\n                \"invalid\");\n\n        client.doRequest();\n        assertTrue(client.isResponse200());\n        assertEquals(\"abcd\", client.getResponseBody());\n        assertTrue(client.isResponseBodyOK());\n    }",
                "    public void testBug51557BoundaryEnd() {\n\n        Bug51557Client client = new Bug51557Client(\"X-Bug51557=\",\n                \"invalid\");\n\n        client.doRequest();\n        assertTrue(client.isResponse200());\n        assertEquals(\"abcd\", client.getResponseBody());\n        assertTrue(client.isResponseBodyOK());\n    }\n\n    private void doTestBug51557Char(char s) {\n        Bug51557Client client =\n            new Bug51557Client(\"X-Bug\" + s + \"51557\", \"invalid\");\n\n        client.doRequest();\n        assertTrue(client.isResponse200());\n        assertEquals(\"abcd\", client.getResponseBody());\n        assertTrue(client.isResponseBodyOK());\n    }\n\n    public void testNewLines() {\n\n        NewLinesClient client = new NewLinesClient(10);\n\n        client.doRequest();\n        assertTrue(client.isResponse200());\n        assertTrue(client.isResponseBodyOK());\n    }",
                "    public void testNewLinesExcessive() {\n\n        NewLinesClient client = new NewLinesClient(10000);\n\n        // If the connection is closed fast enough, writing the request will\n        // fail and the response won't be read.\n        Exception e = client.doRequest();\n        if (e == null) {\n            assertTrue(client.isResponse400());\n        }\n        assertFalse(client.isResponseBodyOK());\n    }\n\n    public void testBug54947() {\n\n        Bug54947Client client = new Bug54947Client();\n\n        client.doRequest();\n        assertTrue(client.isResponse200());\n        assertTrue(client.isResponseBodyOK());\n    }"
            ],
            "test\\org\\apache\\tomcat\\util\\http\\TestCookiesAllowNameOnly.java": [
                "    public void testWithEquals() throws Exception {\n        System.setProperty(\n                \"org.apache.tomcat.util.http.ServerCookie.ALLOW_NAME_ONLY\",\n                \"true\");\n\n        TestCookieNameOnlyClient client = new TestCookieNameOnlyClient();\n        client.doRequest();\n    }"
            ],
            "test\\org\\apache\\catalina\\core\\TestSwallowAbortedUploads.java": [
                "    public void testAbortedUploadUnlimitedSwallow() {\n        log.info(\"Unlimited, swallow enabled\");\n        AbortedUploadClient client = new AbortedUploadClient();\n        Exception ex = doAbortedUploadTest(client, false, true);\n        assertNull(\"Unlimited upload with swallow enabled generates client exception\",\n                   ex);\n        assertTrue(\"Unlimited upload with swallow enabled returns error status code\",\n                   client.isResponse200());\n        client.reset();\n    }\n\n    public void testAbortedUploadUnlimitedNoSwallow() {\n        log.info(\"Unlimited, swallow disabled\");\n        AbortedUploadClient client = new AbortedUploadClient();\n        Exception ex = doAbortedUploadTest(client, false, false);\n        assertNull(\"Unlimited upload with swallow disabled generates client exception\",\n                   ex);\n        assertTrue(\"Unlimited upload with swallow disabled returns error status code\",\n                   client.isResponse200());\n        client.reset();\n    }\n\n    public void testAbortedUploadLimitedSwallow() {\n        log.info(\"Limited, swallow enabled\");\n        AbortedUploadClient client = new AbortedUploadClient();\n        Exception ex = doAbortedUploadTest(client, true, true);\n        assertNull(\"Limited upload with swallow enabled generates client exception\",\n                   ex);\n        assertTrue(\"Limited upload with swallow enabled returns error status code\",\n                   client.isResponse500());\n        client.reset();\n    }",
                "    public void testAbortedUploadLimitedNoSwallow() {\n        log.info(\"Limited, swallow disabled\");\n        AbortedUploadClient client = new AbortedUploadClient();\n        Exception ex = doAbortedUploadTest(client, true, false);\n        assertTrue(\"Limited upload with swallow disabled does not generate client exception\",\n                   ex != null && ex instanceof java.net.SocketException);\n        client.reset();\n    }\n\n    public void testAbortedPOSTOKSwallow() {\n        log.info(\"Aborted (OK), swallow enabled\");\n        AbortedPOSTClient client = new AbortedPOSTClient();\n        Exception ex = doAbortedPOSTTest(client, HttpServletResponse.SC_OK, true);\n        assertNull(\"Unlimited upload with swallow enabled generates client exception\",\n                   ex);\n        assertTrue(\"Unlimited upload with swallow enabled returns error status code\",\n                   client.isResponse200());\n        client.reset();\n    }\n\n    public void testAbortedPOSTOKNoSwallow() {\n        log.info(\"Aborted (OK), swallow disabled\");\n        AbortedPOSTClient client = new AbortedPOSTClient();\n        Exception ex = doAbortedPOSTTest(client, HttpServletResponse.SC_OK, false);\n        assertNull(\"Unlimited upload with swallow disabled generates client exception\",\n                   ex);\n        assertTrue(\"Unlimited upload with swallow disabled returns error status code\",\n                   client.isResponse200());\n        client.reset();\n    }",
                "    public void testAbortedPOST413Swallow() {\n        log.info(\"Aborted (413), swallow enabled\");\n        AbortedPOSTClient client = new AbortedPOSTClient();\n        Exception ex = doAbortedPOSTTest(client, HttpServletResponse.SC_REQUEST_ENTITY_TOO_LARGE, true);\n        assertNull(\"Limited upload with swallow enabled generates client exception\",\n                   ex);\n        assertTrue(\"Limited upload with swallow enabled returns error status code\",\n                   client.isResponse413());\n        client.reset();\n    }\n\n    public void testAbortedPOST413NoSwallow() {\n        log.info(\"Aborted (413), swallow disabled\");\n        AbortedPOSTClient client = new AbortedPOSTClient();\n        Exception ex = doAbortedPOSTTest(client, HttpServletResponse.SC_REQUEST_ENTITY_TOO_LARGE, false);\n        assertTrue(\"Limited upload with swallow disabled does not generate client exception\",\n                   ex != null && ex instanceof java.net.SocketException);\n        client.reset();\n    }"
            ],
            "test\\org\\apache\\catalina\\comet\\TestCometProcessor.java": [
                "    public void testAsyncClose() throws Exception {\n\n        if (!isCometSupported()) {\n            log.info(\"This test is skipped, because this connector does not support Comet.\");\n            return;\n        }\n\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Tomcat.addServlet(root, \"comet\", new SimpleCometServlet());\n        root.addServletMapping(\"/comet\", \"comet\");\n        Tomcat.addServlet(root, \"hello\", new HelloWorldServlet());\n        root.addServletMapping(\"/hello\", \"hello\");\n        root.getPipeline().addValve(new AsyncCometCloseValve());\n        tomcat.getConnector().setProperty(\"connectionTimeout\", \"5000\");\n        tomcat.start();\n\n        // Create connection to Comet servlet\n        final Socket socket =\n            SocketFactory.getDefault().createSocket(\"localhost\", getPort());\n        socket.setSoTimeout(5000);\n\n        final OutputStream os = socket.getOutputStream();\n        String requestLine = \"POST http://localhost:\" + getPort() +\n                \"/comet HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"transfer-encoding: chunked\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n\n        InputStream is = socket.getInputStream();\n        ResponseReaderThread readThread = new ResponseReaderThread(is);\n        readThread.start();\n\n        // Wait for the comet request/response to finish\n        int count = 0;\n        while (count < 10 && !readThread.getResponse().endsWith(\"0\\r\\n\\r\\n\")) {\n            Thread.sleep(500);\n            count++;\n        }\n\n        if (count == 10) {\n            fail(\"Comet request did not complete\");\n        }\n\n        // Send a standard HTTP request on the same connection\n        requestLine = \"GET http://localhost:\" + getPort() +\n                \"/hello HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n\n        // Check for the expected response\n        count = 0;\n        while (count < 10 && !readThread.getResponse().contains(\n                HelloWorldServlet.RESPONSE_TEXT)) {\n            Thread.sleep(500);\n            count++;\n        }\n\n        if (count == 10) {\n            fail(\"Non-comet request did not complete\");\n        }\n\n        readThread.join();\n        os.close();\n        is.close();\n    }",
                "    public void testSyncClose() throws Exception {\n\n        if (!isCometSupported()) {\n            log.info(\"This test is skipped, because this connector does not support Comet.\");\n            return;\n        }\n\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Tomcat.addServlet(root, \"comet\", new CometCloseServlet());\n        root.addServletMapping(\"/comet\", \"comet\");\n        Tomcat.addServlet(root, \"hello\", new HelloWorldServlet());\n        root.addServletMapping(\"/hello\", \"hello\");\n        tomcat.getConnector().setProperty(\"connectionTimeout\", \"5000\");\n        tomcat.start();\n\n        // Create connection to Comet servlet\n        final Socket socket =\n            SocketFactory.getDefault().createSocket(\"localhost\", getPort());\n        socket.setSoTimeout(5000);\n\n        final OutputStream os = socket.getOutputStream();\n        String requestLine = \"POST http://localhost:\" + getPort() +\n                \"/comet HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"transfer-encoding: chunked\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n        // Don't send any data\n        os.write(\"0\\r\\n\\r\\n\".getBytes());\n\n        InputStream is = socket.getInputStream();\n        ResponseReaderThread readThread = new ResponseReaderThread(is);\n        readThread.start();\n\n        // Wait for the comet request/response to finish\n        int count = 0;\n        while (count < 10 && !readThread.getResponse().endsWith(\"0\\r\\n\\r\\n\")) {\n            Thread.sleep(500);\n            count++;\n        }\n\n        Assert.assertTrue(readThread.getResponse().contains(\"2\\r\\nOK\"));\n\n        if (count == 10) {\n            fail(\"Comet request did not complete\");\n        }\n\n        // Send a standard HTTP request on the same connection\n        requestLine = \"GET http://localhost:\" + getPort() +\n                \"/hello HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"connection: close\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n\n        // Check for the expected response\n        count = 0;\n        while (count < 10 && !readThread.getResponse().contains(\n                HelloWorldServlet.RESPONSE_TEXT)) {\n            Thread.sleep(500);\n            count++;\n        }\n\n        if (count == 10) {\n            fail(\"Non-comet request did not complete\");\n        }\n\n        readThread.join();\n        os.close();\n        is.close();\n    }",
                "    public void testConnectionClose() throws Exception {\n\n        if (!isCometSupported()) {\n            log.info(\"This test is skipped, because this connector does not support Comet.\");\n            return;\n        }\n\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Tomcat.addServlet(root, \"comet\", new ConnectionCloseServlet());\n        root.addServletMapping(\"/comet\", \"comet\");\n        Tomcat.addServlet(root, \"hello\", new HelloWorldServlet());\n        root.addServletMapping(\"/hello\", \"hello\");\n        tomcat.getConnector().setProperty(\"connectionTimeout\", \"5000\");\n        tomcat.start();\n\n        // Create connection to Comet servlet\n        final Socket socket =\n            SocketFactory.getDefault().createSocket(\"localhost\", getPort());\n        socket.setSoTimeout(5000);\n\n        final OutputStream os = socket.getOutputStream();\n        String requestLine = \"POST http://localhost:\" + getPort() +\n                \"/comet HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"transfer-encoding: chunked\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n        // Don't send any data\n        os.write(\"0\\r\\n\\r\\n\".getBytes());\n\n        InputStream is = socket.getInputStream();\n        ResponseReaderThread readThread = new ResponseReaderThread(is);\n        readThread.start();\n\n        // Wait for the comet request/response to finish\n        int count = 0;\n        while (count < 10 && !readThread.getResponse().endsWith(\"OK\")) {\n            Thread.sleep(500);\n            count++;\n        }\n\n        if (count == 10) {\n            fail(\"Comet request did not complete\");\n        }\n\n        // Read thread should have terminated cleanly when the server closed the\n        // socket\n        Assert.assertFalse(readThread.isAlive());\n        Assert.assertNull(readThread.getException());\n\n        os.close();\n        is.close();\n    }",
                "    public void testSimpleCometClient() throws Exception {\n        doSimpleCometTest(null);\n    }",
                "    private void doSimpleCometTest(String initParam) throws Exception {\n        if (!isCometSupported()) {\n            log.info(\"This test is skipped, because this connector does not support Comet.\");\n            return;\n        }\n\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Wrapper w = Tomcat.addServlet(root, \"comet\", new SimpleCometServlet());\n        if (initParam != null) {\n            w.addInitParameter(initParam, \"true\");\n        }\n        root.addServletMapping(\"/\", \"comet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        root.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        // Create connection to Comet servlet\n        final Socket socket =\n            SocketFactory.getDefault().createSocket(\"localhost\", getPort());\n        socket.setSoTimeout(60000);\n\n        final OutputStream os = socket.getOutputStream();\n        String requestLine = \"POST http://localhost:\" + getPort() +\n                \"/ HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"transfer-encoding: chunked\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n\n        PingWriterThread writeThread = new PingWriterThread(4, os);\n        writeThread.start();\n\n        socket.setSoTimeout(25000);\n        InputStream is = socket.getInputStream();\n        ResponseReaderThread readThread = new ResponseReaderThread(is);\n        readThread.start();\n        readThread.join();\n        os.close();\n        is.close();\n\n        String[] response = readThread.getResponse().split(\"\\r\\n\");\n        if (initParam == null) {\n            // Normal response expected\n            // Validate response\n            assertEquals(\"HTTP/1.1 200 OK\", response[0]);\n            assertEquals(\"Server: Apache-Coyote/1.1\", response[1]);\n            assertTrue(response[2].startsWith(\"Set-Cookie: JSESSIONID=\"));\n            assertEquals(\"Content-Type: text/plain;charset=ISO-8859-1\", response[3]);\n            assertEquals(\"Transfer-Encoding: chunked\", response[4]);\n            assertTrue(response[5].startsWith(\"Date: \"));\n            assertEquals(\"\", response[6]);\n            assertEquals(\"7\", response[7]);\n            assertEquals(\"BEGIN\", response[8]);\n            assertEquals(\"\", response[9]);\n            assertEquals(\"17\", response[10]);\n            assertEquals(\"Client: READ: 4 bytes\", response[11]);\n            assertEquals(\"\", response[12]);\n            assertEquals(\"17\", response[13]);\n            assertEquals(\"Client: READ: 4 bytes\", response[14]);\n            assertEquals(\"\", response[15]);\n            assertEquals(\"17\", response[16]);\n            assertEquals(\"Client: READ: 4 bytes\", response[17]);\n            assertEquals(\"\", response[18]);\n            assertEquals(\"17\", response[19]);\n            assertEquals(\"Client: READ: 4 bytes\", response[20]);\n            assertEquals(\"\", response[21]);\n            assertEquals(\"d\", response[22]);\n            assertEquals(\"Client: END\", response[23]);\n            assertEquals(\"\", response[24]);\n            assertEquals(\"0\", response[25]);\n            // Expect 26 lines\n            assertEquals(26, response.length);\n        } else {\n            // Failure expected only expected for the fail on begin\n            // Failure at any later stage and the response headers (including\n            // the 200 response code will already have been sent to the client\n            if (SimpleCometServlet.FAIL_ON_BEGIN.equals(initParam)) {\n                assertEquals(\"HTTP/1.1 500 Internal Server Error\", response[0]);\n                alv.validateAccessLog(1, 500, 0, 1000);\n            } else {\n                assertEquals(\"HTTP/1.1 200 OK\", response[0]);\n                alv.validateAccessLog(1, 200, 0, 5000);\n            }\n\n        }\n    }",
                "    public void testCometConnectorStop() throws Exception {\n\n        if (!isCometSupported()) {\n            log.info(\"This test is skipped, because this connector does not support Comet.\");\n            return;\n        }\n\n        // Setup Tomcat instance\n        SimpleCometServlet servlet = new SimpleCometServlet();\n        Tomcat tomcat = getTomcatInstance();\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Tomcat.addServlet(root, \"comet\", servlet);\n        root.addServletMapping(\"/\", \"comet\");\n        tomcat.start();\n\n        // Create connection to Comet servlet\n        final Socket socket =\n            SocketFactory.getDefault().createSocket(\"localhost\", getPort());\n        socket.setSoTimeout(10000);\n\n        final OutputStream os = socket.getOutputStream();\n        String requestLine = \"POST http://localhost:\" + getPort() +\n                \"/ HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"transfer-encoding: chunked\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n\n        PingWriterThread writeThread = new PingWriterThread(100, os);\n        writeThread.start();\n\n        InputStream is = socket.getInputStream();\n        ResponseReaderThread readThread = new ResponseReaderThread(is);\n        readThread.start();\n\n        // Allow the first couple of PING messages to be written\n        Thread.sleep(3000);\n\n        tomcat.getConnector().stop();\n\n        int count = 0;\n        // Wait for the read thread to stop\n        while (readThread.isAlive() && count < 50) {\n            Thread.sleep(100);\n            count ++;\n        }\n\n        // Wait for the write thread to stop\n        count = 0;\n        while (writeThread.isAlive() && count < 50) {\n            Thread.sleep(100);\n            count ++;\n        }\n\n        // Destroy the connector once the executor has sent the end event\n        tomcat.getConnector().destroy();\n\n        String[] response = readThread.getResponse().split(\"\\r\\n\");\n        String lastMessage = \"\";\n        String lastResponseLine = \"\";\n        for (int i = response.length; --i >= 0;) {\n            lastMessage = response[i];\n            if (lastMessage.startsWith(\"Client:\")) {\n                break;\n            }\n        }\n        for (int i = response.length; --i >= 0;) {\n            lastResponseLine = response[i];\n            if (lastResponseLine.length() > 0) {\n                break;\n            }\n        }\n        StringBuilder status = new StringBuilder();\n        // Expected, but is not 100% reliable:\n        // WriteThread exception: java.net.SocketException\n        // ReaderThread exception: null\n        // Last message: [Client: END]\n        // Last response line: [0] (empty chunk)\n        // Last comet event: [END]\n        // END event occurred: [true]\n        status.append(\"Status:\");\n        status.append(\"\\nWriterThread exception: \" + writeThread.getException());\n        status.append(\"\\nReaderThread exception: \" + readThread.getException());\n        status.append(\"\\nLast message: [\" + lastMessage + \"]\");\n        status.append(\"\\nLast response line: [\" + lastResponseLine + \"]\");\n        status.append(\"\\nLast comet event: [\" + servlet.getLastEvent() + \"]\");\n        status.append(\"\\nEND event occurred: [\" + servlet.getEndEventOccurred() + \"]\");\n        if (writeThread.getException() == null\n                || !lastMessage.contains(\"Client: END\")\n                || !EventType.END.equals(servlet.getLastEvent())) {\n            log.error(status);\n        } else {\n            log.info(status);\n        }\n        assertTrue(\"Comet END event not received\",\n                EventType.END.equals(servlet.getLastEvent()));\n    }",
                "    private boolean isCometSupported() {\n        String protocol =\n            getTomcatInstance().getConnector().getProtocolHandlerClassName();\n        if (protocol.indexOf(\"Nio\") == -1 && protocol.indexOf(\"Apr\") == -1) {\n            return false;\n        } else {\n            return true;\n        }\n    }"
            ],
            "java\\org\\apache\\tomcat\\util\\net\\NioSelectorPool.java": [
                "    public void put(Selector s) throws IOException {\n        if ( SHARED ) return;\n        if ( enabled ) active.decrementAndGet();\n        if ( enabled && (maxSpareSelectors==-1 || spare.get() < Math.min(maxSpareSelectors,maxSelectors)) ) {\n            spare.incrementAndGet();\n            selectors.offer(s);\n        }\n        else s.close();\n    }\n\n    public void close() throws IOException {\n        enabled = false;\n        Selector s;\n        while ( (s = selectors.poll()) != null ) s.close();\n        spare.set(0);\n        active.set(0);\n        if (blockingSelector!=null) {\n            blockingSelector.close();\n        }\n        if ( SHARED && getSharedSelector()!=null ) {\n            getSharedSelector().close();\n            SHARED_SELECTOR = null;\n        }\n    }\n\n    public void open() throws IOException {\n        enabled = true;\n        getSharedSelector();\n        if (SHARED) {\n            blockingSelector = new NioBlockingSelector();\n            blockingSelector.open(getSharedSelector());\n        }\n\n    }",
                "    public int write(ByteBuffer buf, NioChannel socket, Selector selector, long writeTimeout) throws IOException {\n        return write(buf,socket,selector,writeTimeout,true);\n    }\n\n    public int read(ByteBuffer buf, NioChannel socket, Selector selector, long readTimeout) throws IOException {\n        return read(buf,socket,selector,readTimeout,true);\n    }",
                "    public int read(ByteBuffer buf, NioChannel socket, Selector selector, long readTimeout, boolean block) throws IOException {\n        if ( SHARED && block ) {\n            return blockingSelector.read(buf,socket,readTimeout);\n        }\n        SelectionKey key = null;\n        int read = 0;\n        boolean timedout = false;\n        int keycount = 1; //assume we can write\n        long time = System.currentTimeMillis(); //start the timeout timer\n        try {\n            while ( (!timedout) ) {\n                int cnt = 0;\n                if ( keycount > 0 ) { //only read if we were registered for a read\n                    cnt = socket.read(buf);\n                    if (cnt == -1) throw new EOFException();\n                    read += cnt;\n                    if (cnt > 0) continue; //read some more\n                    if (cnt==0 && (read>0 || (!block) ) ) break; //we are done reading\n                }\n                if ( selector != null ) {//perform a blocking read\n                    //register OP_WRITE to the selector\n                    if (key==null) key = socket.getIOChannel().register(selector, SelectionKey.OP_READ);\n                    else key.interestOps(SelectionKey.OP_READ);\n                    keycount = selector.select(readTimeout);\n                }\n                if (readTimeout > 0 && (selector == null || keycount == 0) ) timedout = (System.currentTimeMillis()-time)>=readTimeout;\n            }//while\n            if ( timedout ) throw new SocketTimeoutException();\n        } finally {\n            if (key != null) {\n                key.cancel();\n                if (selector != null) selector.selectNow();//removes the key from this selector\n            }\n        }\n        return read;\n    }"
            ],
            "test\\org\\apache\\coyote\\http11\\TestAbstractHttp11Processor.java": [
                "    public void testWithTEVoid() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Use the normal Tomcat ROOT context\n        File root = new File(\"test/webapp-3.0\");\n        tomcat.addWebapp(\"\", root.getAbsolutePath());\n\n        tomcat.start();\n\n        String request =\n            \"POST /echo-params.jsp HTTP/1.1\" + SimpleHttpClient.CRLF +\n            \"Host: any\" + SimpleHttpClient.CRLF +\n            \"Transfer-encoding: void\" + SimpleHttpClient.CRLF +\n            \"Content-Length: 9\" + SimpleHttpClient.CRLF +\n            \"Content-Type: application/x-www-form-urlencoded\" +\n                    SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF +\n            \"test=data\";\n\n        Client client = new Client(tomcat.getConnector().getLocalPort());\n        client.setRequest(new String[] {request});\n\n        client.connect();\n        client.processRequest();\n        assertTrue(client.isResponse501());\n    }",
                "    public void testWithTEBuffered() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Use the normal Tomcat ROOT context\n        File root = new File(\"test/webapp-3.0\");\n        tomcat.addWebapp(\"\", root.getAbsolutePath());\n\n        tomcat.start();\n\n        String request =\n            \"POST /echo-params.jsp HTTP/1.1\" + SimpleHttpClient.CRLF +\n            \"Host: any\" + SimpleHttpClient.CRLF +\n            \"Transfer-encoding: buffered\" + SimpleHttpClient.CRLF +\n            \"Content-Length: 9\" + SimpleHttpClient.CRLF +\n            \"Content-Type: application/x-www-form-urlencoded\" +\n                    SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF +\n            \"test=data\";\n\n        Client client = new Client(tomcat.getConnector().getLocalPort());\n        client.setRequest(new String[] {request});\n\n        client.connect();\n        client.processRequest();\n        assertTrue(client.isResponse501());\n    }",
                "    public void testWithTEIdentity() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Use the normal Tomcat ROOT context\n        File root = new File(\"test/webapp-3.0\");\n        tomcat.addWebapp(\"\", root.getAbsolutePath());\n\n        tomcat.start();\n\n        String request =\n            \"POST /echo-params.jsp HTTP/1.1\" + SimpleHttpClient.CRLF +\n            \"Host: any\" + SimpleHttpClient.CRLF +\n            \"Transfer-encoding: identity\" + SimpleHttpClient.CRLF +\n            \"Content-Length: 9\" + SimpleHttpClient.CRLF +\n            \"Content-Type: application/x-www-form-urlencoded\" +\n                    SimpleHttpClient.CRLF +\n            \"Connection: close\" + SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF +\n            \"test=data\";\n\n        Client client = new Client(tomcat.getConnector().getLocalPort());\n        client.setRequest(new String[] {request});\n\n        client.connect();\n        client.processRequest();\n        assertTrue(client.isResponse200());\n        assertTrue(client.getResponseBody().contains(\"test - data\"));\n    }",
                "    public void testWithTESavedRequest() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Use the normal Tomcat ROOT context\n        File root = new File(\"test/webapp-3.0\");\n        tomcat.addWebapp(\"\", root.getAbsolutePath());\n\n        tomcat.start();\n\n        String request =\n            \"POST /echo-params.jsp HTTP/1.1\" + SimpleHttpClient.CRLF +\n            \"Host: any\" + SimpleHttpClient.CRLF +\n            \"Transfer-encoding: savedrequest\" + SimpleHttpClient.CRLF +\n            \"Content-Length: 9\" + SimpleHttpClient.CRLF +\n            \"Content-Type: application/x-www-form-urlencoded\" +\n                    SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF +\n            \"test=data\";\n\n        Client client = new Client(tomcat.getConnector().getLocalPort());\n        client.setRequest(new String[] {request});\n\n        client.connect();\n        client.processRequest();\n        assertTrue(client.isResponse501());\n    }",
                "    public void testWithTEUnsupported() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Use the normal Tomcat ROOT context\n        File root = new File(\"test/webapp-3.0\");\n        tomcat.addWebapp(\"\", root.getAbsolutePath());\n\n        tomcat.start();\n\n        String request =\n            \"POST /echo-params.jsp HTTP/1.1\" + SimpleHttpClient.CRLF +\n            \"Host: any\" + SimpleHttpClient.CRLF +\n            \"Transfer-encoding: unsupported\" + SimpleHttpClient.CRLF +\n            \"Content-Length: 9\" + SimpleHttpClient.CRLF +\n            \"Content-Type: application/x-www-form-urlencoded\" +\n                    SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF +\n            \"test=data\";\n\n        Client client = new Client(tomcat.getConnector().getLocalPort());\n        client.setRequest(new String[] {request});\n\n        client.connect();\n        client.processRequest();\n        assertTrue(client.isResponse501());\n    }",
                "    public void testPipelining() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctxt = tomcat.addContext(\"\",\n                System.getProperty(\"java.io.tmpdir\"));\n\n        // Add protected servlet\n        Tomcat.addServlet(ctxt, \"TesterServlet\", new TesterServlet());\n        ctxt.addServletMapping(\"/foo\", \"TesterServlet\");\n\n        tomcat.start();\n\n        String requestPart1 =\n            \"GET /foo HTTP/1.1\" + SimpleHttpClient.CRLF;\n        String requestPart2 =\n            \"Host: any\" + SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF;\n\n        final Client client = new Client(tomcat.getConnector().getLocalPort());\n        client.setRequest(new String[] {requestPart1, requestPart2});\n        client.setRequestPause(1000);\n        client.setUseContentLength(true);\n        client.connect();\n\n        Runnable send = new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    client.sendRequest();\n                    client.sendRequest();\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        };\n        Thread t = new Thread(send);\n        t.start();\n\n        // Sleep for 1500 ms which should mean the all of request 1 has been\n        // sent and half of request 2\n        Thread.sleep(1500);\n\n        // Now read the first response\n        client.readResponse(true);\n        assertFalse(client.isResponse50x());\n        assertTrue(client.isResponse200());\n        assertEquals(\"OK\", client.getResponseBody());\n\n        // Read the second response. No need to sleep, read will block until\n        // there is data to process\n        client.readResponse(true);\n        assertFalse(client.isResponse50x());\n        assertTrue(client.isResponse200());\n        assertEquals(\"OK\", client.getResponseBody());\n    }",
                "    public void testChunking11NoContentLength() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctxt = tomcat.addContext(\"\",\n                System.getProperty(\"java.io.tmpdir\"));\n\n        Tomcat.addServlet(ctxt, \"NoContentLengthFlushingServlet\",\n                new NoContentLengthFlushingServlet());\n        ctxt.addServletMapping(\"/test\", \"NoContentLengthFlushingServlet\");\n\n        tomcat.start();\n\n        ByteChunk responseBody = new ByteChunk();\n        Map<String,List<String>> responseHeaders =\n                new HashMap<String,List<String>>();\n        int rc = getUrl(\"http://localhost:\" + getPort() + \"/test\", responseBody,\n                responseHeaders);\n\n        assertEquals(HttpServletResponse.SC_OK, rc);\n        assertTrue(responseHeaders.containsKey(\"Transfer-Encoding\"));\n        List<String> encodings = responseHeaders.get(\"Transfer-Encoding\");\n        assertEquals(1, encodings.size());\n        assertEquals(\"chunked\", encodings.get(0));\n    }",
                "    private void doTestBug53677(boolean flush) throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctxt = tomcat.addContext(\"\",\n                System.getProperty(\"java.io.tmpdir\"));\n\n        Tomcat.addServlet(ctxt, \"LargeHeaderServlet\",\n                new LargeHeaderServlet(flush));\n        ctxt.addServletMapping(\"/test\", \"LargeHeaderServlet\");\n\n        tomcat.start();\n\n        ByteChunk responseBody = new ByteChunk();\n        Map<String,List<String>> responseHeaders =\n                new HashMap<String,List<String>>();\n        int rc = getUrl(\"http://localhost:\" + getPort() + \"/test\", responseBody,\n                responseHeaders);\n\n        assertEquals(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, rc);\n        if (responseBody.getLength() > 0) {\n            // It will be >0 if the standard error page handlign has been\n            // triggered\n            assertFalse(responseBody.toString().contains(\"FAIL\"));\n        }\n    }",
                "    public void testBug55772() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n        tomcat.getConnector().setProperty(\"processorCache\", \"1\");\n        tomcat.getConnector().setProperty(\"maxThreads\", \"1\");\n\n        // Must have a real docBase - just use temp\n        Context ctxt = tomcat.addContext(\"\",\n                System.getProperty(\"java.io.tmpdir\"));\n\n        Tomcat.addServlet(ctxt, \"async\", new Bug55772Servlet());\n        ctxt.addServletMapping(\"/*\", \"async\");\n\n        tomcat.start();\n\n        String request1 = \"GET /async HTTP/1.1\\r\\n\" +\n                \"Host: localhost:\" + getPort() + \"\\r\\n\" +\n                \"Connection: keep-alive\\r\\n\" +\n                \"Cache-Control: max-age=0\\r\\n\" +\n                \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\\r\\n\" +\n                \"User-Agent: Request1\\r\\n\" +\n                \"Accept-Encoding: gzip,deflate,sdch\\r\\n\" +\n                \"Accept-Language: en-US,en;q=0.8,fr;q=0.6,es;q=0.4\\r\\n\" +\n                \"Cookie: something.that.should.not.leak=true\\r\\n\" +\n                \"\\r\\n\";\n\n        String request2 = \"GET /async HTTP/1.1\\r\\n\" +\n                \"Host: localhost:\" + getPort() + \"\\r\\n\" +\n                \"Connection: keep-alive\\r\\n\" +\n                \"Cache-Control: max-age=0\\r\\n\" +\n                \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\\r\\n\" +\n                \"User-Agent: Request2\\r\\n\" +\n                \"Accept-Encoding: gzip,deflate,sdch\\r\\n\" +\n                \"Accept-Language: en-US,en;q=0.8,fr;q=0.6,es;q=0.4\\r\\n\" +\n                \"\\r\\n\";\n\n        Socket connection = null;\n        try {\n            connection = new Socket(\"localhost\", getPort());\n            connection.setSoLinger(true, 0);\n            Writer writer = new OutputStreamWriter(connection.getOutputStream(),\n                    B2CConverter.getCharset(\"US-ASCII\"));\n            writer.write(request1);\n            writer.flush();\n\n            bug55772Latch1.await();\n            connection.close();\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (IOException ioe) {\n                    // Ignore\n                }\n            }\n        }\n\n        bug55772Latch2.await();\n        bug55772IsSecondRequest = true;\n\n        try {\n            connection = new Socket(\"localhost\", getPort());\n            connection.setSoLinger(true, 0);\n            Writer writer = new OutputStreamWriter(connection.getOutputStream(),\n                    B2CConverter.getCharset(\"US-ASCII\"));\n            writer.write(request2);\n            writer.flush();\n            connection.getInputStream().read();\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (IOException ioe) {\n                    // Ignore\n                }\n            }\n        }\n\n        bug55772Latch3.await();\n        if (bug55772RequestStateLeaked) {\n            Assert.fail(\"State leaked between requests!\");\n        }\n    }"
            ],
            "java\\org\\apache\\coyote\\ajp\\AjpNioProcessor.java": [
                "    protected void actionInternal(ActionCode actionCode, Object param) {\n\n        if (actionCode == ActionCode.ASYNC_COMPLETE) {\n            if (asyncStateMachine.asyncComplete()) {\n                ((NioEndpoint)endpoint).processSocket(this.socket,\n                        SocketStatus.OPEN_READ, false);\n            }\n\n        } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {\n            if (param == null) return;\n            long timeout = ((Long)param).longValue();\n            final KeyAttachment ka = (KeyAttachment)socket.getAttachment(false);\n            ka.setTimeout(timeout);\n\n        } else if (actionCode == ActionCode.ASYNC_DISPATCH) {\n            if (asyncStateMachine.asyncDispatch()) {\n                ((NioEndpoint)endpoint).processSocket(this.socket,\n                        SocketStatus.OPEN_READ, true);\n            }\n        }\n    }\n\n    protected void resetTimeouts() {\n        // The NIO connector uses the timeout configured on the wrapper in the\n        // poller. Therefore, it needs to be reset once asycn processing has\n        // finished.\n        final KeyAttachment attach = (KeyAttachment)socket.getAttachment(false);\n        if (!error && attach != null &&\n                asyncStateMachine.isAsyncDispatching()) {\n            long soTimeout = endpoint.getSoTimeout();\n\n            //reset the timeout\n            if (keepAliveTimeout > 0) {\n                attach.setTimeout(keepAliveTimeout);\n            } else {\n                attach.setTimeout(soTimeout);\n            }\n        }\n\n    }",
                "    public boolean receive() throws IOException {\n\n        first = false;\n        bodyMessage.reset();\n        \n        readMessage(bodyMessage, true);\n\n        // No data received.\n        if (bodyMessage.getLen() == 0) {\n            // just the header\n            // Don't mark 'end of stream' for the first chunk.\n            return false;\n        }\n        int blen = bodyMessage.peekInt();\n        if (blen == 0) {\n            return false;\n        }\n\n        bodyMessage.getBodyBytes(bodyBytes);\n        empty = false;\n        return true;\n    }"
            ],
            "test\\org\\apache\\tomcat\\util\\net\\TestXxxEndpoint.java": [
                "    private long createAprPool() {\n\n        // Create the pool for the server socket\n        try {\n            return Pool.create(0);\n        } catch (UnsatisfiedLinkError e) {\n            log.error(\"Could not create socket pool\", e);\n            return 0;\n        }\n    }\n\n    private void destroyAprSocket(long serverSock, long pool) {\n        if (serverSock != 0) {\n            Socket.shutdown(serverSock, Socket.APR_SHUTDOWN_READWRITE);\n            Socket.close(serverSock);\n            Socket.destroy(serverSock);\n        }\n\n        if (pool != 0) {\n            Pool.destroy(pool);\n            pool = 0;\n        }\n    }",
                "    public void testStartStopBindOnInit() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n        File appDir = new File(getBuildDirectory(), \"webapps/examples\");\n        tomcat.addWebapp(null, \"/examples\", appDir.getAbsolutePath());\n\n        tomcat.start();\n\n        int port = getPort();\n\n        tomcat.getConnector().stop();\n        Exception e = null;\n        ServerSocket s = null;\n        long pool = 0;\n        long nativeSocket = 0;\n        boolean isApr = tomcat.getConnector().getProtocolHandlerClassName().contains(\"Apr\");\n        try {\n            // This should throw an Exception\n            if (isApr) {\n                pool = createAprPool();\n                assertTrue(pool != 0);\n                nativeSocket = createAprSocket(port, pool);\n                assertTrue(nativeSocket != 0);\n            } else {\n                s = new ServerSocket(port, 100,\n                        InetAddress.getByName(\"localhost\"));\n            }\n        } catch (Exception e1) {\n            e = e1;\n        } finally {\n            try {\n                if (isApr) {\n                    destroyAprSocket(nativeSocket, pool);\n                } else if (s != null) {\n                    s.close();\n                }\n            } catch (Exception e2) { /* Ignore */ }\n        }\n        if (e != null) {\n            log.info(\"Exception was\", e);\n        }\n        assertNotNull(e);\n        tomcat.getConnector().start();\n    }",
                "    public void testStartStopBindOnStart() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n        Connector c = tomcat.getConnector();\n        c.setProperty(\"bindOnInit\", \"false\");\n\n        File appDir = new File(getBuildDirectory(), \"webapps/examples\");\n        tomcat.addWebapp(null, \"/examples\", appDir.getAbsolutePath());\n\n\n        tomcat.start();\n        int port = getPort();\n\n        tomcat.getConnector().stop();\n        Exception e = null;\n        ServerSocket s = null;\n        long pool = 0;\n        long nativeSocket = 0;\n        boolean isApr = tomcat.getConnector().getProtocolHandlerClassName().contains(\"Apr\");\n        try {\n            // This should not throw an Exception\n            if (isApr) {\n                pool = createAprPool();\n                assertTrue(pool != 0);\n                nativeSocket = createAprSocket(port, pool);\n                assertTrue(nativeSocket != 0);\n            } else {\n                s = new ServerSocket(port, 100,\n                        InetAddress.getByName(\"localhost\"));\n            }\n        } catch (Exception e1) {\n            e = e1;\n        } finally {\n            try {\n                if (isApr) {\n                    destroyAprSocket(nativeSocket, pool);\n                } else if (s != null) {\n                    s.close();\n                }\n            } catch (Exception e2) { /* Ignore */ }\n        }\n        assertNull(e);\n        tomcat.getConnector().start();\n    }"
            ],
            "test\\org\\apache\\catalina\\valves\\TestErrorReportValve.java": [
                "    public void testBug53071() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        Tomcat.addServlet(ctx, \"errorServlet\", new ErrorServlet());\n        ctx.addServletMapping(\"/\", \"errorServlet\");\n\n        tomcat.start();\n\n        ByteChunk res = getUrl(\"http://localhost:\" + getPort());\n\n        Assert.assertTrue(res.toString().contains(\"<p><b>message</b> <u>\" +\n                ErrorServlet.ERROR_TEXT + \"</u></p>\"));\n    }\n\n    public void testBug54220DoNotSetNotFound() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        Tomcat.addServlet(ctx, \"bug54220\", new Bug54220Servlet(false));\n        ctx.addServletMapping(\"/\", \"bug54220\");\n\n        tomcat.start();\n\n        ByteChunk res = new ByteChunk();\n        int rc = getUrl(\"http://localhost:\" + getPort(), res, null);\n\n        Assert.assertNull(res.toString());\n        Assert.assertEquals(HttpServletResponse.SC_OK, rc);\n    }",
                "    public void testBug54220SetNotFound() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        Tomcat.addServlet(ctx, \"bug54220\", new Bug54220Servlet(true));\n        ctx.addServletMapping(\"/\", \"bug54220\");\n\n        tomcat.start();\n\n        ByteChunk res = new ByteChunk();\n        int rc = getUrl(\"http://localhost:\" + getPort(), res, null);\n\n        Assert.assertNull(res.toString());\n        Assert.assertEquals(HttpServletResponse.SC_NOT_FOUND, rc);\n    }\n\n    public void testBug54536() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        Tomcat.addServlet(ctx, \"bug54536\", new Bug54536Servlet());\n        ctx.addServletMapping(\"/\", \"bug54536\");\n\n        tomcat.start();\n\n        ByteChunk res = new ByteChunk();\n        int rc = getUrl(\"http://localhost:\" + getPort(), res, null);\n\n        Assert.assertEquals(Bug54536Servlet.ERROR_STATUS, rc);\n        String body = res.toString();\n        Assert.assertNotNull(body);\n        Assert.assertTrue(body, body.contains(Bug54536Servlet.ERROR_MESSAGE));\n    }",
                "    public void testBug56042() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        Bug56042Servlet bug56042Servlet = new Bug56042Servlet();\n        Wrapper wrapper =\n            Tomcat.addServlet(ctx, \"bug56042Servlet\", bug56042Servlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/bug56042Servlet\", \"bug56042Servlet\");\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/bug56042Servlet\");\n\n        ByteChunk res = new ByteChunk();\n        int rc = getUrl(url.toString(), res, null);\n\n        Assert.assertEquals(HttpServletResponse.SC_BAD_REQUEST, rc);\n    }"
            ],
            "test\\org\\apache\\catalina\\mbeans\\TestRegistration.java": [
                "    private static String[] hostMBeanNames(String host) {\n        return new String[] {\n            \"Tomcat:type=Host,host=\" + host,\n            \"Tomcat:type=Valve,host=\" + host + \",name=ErrorReportValve\",\n            \"Tomcat:type=Valve,host=\" + host + \",name=StandardHostValve\",\n        };\n    }\n\n    private String[] optionalMBeanNames(String host) {\n        if (isAccessLogEnabled()) {\n            return new String[] {\n                \"Tomcat:type=Valve,host=\" + host + \",name=AccessLogValve\",\n            };\n        } else {\n            return new String[] { };\n        }\n    }\n\n    private static String[] requestMBeanNames(String port, String type) {\n        return new String[] {\n            \"Tomcat:type=RequestProcessor,worker=\" +\n                    ObjectName.quote(\"http-\" + type + \"-\" + ADDRESS + \"-\" + port) +\n                    \",name=HttpRequest1\",\n        };\n    }",
                "    public void testMBeanDeregistration() throws Exception {\n        final MBeanServer mbeanServer = Registry.getRegistry(null, null).getMBeanServer();\n        // Verify there are no Catalina or Tomcat MBeans\n        Set<ObjectName> onames = mbeanServer.queryNames(new ObjectName(\"Catalina:*\"), null);\n        log.info(MBeanDumper.dumpBeans(mbeanServer, onames));\n        assertEquals(\"Unexpected: \" + onames, 0, onames.size());\n        onames = mbeanServer.queryNames(new ObjectName(\"Tomcat:*\"), null);\n        log.info(MBeanDumper.dumpBeans(mbeanServer, onames));\n        assertEquals(\"Unexpected: \" + onames, 0, onames.size());\n\n        final Tomcat tomcat = getTomcatInstance();\n        final File contextDir = new File(getTemporaryDirectory(), \"webappFoo\");\n        addDeleteOnTearDown(contextDir);\n        if (!contextDir.mkdirs() && !contextDir.isDirectory()) {\n            fail(\"Failed to create: [\" + contextDir.toString() + \"]\");\n        }\n        Context ctx = tomcat.addContext(contextName, contextDir.getAbsolutePath());\n\n        CombinedRealm combinedRealm = new CombinedRealm();\n        Realm nullRealm = new NullRealm();\n        combinedRealm.addRealm(nullRealm);\n        ctx.setRealm(combinedRealm);\n\n        // Disable keep-alive otherwise request processing threads in keep-alive\n        // won't shut down fast enough with BIO to de-register the processor\n        // triggering a test failure\n        tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", Integer.valueOf(1));\n\n        tomcat.start();\n\n        getUrl(\"http://localhost:\" + getPort());\n\n        // Verify there are no Catalina MBeans\n        onames = mbeanServer.queryNames(new ObjectName(\"Catalina:*\"), null);\n        log.info(MBeanDumper.dumpBeans(mbeanServer, onames));\n        assertEquals(\"Found: \" + onames, 0, onames.size());\n\n        // Verify there are the correct Tomcat MBeans\n        onames = mbeanServer.queryNames(new ObjectName(\"Tomcat:*\"), null);\n        ArrayList<String> found = new ArrayList<String>(onames.size());\n        for (ObjectName on: onames) {\n            found.add(on.toString());\n        }\n\n        // Create the list of expected MBean names\n        String protocol = tomcat.getConnector().getProtocolHandlerClassName();\n        if (protocol.indexOf(\"Nio\") > 0) {\n            protocol = \"nio\";\n        } else if (protocol.indexOf(\"Apr\") > 0) {\n            protocol = \"apr\";\n        } else {\n            protocol = \"bio\";\n        }\n        String index = tomcat.getConnector().getProperty(\"nameIndex\").toString();\n        ArrayList<String> expected = new ArrayList<String>(Arrays.asList(basicMBeanNames()));\n        expected.addAll(Arrays.asList(hostMBeanNames(\"localhost\")));\n        expected.addAll(Arrays.asList(contextMBeanNames(\"localhost\", contextName)));\n        expected.addAll(Arrays.asList(connectorMBeanNames(\"auto-\" + index, protocol)));\n        expected.addAll(Arrays.asList(optionalMBeanNames(\"localhost\")));\n        expected.addAll(Arrays.asList(requestMBeanNames(\n                \"auto-\" + index + \"-\" + getPort(), protocol)));\n\n        // Did we find all expected MBeans?\n        ArrayList<String> missing = new ArrayList<String>(expected);\n        missing.removeAll(found);\n        assertTrue(\"Missing Tomcat MBeans: \" + missing, missing.isEmpty());\n\n        // Did we find any unexpected MBeans?\n        List<String> additional = found;\n        additional.removeAll(expected);\n        assertTrue(\"Unexpected Tomcat MBeans: \" + additional, additional.isEmpty());\n\n        tomcat.stop();\n\n        // There should still be some Tomcat MBeans\n        onames = mbeanServer.queryNames(new ObjectName(\"Tomcat:*\"), null);\n        assertTrue(\"No Tomcat MBeans\", onames.size() > 0);\n\n        // add a new host\n        StandardHost host = new StandardHost();\n        host.setName(\"otherhost\");\n        tomcat.getEngine().addChild(host);\n\n        final File contextDir2 = new File(getTemporaryDirectory(), \"webappFoo2\");\n        addDeleteOnTearDown(contextDir2);\n        if (!contextDir2.mkdirs() && !contextDir2.isDirectory()) {\n            fail(\"Failed to create: [\" + contextDir2.toString() + \"]\");\n        }\n        tomcat.addContext(host, contextName + \"2\", contextDir2.getAbsolutePath());\n\n        tomcat.start();\n        tomcat.stop();\n        tomcat.destroy();\n\n        // There should be no Catalina MBeans and no Tomcat MBeans\n        onames = mbeanServer.queryNames(new ObjectName(\"Catalina:*\"), null);\n        log.info(MBeanDumper.dumpBeans(mbeanServer, onames));\n        assertEquals(\"Remaining: \" + onames, 0, onames.size());\n        onames = mbeanServer.queryNames(new ObjectName(\"Tomcat:*\"), null);\n        log.info(MBeanDumper.dumpBeans(mbeanServer, onames));\n        assertEquals(\"Remaining: \" + onames, 0, onames.size());\n    }"
            ],
            "test\\org\\apache\\catalina\\startup\\TomcatBaseTest.java": [
                "    public void tearDown() throws Exception {\n        try {\n            // Some tests may call tomcat.destroy(), some tests may just call\n            // tomcat.stop(), some not call either method. Make sure that stop()\n            // & destroy() are called as necessary.\n            if (tomcat.server != null\n                    && tomcat.server.getState() != LifecycleState.DESTROYED) {\n                if (tomcat.server.getState() != LifecycleState.STOPPED) {\n                    tomcat.stop();\n                }\n                tomcat.destroy();\n            }\n        } finally {\n            super.tearDown();\n        }\n    }"
            ],
            "test\\org\\apache\\catalina\\connector\\TestResponse.java": [
                "    public void testBug49598() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        Tomcat.addServlet(ctx, \"servlet\", new Bug49598Servlet());\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        tomcat.start();\n\n        Map<String,List<String>> headers = new HashMap<String,List<String>>();\n        getUrl(\"http://localhost:\" + getPort() + \"/\", new ByteChunk(), headers);\n\n        // Check for headers without a name\n        for (Map.Entry<String,List<String>> header : headers.entrySet()) {\n            if (header.getKey() == null) {\n                // Expected if this is the response line\n                List<String> values = header.getValue();\n                if (values.size() == 1 &&\n                        values.get(0).startsWith(\"HTTP/1.1\")) {\n                    continue;\n                }\n                fail(\"Null header name detected for value \" + values);\n            }\n        }\n\n        // Check for exactly one Set-Cookie header\n        int count = 0;\n        for (String headerName : headers.keySet()) {\n            if (\"Set-Cookie\".equals(headerName)) {\n                count ++;\n            }\n        }\n        assertEquals(1, count);\n    }",
                "    public void testCharset() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        Tomcat.addServlet(ctx, \"servlet\", new CharsetServlet());\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        tomcat.start();\n\n        ByteChunk bc = getUrl(\"http://localhost:\" + getPort() + \"/\");\n\n        assertEquals(\"OK\", bc.toString());\n    }\n\n    public void testBug52811() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        Tomcat.addServlet(ctx, \"servlet\", new Bug52811Servlet());\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        tomcat.start();\n\n        ByteChunk bc = getUrl(\"http://localhost:\" + getPort() + \"/\");\n\n        assertEquals(\"OK\", bc.toString());\n    }",
                "    public void testBug53062a() throws Exception {\n        Request req = new TesterRequest();\n        Response resp = new Response();\n        resp.setRequest(req);\n\n        String result = resp.toAbsolute(\"./bar.html\");\n\n        Assert.assertEquals(\"http://localhost:8080/level1/level2/bar.html\",\n                result);\n    }\n\n    public void testBug53062b() throws Exception {\n        Request req = new TesterRequest();\n        Response resp = new Response();\n        resp.setRequest(req);\n\n        String result = resp.toAbsolute(\".\");\n\n        Assert.assertEquals(\"http://localhost:8080/level1/level2/\", result);\n    }\n\n    public void testBug53062c() throws Exception {\n        Request req = new TesterRequest();\n        Response resp = new Response();\n        resp.setRequest(req);\n\n        String result = resp.toAbsolute(\"..\");\n\n        Assert.assertEquals(\"http://localhost:8080/level1/\", result);\n    }",
                "    public void testBug53062d() throws Exception {\n        Request req = new TesterRequest();\n        Response resp = new Response();\n        resp.setRequest(req);\n\n        String result = resp.toAbsolute(\".././..\");\n\n        Assert.assertEquals(\"http://localhost:8080/\", result);\n    }\n\n    public void testBug53062e() throws Exception {\n        Request req = new TesterRequest();\n        Response resp = new Response();\n        resp.setRequest(req);\n\n        resp.toAbsolute(\"../../..\");\n    }\n\n    public void testBug53062f() throws Exception {\n        Request req = new TesterRequest();\n        Response resp = new Response();\n        resp.setRequest(req);\n\n        String result = resp.toAbsolute(\"bar.html\");\n\n        Assert.assertEquals(\n                \"http://localhost:8080/level1/level2/bar.html\", result);\n    }",
                "    public void testBug53062g() throws Exception {\n        Request req = new TesterRequest();\n        Response resp = new Response();\n        resp.setRequest(req);\n\n        String result = resp.toAbsolute(\"bar.html?x=/../\");\n\n        Assert.assertEquals(\n                \"http://localhost:8080/level1/level2/bar.html?x=/../\", result);\n    }\n\n    public void testBug53062h() throws Exception {\n        Request req = new TesterRequest();\n        Response resp = new Response();\n        resp.setRequest(req);\n\n        String result = resp.toAbsolute(\"bar.html?x=/../../\");\n\n        Assert.assertEquals(\n                \"http://localhost:8080/level1/level2/bar.html?x=/../../\",\n                result);\n    }\n\n    public void testBug53062i() throws Exception {\n        Request req = new TesterRequest();\n        Response resp = new Response();\n        resp.setRequest(req);\n\n        String result = resp.toAbsolute(\"./.?x=/../../\");\n\n        Assert.assertEquals(\n                \"http://localhost:8080/level1/level2/?x=/../../\", result);\n    }",
                "    public void testBug53062j() throws Exception {\n        Request req = new TesterRequest();\n        Response resp = new Response();\n        resp.setRequest(req);\n\n        String result = resp.toAbsolute(\"./..?x=/../../\");\n\n        Assert.assertEquals(\"http://localhost:8080/level1/?x=/../../\", result);\n    }\n\n    public void testBug53062k() throws Exception {\n        Request req = new TesterRequest();\n        Response resp = new Response();\n        resp.setRequest(req);\n\n        String result = resp.toAbsolute(\"./..?x=/../..\");\n\n        Assert.assertEquals(\n                \"http://localhost:8080/level1/?x=/../..\",\n                result);\n    }\n\n    public void testBug53062l() throws Exception {\n        Request req = new TesterRequest();\n        Response resp = new Response();\n        resp.setRequest(req);\n\n        String result = resp.toAbsolute(\"bar.html#/../\");\n\n        Assert.assertEquals(\n                \"http://localhost:8080/level1/level2/bar.html#/../\", result);\n    }",
                "    public void testBug53062m() throws Exception {\n        Request req = new TesterRequest();\n        Response resp = new Response();\n        resp.setRequest(req);\n\n        String result = resp.toAbsolute(\"bar.html#/../../\");\n\n        Assert.assertEquals(\n                \"http://localhost:8080/level1/level2/bar.html#/../../\", result);\n    }\n\n    public void testBug53062n() throws Exception {\n        Request req = new TesterRequest();\n        Response resp = new Response();\n        resp.setRequest(req);\n\n        String result = resp.toAbsolute(\"./.#/../../\");\n\n        Assert.assertEquals(\n                \"http://localhost:8080/level1/level2/#/../../\", result);\n    }\n\n    public void testBug53062o() throws Exception {\n        Request req = new TesterRequest();\n        Response resp = new Response();\n        resp.setRequest(req);\n\n        String result = resp.toAbsolute(\"./..#/../../\");\n\n        Assert.assertEquals(\"http://localhost:8080/level1/#/../../\", result);\n    }",
                "    public void testBug53062p() throws Exception {\n        Request req = new TesterRequest();\n        Response resp = new Response();\n        resp.setRequest(req);\n\n        String result = resp.toAbsolute(\"./..#/../..\");\n\n        Assert.assertEquals(\"http://localhost:8080/level1/#/../..\", result);\n    }\n\n    public void testBug53469a() throws Exception {\n        Request req = new TesterRequest();\n        Response resp = new Response();\n        resp.setRequest(req);\n\n        String result = resp.encodeURL(\"../bar.html\");\n\n        Assert.assertEquals(\"../bar.html\", result);\n    }\n\n    public void testBug53469b() throws Exception {\n        Request req = new TesterRequest();\n        Response resp = new Response();\n        resp.setRequest(req);\n\n        String result = resp.encodeURL(\"../../../../bar.html\");\n\n        Assert.assertEquals(\"../../../../bar.html\", result);\n    }"
            ],
            "java\\org\\apache\\coyote\\http11\\upgrade\\NioServletOutputStream.java": [
                "    protected void doFlush() throws IOException {\n        NioEndpoint.KeyAttachment att =\n                (NioEndpoint.KeyAttachment) channel.getAttachment(false);\n        if (att == null) {\n            throw new IOException(\"Key must be cancelled\");\n        }\n        long writeTimeout = att.getWriteTimeout();\n        Selector selector = null;\n        try {\n            selector = pool.get();\n        } catch ( IOException x ) {\n            //ignore\n        }\n        try {\n            do {\n                if (channel.flush(true, selector, writeTimeout)) {\n                    break;\n                }\n            } while (true);\n        } finally {\n            if (selector != null) {\n                pool.put(selector);\n            }\n        }\n    }\n\n    protected void doClose() throws IOException {\n        channel.close(true);\n    }"
            ],
            "test\\org\\apache\\catalina\\authenticator\\TestFormAuthenticator.java": [
                "    public void testNoChangedSessidWithCookies() throws Exception {\n        doTest(\"GET\", \"GET\", NO_100_CONTINUE,\n                CLIENT_USE_COOKIES, SERVER_USE_COOKIES,\n                SERVER_FREEZE_SESSID);\n    }\n\n    public void testNoChangedSessidWithoutCookies() throws Exception {\n        doTest(\"GET\", \"GET\", NO_100_CONTINUE,\n                CLIENT_NO_COOKIES, SERVER_USE_COOKIES,\n                SERVER_FREEZE_SESSID);\n    }\n\n    public void testTimeoutWithoutCookies() throws Exception {\n        String protectedUri = doTest(\"GET\", \"GET\", NO_100_CONTINUE,\n                CLIENT_NO_COOKIES, SERVER_USE_COOKIES,\n                SERVER_FREEZE_SESSID);\n\n        // wait long enough for my session to expire\n        Thread.sleep(TIMEOUT_DELAY_MSECS);\n\n        // then try to continue using the expired session to get the\n        // protected resource once more.\n        // should get login challenge or timeout status 408\n        doTestProtected(\"GET\", protectedUri, NO_100_CONTINUE,\n                FormAuthClient.LOGIN_REQUIRED, 1);\n    }",
                "    public void doTestSelectedMethods() throws Exception {\n\n        FormAuthClientSelectedMethods client =\n                new FormAuthClientSelectedMethods(true, true, true);\n\n        // First request for protected resource gets the login page\n        client.doResourceRequest(\"PUT\", true, \"/test?\" +\n                SelectedMethodsServlet.PARAM + \"=\" +\n                SelectedMethodsServlet.VALUE, null);\n        assertTrue(client.getResponseLine(), client.isResponse200());\n        assertTrue(client.isResponseBodyOK());\n        String originalSessionId = client.getSessionId();\n        client.reset();\n\n        // Second request replies to the login challenge\n        client.doResourceRequest(\"POST\", true, \"/test/j_security_check\",\n                FormAuthClientBase.LOGIN_REPLY);\n        assertTrue(\"login failed \" + client.getResponseLine(),\n                client.isResponse302());\n        assertTrue(client.isResponseBodyOK());\n        String redirectUri = client.getRedirectUri();\n        client.reset();\n\n        // Third request - the login was successful so\n        // follow the redirect to the protected resource\n        client.doResourceRequest(\"GET\", true, redirectUri, null);\n        assertTrue(client.isResponse200());\n        assertTrue(client.isResponseBodyOK());\n        String newSessionId = client.getSessionId();\n\n        assertTrue(!originalSessionId.equals(newSessionId));\n        client.reset();\n    }"
            ]
        }
    }
}