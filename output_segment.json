{
    "56012": [
        "    public void doTag(TagPluginContext ctxt) {\n        \n        //flag for the existence of the var attribute\n        boolean hasVar = ctxt.isAttributeSpecified(\"var\");\n        \n        //temp name for exception and caught\n        String exceptionName = ctxt.getTemporaryVariableName();\n        String caughtName = ctxt.getTemporaryVariableName();\n        \n        //main part to generate code\n        ctxt.generateJavaSource(\"boolean \" + caughtName + \" = false;\");\n        ctxt.generateJavaSource(\"try{\");\n        ctxt.generateBody();\n        ctxt.generateJavaSource(\"}\");\n        \n        //do catch\n        ctxt.generateJavaSource(\"catch(Throwable \" + exceptionName + \"){\");\n        \n        //if the var specified, the exception object should \n        //be set to the attribute \"var\" defines in page scope \n        if(hasVar){\n            String strVar = ctxt.getConstantAttribute(\"var\");\n            ctxt.generateJavaSource(\"    pageContext.setAttribute(\\\"\" + strVar + \"\\\", \" \n                    + exceptionName + \", PageContext.PAGE_SCOPE);\");\n        }\n        \n        //whenever there's exception caught, \n        //the flag caught should be set true;\n        ctxt.generateJavaSource(\"    \" + caughtName + \" = true;\");\n        ctxt.generateJavaSource(\"}\");\n        \n        //do finally\n        ctxt.generateJavaSource(\"finally{\");\n        \n        //if var specified, the attribute it defines \n        //in page scope should be removed\n        if(hasVar){\n            String strVar = ctxt.getConstantAttribute(\"var\");\n            ctxt.generateJavaSource(\"    if(!\" + caughtName + \"){\");\n            ctxt.generateJavaSource(\"        pageContext.removeAttribute(\\\"\" + strVar + \"\\\", PageContext.PAGE_SCOPE);\");\n            ctxt.generateJavaSource(\"    }\");\n        }\n        \n        ctxt.generateJavaSource(\"}\");\n    }",
        "    public void doTag(TagPluginContext ctxt) {\n        \n        //scope flag\n        boolean hasScope = ctxt.isAttributeSpecified(\"scope\");\n        \n        //the value of the \"var\"\n        String strVar = ctxt.getConstantAttribute(\"var\");\n        \n        //remove attribute from certain scope.\n        //default scope is \"page\".\n        if(hasScope){\n            int iScope = Util.getScope(ctxt.getConstantAttribute(\"scope\"));\n            ctxt.generateJavaSource(\"pageContext.removeAttribute(\\\"\" + strVar + \"\\\",\" + iScope + \");\");\n        }else{\n            ctxt.generateJavaSource(\"pageContext.removeAttribute(\\\"\" + strVar + \"\\\");\");\n        }\n    }"
    ],
    "56029": [
        "    public void doTag(TagPluginContext ctxt) {\n        \n        //scope flag\n        boolean hasScope = ctxt.isAttributeSpecified(\"scope\");\n        \n        //the value of the \"var\"\n        String strVar = ctxt.getConstantAttribute(\"var\");\n        \n        //remove attribute from certain scope.\n        //default scope is \"page\".\n        if(hasScope){\n            int iScope = Util.getScope(ctxt.getConstantAttribute(\"scope\"));\n            ctxt.generateJavaSource(\"pageContext.removeAttribute(\\\"\" + strVar + \"\\\",\" + iScope + \");\");\n        }else{\n            ctxt.generateJavaSource(\"pageContext.removeAttribute(\\\"\" + strVar + \"\\\");\");\n        }\n    }",
        "    private ELNode.Nodes parseEL() {\n\n        StringBuilder buf = new StringBuilder();\n        ELexpr = new ELNode.Nodes();\n        curToken = null;\n        prevToken = null;\n        while (hasNext()) {\n            curToken = nextToken();\n            if (curToken instanceof Char) {\n                if (curToken.toChar() == '}') {\n                    break;\n                }\n                buf.append(curToken.toString());\n            } else {\n                // Output whatever is in buffer\n                if (buf.length() > 0) {\n                    ELexpr.add(new ELNode.ELText(buf.toString()));\n                    buf.setLength(0);\n                }\n                if (!parseFunction()) {\n                    ELexpr.add(new ELNode.ELText(curToken.toString()));\n                }\n            }\n        }"
    ],
    "55943": [
        "    public List<T> load(Class<T> serviceType) throws IOException {\n        String configFile = SERVICES + serviceType.getName();\n\n        LinkedHashSet<String> applicationServicesFound = new LinkedHashSet<String>();\n        LinkedHashSet<String> containerServicesFound = new LinkedHashSet<String>();\n\n        ClassLoader loader = context.getClassLoader();\n\n        // if the ServletContext has ORDERED_LIBS, then use that to specify the\n        // set of JARs from WEB-INF/lib that should be used for loading services\n        @SuppressWarnings(\"unchecked\")\n        List<String> orderedLibs =\n                (List<String>) context.getAttribute(ServletContext.ORDERED_LIBS);\n        if (orderedLibs != null) {\n            // handle ordered libs directly, ...\n            for (String lib : orderedLibs) {\n                URL jarUrl = context.getResource(LIB + lib);\n                if (jarUrl == null) {\n                    // should not happen, just ignore\n                    continue;\n                }\n\n                String base = jarUrl.toExternalForm();\n                URL url;\n                if (base.endsWith(\"/\")) {\n                    url = new URL(base + configFile);\n                } else {\n                    url = new URL(\"jar:\" + base + \"!/\" + configFile);\n                }\n                try {\n                    parseConfigFile(applicationServicesFound, url);\n                } catch (FileNotFoundException e) {\n                    // no provider file found, this is OK\n                }\n            }\n\n            // and the parent ClassLoader for all others\n            loader = loader.getParent();\n        }\n\n        Enumeration<URL> resources;\n        if (loader == null) {\n            resources = ClassLoader.getSystemResources(configFile);\n        } else {\n            resources = loader.getResources(configFile);\n        }\n        while (resources.hasMoreElements()) {\n            parseConfigFile(containerServicesFound, resources.nextElement());\n        }\n\n        // Filter the discovered container SCIs if required\n        if (containerSciFilterPattern != null) {\n            Iterator<String> iter = containerServicesFound.iterator();\n            while (iter.hasNext()) {\n                if (containerSciFilterPattern.matcher(iter.next()).find()) {\n                    iter.remove();\n                }\n            }\n        }\n\n        // Add the application services after the container services to ensure\n        // that the container services are loaded first\n        containerServicesFound.addAll(applicationServicesFound);\n\n        // load the discovered services\n        if (containerServicesFound.isEmpty()) {\n            return Collections.emptyList();\n        }\n        return loadServices(serviceType, containerServicesFound);\n    }",
        "    public List<String> clearJdbcDriverRegistrations() throws SQLException {\n        List<String> driverNames = new ArrayList<String>();\n\n        /*\n         * DriverManager.getDrivers() has a nasty side-effect of registering\n         * drivers that are visible to this class loader but haven't yet been\n         * loaded. Therefore, the first call to this method a) gets the list\n         * of originally loaded drivers and b) triggers the unwanted\n         * side-effect. The second call gets the complete list of drivers\n         * ensuring that both original drivers and any loaded as a result of the\n         * side-effects are all de-registered.\n         */\n        HashSet<Driver> originalDrivers = new HashSet<Driver>();\n        Enumeration<Driver> drivers = DriverManager.getDrivers();\n        while (drivers.hasMoreElements()) {\n            originalDrivers.add(drivers.nextElement());\n        }\n        drivers = DriverManager.getDrivers();\n        while (drivers.hasMoreElements()) {\n            Driver driver = drivers.nextElement();\n            // Only unload the drivers this web app loaded\n            if (driver.getClass().getClassLoader() !=\n                this.getClass().getClassLoader()) {\n                continue;\n            }\n            // Only report drivers that were originally registered. Skip any\n            // that were registered as a side-effect of this code.\n            if (originalDrivers.contains(driver)) {\n                driverNames.add(driver.getClass().getCanonicalName());\n            }\n            DriverManager.deregisterDriver(driver);\n        }\n        return driverNames;\n    }",
        "    public void testWebapp() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n        File appDir = new File(\"test/webapp-3.0-fragments-empty-absolute-ordering\");\n        StandardContext ctxt = (StandardContext) tomcat.addContext(null, \"/test\", appDir.getAbsolutePath());\n        ctxt.addLifecycleListener(new ContextConfig());\n        tomcat.start();\n\n        WebappServiceLoader<ServletContainerInitializer> loader =\n                new WebappServiceLoader<ServletContainerInitializer>(ctxt.getServletContext(), null);\n        @SuppressWarnings(\"unused\")\n        Collection<ServletContainerInitializer> initializers = loader.load(ServletContainerInitializer.class);\n    }",
        "    public void lifecycleEvent(LifecycleEvent event) {\n        // Initialise these classes when Tomcat starts\n        if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {\n\n            ClassLoader loader = Thread.currentThread().getContextClassLoader();\n\n            try\n            {\n                // Use the system classloader as the victim for all this\n                // ClassLoader pinning we're about to do.\n                Thread.currentThread().setContextClassLoader(\n                        ClassLoader.getSystemClassLoader());\n\n                /*\n                 * First call to this loads all drivers in the current class\n                 * loader\n                 */\n                if (driverManagerProtection) {\n                    DriverManager.getDrivers();\n                }\n\n                /*\n                 * Several components end up calling:\n                 * sun.awt.AppContext.getAppContext()\n                 * \n                 * Those libraries / components known to trigger memory leaks\n                 * due to eventual calls to getAppContext() are:\n                 * - Google Web Toolkit via its use of javax.imageio\n                 * - Tomcat via its use of java.beans.Introspector.flushCaches()\n                 *   in 1.6.0_15 to 1.7.0_01. From 1.7.0_02 onwards use of\n                 *   AppContext by Introspector.flushCaches() was replaced with\n                 *   ThreadGroupContext\n                 * - others TBD\n                 *\n                 * From 1.7.0_25 onwards, a call to\n                 * sun.awt.AppContext.getAppContext() results in a thread being\n                 * started named AWT-AppKit that requires a graphic environment\n                 * to be available.\n                 */\n                \n                // Trigger a call to sun.awt.AppContext.getAppContext(). This\n                // will pin the system class loader in memory but that shouldn't\n                // be an issue.\n                if (appContextProtection) {\n                    ImageIO.getCacheDirectory();\n                }\n\n                // Trigger the creation of the AWT (AWT-Windows, AWT-XAWT,\n                // etc.) thread\n                if (awtThreadProtection) {\n                  java.awt.Toolkit.getDefaultToolkit();\n                }\n\n                // Trigger the creation of the \"Java2D Disposer\" thread.\n                // See https://issues.apache.org/bugzilla/show_bug.cgi?id=51687\n                if(java2dDisposerProtection) {\n                    try {\n                        Class.forName(\"sun.java2d.Disposer\");\n                    }\n                    catch (ClassNotFoundException cnfe) {\n                        // Ignore this case: we must be running on a\n                        // non-Sun-based JRE.\n                    }\n                }\n\n                /*\n                 * Several components end up calling\n                 * sun.misc.GC.requestLatency(long) which creates a daemon\n                 * thread without setting the TCCL.\n                 * \n                 * Those libraries / components known to trigger memory leaks\n                 * due to eventual calls to requestLatency(long) are:\n                 * - javax.management.remote.rmi.RMIConnectorServer.start()\n                 *\n                 * Note: Long.MAX_VALUE is a special case that causes the thread\n                 *       to terminate\n                 *\n                 */\n                if (gcDaemonProtection) {\n                    try {\n                        Class<?> clazz = Class.forName(\"sun.misc.GC\");\n                        Method method = clazz.getDeclaredMethod(\n                                \"requestLatency\",\n                                new Class[] {long.class});\n                        method.invoke(null, Long.valueOf(Long.MAX_VALUE - 1));\n                    } catch (ClassNotFoundException e) {\n                        if (Globals.IS_ORACLE_JVM) {\n                            log.error(sm.getString(\n                                    \"jreLeakListener.gcDaemonFail\"), e);\n                        } else {\n                            log.debug(sm.getString(\n                                    \"jreLeakListener.gcDaemonFail\"), e);\n                        }\n                    } catch (SecurityException e) {\n                        log.error(sm.getString(\"jreLeakListener.gcDaemonFail\"),\n                                e);\n                    } catch (NoSuchMethodException e) {\n                        log.error(sm.getString(\"jreLeakListener.gcDaemonFail\"),\n                                e);\n                    } catch (IllegalArgumentException e) {\n                        log.error(sm.getString(\"jreLeakListener.gcDaemonFail\"),\n                                e);\n                    } catch (IllegalAccessException e) {\n                        log.error(sm.getString(\"jreLeakListener.gcDaemonFail\"),\n                                e);\n                    } catch (InvocationTargetException e) {\n                        ExceptionUtils.handleThrowable(e.getCause());\n                        log.error(sm.getString(\"jreLeakListener.gcDaemonFail\"),\n                                e);\n                    }\n                }\n    \n                /*\n                 * Calling getPolicy retains a static reference to the context \n                 * class loader.\n                 */\n                if (securityPolicyProtection) {\n                    try {\n                        // Policy.getPolicy();\n                        Class<?> policyClass = Class\n                                .forName(\"javax.security.auth.Policy\");\n                        Method method = policyClass.getMethod(\"getPolicy\");\n                        method.invoke(null);\n                    } catch(ClassNotFoundException e) {\n                        // Ignore. The class is deprecated.\n                    } catch(SecurityException e) {\n                        // Ignore. Don't need call to getPolicy() to be\n                        // successful, just need to trigger static initializer.\n                    } catch (NoSuchMethodException e) {\n                        log.warn(sm.getString(\"jreLeakListener.authPolicyFail\"),\n                                e);\n                    } catch (IllegalArgumentException e) {\n                        log.warn(sm.getString(\"jreLeakListener.authPolicyFail\"),\n                                e);\n                    } catch (IllegalAccessException e) {\n                        log.warn(sm.getString(\"jreLeakListener.authPolicyFail\"),\n                                e);\n                    } catch (InvocationTargetException e) {\n                        ExceptionUtils.handleThrowable(e.getCause());\n                        log.warn(sm.getString(\"jreLeakListener.authPolicyFail\"),\n                                e);\n                    }\n                }\n    \n                \n                /*\n                 * Initializing javax.security.auth.login.Configuration retains a static reference to the context \n                 * class loader.\n                 */\n                if (securityLoginConfigurationProtection) {\n                    try {\n                        Class.forName(\"javax.security.auth.login.Configuration\", true, ClassLoader.getSystemClassLoader());\n                    } catch(ClassNotFoundException e) {\n                        // Ignore\n                    }\n                }\n\n                /*\n                 * Creating a MessageDigest during web application startup\n                 * initializes the Java Cryptography Architecture. Under certain\n                 * conditions this starts a Token poller thread with TCCL equal\n                 * to the web application class loader.\n                 * \n                 * Instead we initialize JCA right now.\n                 */\n                if (tokenPollerProtection) {\n                    java.security.Security.getProviders();\n                }\n                \n                /*\n                 * Several components end up opening JarURLConnections without\n                 * first disabling caching. This effectively locks the file.\n                 * Whilst more noticeable and harder to ignore on Windows, it\n                 * affects all operating systems.\n                 * \n                 * Those libraries/components known to trigger this issue\n                 * include:\n                 * - log4j versions 1.2.15 and earlier\n                 * - javax.xml.bind.JAXBContext.newInstance()\n                 */\n                \n                // Set the default URL caching policy to not to cache\n                if (urlCacheProtection) {\n                    try {\n                        // Doesn't matter that this JAR doesn't exist - just as\n                        // long as the URL is well-formed\n                        URL url = new URL(\"jar:file://dummy.jar!/\");\n                        URLConnection uConn = url.openConnection();\n                        uConn.setDefaultUseCaches(false);\n                    } catch (MalformedURLException e) {\n                        log.error(sm.getString(\n                                \"jreLeakListener.jarUrlConnCacheFail\"), e);\n                    } catch (IOException e) {\n                        log.error(sm.getString(\n                                \"jreLeakListener.jarUrlConnCacheFail\"), e);\n                    }\n                }\n                \n                /*\n                 * Haven't got to the root of what is going on with this leak\n                 * but if a web app is the first to make the calls below the web\n                 * application class loader will be pinned in memory.\n                 */\n                if (xmlParsingProtection) {\n                    DocumentBuilderFactory factory =\n                        DocumentBuilderFactory.newInstance();\n                    try {\n                        factory.newDocumentBuilder();\n                    } catch (ParserConfigurationException e) {\n                        log.error(sm.getString(\"jreLeakListener.xmlParseFail\"),\n                                e);\n                    }\n                }\n                \n                if (ldapPoolProtection) {\n                    try {\n                        Class.forName(\"com.sun.jndi.ldap.LdapPoolManager\");\n                    } catch (ClassNotFoundException e) {\n                        if (Globals.IS_ORACLE_JVM) {\n                            log.error(sm.getString(\n                                    \"jreLeakListener.ldapPoolManagerFail\"), e);\n                        } else {\n                            log.debug(sm.getString(\n                                    \"jreLeakListener.ldapPoolManagerFail\"), e);\n                        }\n                    }\n                }\n                \n                if (classesToInitialize != null) {\n                    StringTokenizer strTok =\n                        new StringTokenizer(classesToInitialize, \", \\r\\n\\t\");\n                    while (strTok.hasMoreTokens()) {\n                        String classNameToLoad = strTok.nextToken();\n                        try {\n                            Class.forName(classNameToLoad);\n                        } catch (ClassNotFoundException e) {\n                            log.error(\n                                sm.getString(\"jreLeakListener.classToInitializeFail\",\n                                    classNameToLoad), e);\n                            // continue with next class to load\n                        }\n                    }\n                }\n\n            } finally {\n                Thread.currentThread().setContextClassLoader(loader);\n            }\n        }\n    }",
        "    public void addRepository(String repository) {\n\n        if (log.isDebugEnabled())\n            log.debug(sm.getString(\"webappLoader.addRepository\", repository));\n\n        for (int i = 0; i < repositories.length; i++) {\n            if (repository.equals(repositories[i]))\n                return;\n        }\n        String results[] = new String[repositories.length + 1];\n        for (int i = 0; i < repositories.length; i++)\n            results[i] = repositories[i];\n        results[repositories.length] = repository;\n        repositories = results;\n\n        if (getState().isAvailable() && (classLoader != null)) {\n            classLoader.addRepository(repository);\n            if( loaderRepositories != null ) loaderRepositories.add(repository);\n            setClassPath();\n        }\n\n    }\n\n    public void backgroundProcess() {\n        if (reloadable && modified()) {\n            try {\n                Thread.currentThread().setContextClassLoader\n                    (WebappLoader.class.getClassLoader());\n                if (container instanceof StandardContext) {\n                    ((StandardContext) container).reload();\n                }\n            } finally {\n                if (container.getLoader() != null) {\n                    Thread.currentThread().setContextClassLoader\n                        (container.getLoader().getClassLoader());\n                }\n            }\n        } else {\n            closeJARs(false);\n        }\n    }",
        "    public void closeJARs(boolean force) {\n        if (classLoader !=null) {\n            classLoader.closeJARs(force);\n        }\n    }",
        "    protected void startInternal() throws LifecycleException {\n\n        if (log.isDebugEnabled())\n            log.debug(sm.getString(\"webappLoader.starting\"));\n\n        if (container.getResources() == null) {\n            log.info(\"No resources for \" + container);\n            setState(LifecycleState.STARTING);\n            return;\n        }\n\n        // Register a stream handler factory for the JNDI protocol\n        URLStreamHandlerFactory streamHandlerFactory =\n                DirContextURLStreamHandlerFactory.getInstance();\n        if (first) {\n            first = false;\n            try {\n                URL.setURLStreamHandlerFactory(streamHandlerFactory);\n            } catch (Exception e) {\n                // Log and continue anyway, this is not critical\n                log.error(\"Error registering jndi stream handler\", e);\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                // This is likely a dual registration\n                log.info(\"Dual registration of jndi stream handler: \"\n                         + t.getMessage());\n            }\n        }\n\n        // Construct a class loader based on our current repositories list\n        try {\n\n            classLoader = createClassLoader();\n            classLoader.setResources(container.getResources());\n            classLoader.setDelegate(this.delegate);\n            classLoader.setSearchExternalFirst(searchExternalFirst);\n            if (container instanceof StandardContext) {\n                classLoader.setAntiJARLocking(\n                        ((StandardContext) container).getAntiJARLocking());\n                classLoader.setClearReferencesStatic(\n                        ((StandardContext) container).getClearReferencesStatic());\n                classLoader.setClearReferencesStopThreads(\n                        ((StandardContext) container).getClearReferencesStopThreads());\n                classLoader.setClearReferencesStopTimerThreads(\n                        ((StandardContext) container).getClearReferencesStopTimerThreads());\n                classLoader.setClearReferencesHttpClientKeepAliveThread(\n                        ((StandardContext) container).getClearReferencesHttpClientKeepAliveThread());\n            }\n\n            for (int i = 0; i < repositories.length; i++) {\n                classLoader.addRepository(repositories[i]);\n            }\n\n            // Configure our repositories\n            setRepositories();\n            setClassPath();\n\n            setPermissions();\n\n            ((Lifecycle) classLoader).start();\n\n            // Binding the Webapp class loader to the directory context\n            DirContextURLStreamHandler.bind(classLoader,\n                    this.container.getResources());\n\n            StandardContext ctx=(StandardContext)container;\n            String contextName = ctx.getName();\n            if (!contextName.startsWith(\"/\")) {\n                contextName = \"/\" + contextName;\n            }\n            ObjectName cloname = new ObjectName\n                (MBeanUtils.getDomain(ctx) + \":type=WebappClassLoader,context=\"\n                 + contextName + \",host=\" + ctx.getParent().getName());\n            Registry.getRegistry(null, null)\n                .registerComponent(classLoader, cloname, null);\n\n        } catch (Throwable t) {\n            t = ExceptionUtils.unwrapInvocationTargetException(t);\n            ExceptionUtils.handleThrowable(t);\n            log.error( \"LifecycleException \", t );\n            throw new LifecycleException(\"start: \", t);\n        }\n\n        setState(LifecycleState.STARTING);\n    }",
        "    protected void stopInternal() throws LifecycleException {\n\n        if (log.isDebugEnabled())\n            log.debug(sm.getString(\"webappLoader.stopping\"));\n\n        setState(LifecycleState.STOPPING);\n\n        // Remove context attributes as appropriate\n        if (container instanceof Context) {\n            ServletContext servletContext =\n                ((Context) container).getServletContext();\n            servletContext.removeAttribute(Globals.CLASS_PATH_ATTR);\n        }\n\n        // Throw away our current class loader\n        if (classLoader != null) {\n            ((Lifecycle) classLoader).stop();\n            DirContextURLStreamHandler.unbind(classLoader);\n        }\n\n        try {\n            StandardContext ctx=(StandardContext)container;\n            String contextName = ctx.getName();\n            if (!contextName.startsWith(\"/\")) {\n                contextName = \"/\" + contextName;\n            }\n            ObjectName cloname = new ObjectName\n                (MBeanUtils.getDomain(ctx) + \":type=WebappClassLoader,context=\"\n                 + contextName + \",host=\" + ctx.getParent().getName());\n            Registry.getRegistry(null, null).unregisterComponent(cloname);\n        } catch (Exception e) {\n            log.error(\"LifecycleException \", e);\n        }\n\n        classLoader = null;\n    }",
        "    protected void startInternal() throws LifecycleException {\n\n        // just add any jar/directory set in virtual classpath to the\n        // repositories list before calling start on the standard WebappLoader\n        StringTokenizer tkn = new StringTokenizer(virtualClasspath, \";\");\n        Set<String> set = new LinkedHashSet<String>();\n        while (tkn.hasMoreTokens()) {\n            String token = tkn.nextToken().trim();\n\n            if (token.isEmpty()) {\n                continue;\n            }\n\n            if (log.isDebugEnabled())\n                log.debug(sm.getString(\"virtualWebappLoader.token\", token));\n\n            if (token.endsWith(\"*.jar\")) {\n                // glob\n                token = token.substring(0, token.length() - \"*.jar\".length());\n\n                File directory = new File(token);\n                if (!directory.isDirectory()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\n                                \"virtualWebappLoader.token.notDirectory\",\n                                directory.getAbsolutePath()));\n                    }\n                    continue;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                            \"virtualWebappLoader.token.glob.dir\",\n                            directory.getAbsolutePath()));\n                }\n                String filenames[] = directory.list();\n                Arrays.sort(filenames);\n                for (int j = 0; j < filenames.length; j++) {\n                    String filename = filenames[j].toLowerCase(Locale.ENGLISH);\n                    if (!filename.endsWith(\".jar\"))\n                        continue;\n                    File file = new File(directory, filenames[j]);\n                    if (!file.isFile()) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\n                                    \"virtualWebappLoader.token.notFile\",\n                                    file.getAbsolutePath()));\n                        }\n                        continue;\n                    }\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\n                                \"virtualWebappLoader.token.file\",\n                                file.getAbsolutePath()));\n                    }\n                    set.add(file.toURI().toString());\n                }\n            } else {\n                // single file or directory\n                File file = new File(token);\n                if (!file.exists()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\n                                \"virtualWebappLoader.token.notExists\",\n                                file.getAbsolutePath()));\n                    }\n                    continue;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                            \"virtualWebappLoader.token.file\",\n                            file.getAbsolutePath()));\n                }\n                set.add(file.toURI().toString());\n            }\n        }\n\n        for (String repository: set) {\n            addRepository(repository);\n        }\n\n        super.startInternal();\n    }",
        "    public static void release(ClassLoader classLoader) {\n        // JULI's log manager looks at the current classLoader so there is no\n        // need to use the passed in classLoader, the default implementation\n        // does not so calling reset in that case will break things\n        if (!LogManager.getLogManager().getClass().getName().equals(\n                \"java.util.logging.LogManager\")) {\n            LogManager.getLogManager().reset();\n        }\n    }\n\n    public static String objectId(Object o) {\n        if (o == null) {\n            return \"null\";\n        } else {\n            return o.getClass().getName() + \"@\" + System.identityHashCode(o);\n        }\n    }",
        "    public void addPermission(String filepath) {\n        if (filepath == null) {\n            return;\n        }\n\n        String path = filepath;\n\n        if (securityManager != null) {\n            Permission permission = null;\n            if (path.startsWith(\"jndi:\") || path.startsWith(\"jar:jndi:\")) {\n                if (!path.endsWith(\"/\")) {\n                    path = path + \"/\";\n                }\n                permission = new JndiPermission(path + \"*\");\n                addPermission(permission);\n            } else {\n                if (!path.endsWith(File.separator)) {\n                    permission = new FilePermission(path, \"read\");\n                    addPermission(permission);\n                    path = path + File.separator;\n                }\n                permission = new FilePermission(path + \"-\", \"read\");\n                addPermission(permission);\n            }\n        }\n    }\n\n    public void addPermission(URL url) {\n        if (url != null) {\n            addPermission(url.toString());\n        }\n    }\n\n    public void addPermission(Permission permission) {\n        if ((securityManager != null) && (permission != null)) {\n            permissionList.add(permission);\n        }\n    }",
        "    public void addRepository(String repository) {\n\n        // Ignore any of the standard repositories, as they are set up using\n        // either addJar or addRepository\n        if (repository.startsWith(\"/WEB-INF/lib\")\n            || repository.startsWith(\"/WEB-INF/classes\"))\n            return;\n\n        // Add this repository to our underlying class loader\n        try {\n            URL url = new URL(repository);\n            super.addURL(url);\n            hasExternalRepositories = true;\n            repositoryURLs = null;\n        } catch (MalformedURLException e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Invalid repository: \" + repository);\n            iae.initCause(e);\n            throw iae;\n        }\n\n    }",
        "    public Class<?> findClass(String name) throws ClassNotFoundException {\n\n        if (log.isDebugEnabled())\n            log.debug(\"    findClass(\" + name + \")\");\n\n        // Cannot load anything from local repositories if class loader is stopped\n        if (!started) {\n            throw new ClassNotFoundException(name);\n        }\n\n        // (1) Permission to define this class when using a SecurityManager\n        if (securityManager != null) {\n            int i = name.lastIndexOf('.');\n            if (i >= 0) {\n                try {\n                    if (log.isTraceEnabled())\n                        log.trace(\"      securityManager.checkPackageDefinition\");\n                    securityManager.checkPackageDefinition(name.substring(0,i));\n                } catch (Exception se) {\n                    if (log.isTraceEnabled())\n                        log.trace(\"      -->Exception-->ClassNotFoundException\", se);\n                    throw new ClassNotFoundException(name, se);\n                }\n            }\n        }\n\n        // Ask our superclass to locate this class, if possible\n        // (throws ClassNotFoundException if it is not found)\n        Class<?> clazz = null;\n        try {\n            if (log.isTraceEnabled())\n                log.trace(\"      findClassInternal(\" + name + \")\");\n            if (hasExternalRepositories && searchExternalFirst) {\n                try {\n                    clazz = super.findClass(name);\n                } catch(ClassNotFoundException cnfe) {\n                    // Ignore - will search internal repositories next\n                } catch(AccessControlException ace) {\n                    log.warn(\"WebappClassLoader.findClassInternal(\" + name\n                            + \") security exception: \" + ace.getMessage(), ace);\n                    throw new ClassNotFoundException(name, ace);\n                } catch (RuntimeException e) {\n                    if (log.isTraceEnabled())\n                        log.trace(\"      -->RuntimeException Rethrown\", e);\n                    throw e;\n                }\n            }\n            if ((clazz == null)) {\n                try {\n                    clazz = findClassInternal(name);\n                } catch(ClassNotFoundException cnfe) {\n                    if (!hasExternalRepositories || searchExternalFirst) {\n                        throw cnfe;\n                    }\n                } catch(AccessControlException ace) {\n                    log.warn(\"WebappClassLoader.findClassInternal(\" + name\n                            + \") security exception: \" + ace.getMessage(), ace);\n                    throw new ClassNotFoundException(name, ace);\n                } catch (RuntimeException e) {\n                    if (log.isTraceEnabled())\n                        log.trace(\"      -->RuntimeException Rethrown\", e);\n                    throw e;\n                }\n            }\n            if ((clazz == null) && hasExternalRepositories && !searchExternalFirst) {\n                try {\n                    clazz = super.findClass(name);\n                } catch(AccessControlException ace) {\n                    log.warn(\"WebappClassLoader.findClassInternal(\" + name\n                            + \") security exception: \" + ace.getMessage(), ace);\n                    throw new ClassNotFoundException(name, ace);\n                } catch (RuntimeException e) {\n                    if (log.isTraceEnabled())\n                        log.trace(\"      -->RuntimeException Rethrown\", e);\n                    throw e;\n                }\n            }\n            if (clazz == null) {\n                if (log.isDebugEnabled())\n                    log.debug(\"    --> Returning ClassNotFoundException\");\n                throw new ClassNotFoundException(name);\n            }\n        } catch (ClassNotFoundException e) {\n            if (log.isTraceEnabled())\n                log.trace(\"    --> Passing on ClassNotFoundException\");\n            throw e;\n        }\n\n        // Return the class we have located\n        if (log.isTraceEnabled())\n            log.debug(\"      Returning class \" + clazz);\n\n        if (log.isTraceEnabled()) {\n            ClassLoader cl;\n            if (Globals.IS_SECURITY_ENABLED){\n                cl = AccessController.doPrivileged(\n                    new PrivilegedGetClassLoader(clazz));\n            } else {\n                cl = clazz.getClassLoader();\n            }\n            log.debug(\"      Loaded by \" + cl.toString());\n        }\n        return (clazz);\n\n    }",
        "    public URL findResource(final String name) {\n\n        if (log.isDebugEnabled())\n            log.debug(\"    findResource(\" + name + \")\");\n\n        URL url = null;\n\n        if (hasExternalRepositories && searchExternalFirst)\n            url = super.findResource(name);\n\n        if (url == null) {\n            ResourceEntry entry = resourceEntries.get(name);\n            if (entry == null) {\n                if (securityManager != null) {\n                    PrivilegedAction<ResourceEntry> dp =\n                        new PrivilegedFindResourceByName(name, name);\n                    entry = AccessController.doPrivileged(dp);\n                } else {\n                    entry = findResourceInternal(name, name);\n                }\n            }\n            if (entry != null) {\n                url = entry.source;\n            }\n        }\n\n        if ((url == null) && hasExternalRepositories && !searchExternalFirst)\n            url = super.findResource(name);\n\n        if (log.isDebugEnabled()) {\n            if (url != null)\n                log.debug(\"    --> Returning '\" + url.toString() + \"'\");\n            else\n                log.debug(\"    --> Resource not found, returning null\");\n        }\n        return (url);\n\n    }",
        "    public Enumeration<URL> findResources(String name) throws IOException {\n\n        if (log.isDebugEnabled())\n            log.debug(\"    findResources(\" + name + \")\");\n\n        //we use a LinkedHashSet instead of a Vector to avoid duplicates with virtualmappings\n        LinkedHashSet<URL> result = new LinkedHashSet<URL>();\n\n        int jarFilesLength = jarFiles.length;\n        int repositoriesLength = repositories.length;\n\n        int i;\n\n        // Adding the results of a call to the superclass\n        if (hasExternalRepositories && searchExternalFirst) {\n\n            Enumeration<URL> otherResourcePaths = super.findResources(name);\n\n            while (otherResourcePaths.hasMoreElements()) {\n                result.add(otherResourcePaths.nextElement());\n            }\n\n        }\n        // Looking at the repositories\n        for (i = 0; i < repositoriesLength; i++) {\n            try {\n                String fullPath = repositories[i] + name;\n                resources.lookup(fullPath);\n                // Note : Not getting an exception here means the resource was\n                // found\n                try {\n                    result.add(getURI(new File(files[i], name)));\n                } catch (MalformedURLException e) {\n                    // Ignore\n                }\n            } catch (NamingException e) {\n                // Ignore\n            }\n        }\n\n        // Looking at the JAR files\n        synchronized (jarFiles) {\n            if (openJARs()) {\n                for (i = 0; i < jarFilesLength; i++) {\n                    JarEntry jarEntry = jarFiles[i].getJarEntry(name);\n                    if (jarEntry != null) {\n                        try {\n                            String jarFakeUrl = getURI(jarRealFiles[i]).toString();\n                            jarFakeUrl = \"jar:\" + jarFakeUrl + \"!/\" + name;\n                            result.add(new URL(jarFakeUrl));\n                        } catch (MalformedURLException e) {\n                            // Ignore\n                        }\n                    }\n                }\n            }\n        }\n\n        // Adding the results of a call to the superclass\n        if (hasExternalRepositories && !searchExternalFirst) {\n\n            Enumeration<URL> otherResourcePaths = super.findResources(name);\n\n            while (otherResourcePaths.hasMoreElements()) {\n                result.add(otherResourcePaths.nextElement());\n            }\n\n        }\n\n        return Collections.enumeration(result);\n    }",
        "    public Class<?> loadClass(String name) throws ClassNotFoundException {\n\n        return (loadClass(name, false));\n\n    }\n\n    public void start() throws LifecycleException {\n\n        started = true;\n        String encoding = null;\n        try {\n            encoding = System.getProperty(\"file.encoding\");\n        } catch (SecurityException e) {\n            return;\n        }\n        if (encoding.indexOf(\"EBCDIC\")!=-1) {\n            needConvert = true;\n        }\n\n    }",
        "    public void stop() throws LifecycleException {\n\n        // Clearing references should be done before setting started to\n        // false, due to possible side effects\n        clearReferences();\n\n        started = false;\n\n        int length = files.length;\n        for (int i = 0; i < length; i++) {\n            files[i] = null;\n        }\n\n        length = jarFiles.length;\n        for (int i = 0; i < length; i++) {\n            try {\n                if (jarFiles[i] != null) {\n                    jarFiles[i].close();\n                }\n            } catch (IOException e) {\n                // Ignore\n            }\n            jarFiles[i] = null;\n        }\n\n        notFoundResources.clear();\n        resourceEntries.clear();\n        resources = null;\n        repositories = null;\n        repositoryURLs = null;\n        files = null;\n        jarFiles = null;\n        jarRealFiles = null;\n        jarPath = null;\n        jarNames = null;\n        lastModifiedDates = null;\n        paths = null;\n        hasExternalRepositories = false;\n        parent = null;\n\n        permissionList.clear();\n        loaderPC.clear();\n\n        if (loaderDir != null) {\n            deleteDir(loaderDir);\n        }\n\n    }",
        "    private final void clearReferencesJdbc() {\n        InputStream is = getResourceAsStream(\n                \"org/apache/catalina/loader/JdbcLeakPrevention.class\");\n        // We know roughly how big the class will be (~ 1K) so allow 2k as a\n        // starting point\n        byte[] classBytes = new byte[2048];\n        int offset = 0;\n        try {\n            int read = is.read(classBytes, offset, classBytes.length-offset);\n            while (read > -1) {\n                offset += read;\n                if (offset == classBytes.length) {\n                    // Buffer full - double size\n                    byte[] tmp = new byte[classBytes.length * 2];\n                    System.arraycopy(classBytes, 0, tmp, 0, classBytes.length);\n                    classBytes = tmp;\n                }\n                read = is.read(classBytes, offset, classBytes.length-offset);\n            }\n            Class<?> lpClass =\n                defineClass(\"org.apache.catalina.loader.JdbcLeakPrevention\",\n                    classBytes, 0, offset, this.getClass().getProtectionDomain());\n            Object obj = lpClass.newInstance();\n            @SuppressWarnings(\"unchecked\") // clearJdbcDriverRegistrations() returns List<String>\n            List<String> driverNames = (List<String>) obj.getClass().getMethod(\n                    \"clearJdbcDriverRegistrations\").invoke(obj);\n            for (String name : driverNames) {\n                log.error(sm.getString(\"webappClassLoader.clearJdbc\",\n                        contextName, name));\n            }\n        } catch (Exception e) {\n            // So many things to go wrong above...\n            Throwable t = ExceptionUtils.unwrapInvocationTargetException(e);\n            ExceptionUtils.handleThrowable(t);\n            log.warn(sm.getString(\n                    \"webappClassLoader.jdbcRemoveFailed\", contextName), t);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException ioe) {\n                    log.warn(sm.getString(\n                            \"webappClassLoader.jdbcRemoveStreamError\",\n                            contextName), ioe);\n                }\n            }\n        }\n    }",
        "    private final void clearReferencesStaticFinal() {\n\n        @SuppressWarnings(\"unchecked\") // resourceEntries is HashMap<String, ResourceEntry>\n        Collection<ResourceEntry> values =\n            ((HashMap<String,ResourceEntry>) resourceEntries.clone()).values();\n        Iterator<ResourceEntry> loadedClasses = values.iterator();\n        //\n        // walk through all loaded class to trigger initialization for\n        //    any uninitialized classes, otherwise initialization of\n        //    one class may call a previously cleared class.\n        while(loadedClasses.hasNext()) {\n            ResourceEntry entry = loadedClasses.next();\n            if (entry.loadedClass != null) {\n                Class<?> clazz = entry.loadedClass;\n                try {\n                    Field[] fields = clazz.getDeclaredFields();\n                    for (int i = 0; i < fields.length; i++) {\n                        if(Modifier.isStatic(fields[i].getModifiers())) {\n                            fields[i].get(null);\n                            break;\n                        }\n                    }\n                } catch(Throwable t) {\n                    // Ignore\n                }\n            }\n        }\n        loadedClasses = values.iterator();\n        while (loadedClasses.hasNext()) {\n            ResourceEntry entry = loadedClasses.next();\n            if (entry.loadedClass != null) {\n                Class<?> clazz = entry.loadedClass;\n                try {\n                    Field[] fields = clazz.getDeclaredFields();\n                    for (int i = 0; i < fields.length; i++) {\n                        Field field = fields[i];\n                        int mods = field.getModifiers();\n                        if (field.getType().isPrimitive()\n                                || (field.getName().indexOf(\"$\") != -1)) {\n                            continue;\n                        }\n                        if (Modifier.isStatic(mods)) {\n                            try {\n                                field.setAccessible(true);\n                                if (Modifier.isFinal(mods)) {\n                                    if (!((field.getType().getName().startsWith(\"java.\"))\n                                            || (field.getType().getName().startsWith(\"javax.\")))) {\n                                        nullInstance(field.get(null));\n                                    }\n                                } else {\n                                    field.set(null, null);\n                                    if (log.isDebugEnabled()) {\n                                        log.debug(\"Set field \" + field.getName()\n                                                + \" to null in class \" + clazz.getName());\n                                    }\n                                }\n                            } catch (Throwable t) {\n                                ExceptionUtils.handleThrowable(t);\n                                if (log.isDebugEnabled()) {\n                                    log.debug(\"Could not set field \" + field.getName()\n                                            + \" to null in class \" + clazz.getName(), t);\n                                }\n                            }\n                        }\n                    }\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Could not clean fields for class \" + clazz.getName(), t);\n                    }\n                }\n            }\n        }\n\n    }",
        "    private void nullInstance(Object instance) {\n        if (instance == null) {\n            return;\n        }\n        Field[] fields = instance.getClass().getDeclaredFields();\n        for (int i = 0; i < fields.length; i++) {\n            Field field = fields[i];\n            int mods = field.getModifiers();\n            if (field.getType().isPrimitive()\n                    || (field.getName().indexOf(\"$\") != -1)) {\n                continue;\n            }\n            try {\n                field.setAccessible(true);\n                if (Modifier.isStatic(mods) && Modifier.isFinal(mods)) {\n                    // Doing something recursively is too risky\n                    continue;\n                }\n                Object value = field.get(instance);\n                if (null != value) {\n                    Class<? extends Object> valueClass = value.getClass();\n                    if (!loadedByThisOrChild(valueClass)) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Not setting field \" + field.getName() +\n                                    \" to null in object of class \" +\n                                    instance.getClass().getName() +\n                                    \" because the referenced object was of type \" +\n                                    valueClass.getName() +\n                                    \" which was not loaded by this WebappClassLoader.\");\n                        }\n                    } else {\n                        field.set(instance, null);\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Set field \" + field.getName()\n                                    + \" to null in class \" + instance.getClass().getName());\n                        }\n                    }\n                }\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Could not set field \" + field.getName()\n                            + \" to null in object instance of class \"\n                            + instance.getClass().getName(), t);\n                }\n            }\n        }\n    }",
        "    private void clearReferencesThreads() {\n        Thread[] threads = getThreads();\n        List<Thread> executorThreadsToStop = new ArrayList<Thread>();\n\n        // Iterate over the set of threads\n        for (Thread thread : threads) {\n            if (thread != null) {\n                ClassLoader ccl = thread.getContextClassLoader();\n                if (ccl == this) {\n                    // Don't warn about this thread\n                    if (thread == Thread.currentThread()) {\n                        continue;\n                    }\n\n                    // JVM controlled threads\n                    ThreadGroup tg = thread.getThreadGroup();\n                    if (tg != null &&\n                            JVM_THREAD_GROUP_NAMES.contains(tg.getName())) {\n\n                        // HttpClient keep-alive threads\n                        if (clearReferencesHttpClientKeepAliveThread &&\n                                thread.getName().equals(\"Keep-Alive-Timer\")) {\n                            thread.setContextClassLoader(parent);\n                            log.debug(sm.getString(\n                                    \"webappClassLoader.checkThreadsHttpClient\"));\n                        }\n\n                        // Don't warn about remaining JVM controlled threads\n                        continue;\n                    }\n\n                    // Skip threads that have already died\n                    if (!thread.isAlive()) {\n                        continue;\n                    }\n\n                    // TimerThread can be stopped safely so treat separately\n                    // \"java.util.TimerThread\" in Sun/Oracle JDK\n                    // \"java.util.Timer$TimerImpl\" in Apache Harmony and in IBM JDK\n                    if (thread.getClass().getName().startsWith(\"java.util.Timer\") &&\n                            clearReferencesStopTimerThreads) {\n                        clearReferencesStopTimerThread(thread);\n                        continue;\n                    }\n\n                    if (isRequestThread(thread)) {\n                        log.error(sm.getString(\"webappClassLoader.warnRequestThread\",\n                                contextName, thread.getName()));\n                    } else {\n                        log.error(sm.getString(\"webappClassLoader.warnThread\",\n                                contextName, thread.getName()));\n                    }\n\n                    // Don't try an stop the threads unless explicitly\n                    // configured to do so\n                    if (!clearReferencesStopThreads) {\n                        continue;\n                    }\n\n                    // If the thread has been started via an executor, try\n                    // shutting down the executor\n                    boolean usingExecutor = false;\n                    try {\n\n                        // Runnable wrapped by Thread\n                        // \"target\" in Sun/Oracle JDK\n                        // \"runnable\" in IBM JDK\n                        // \"action\" in Apache Harmony\n                        Object target = null;\n                        for (String fieldName : new String[] { \"target\",\n                                \"runnable\", \"action\" }) {\n                            try {\n                                Field targetField = thread.getClass()\n                                        .getDeclaredField(fieldName);\n                                targetField.setAccessible(true);\n                                target = targetField.get(thread);\n                                break;\n                            } catch (NoSuchFieldException nfe) {\n                                continue;\n                            }\n                        }\n\n                        // \"java.util.concurrent\" code is in public domain,\n                        // so all implementations are similar\n                        if (target != null &&\n                                target.getClass().getCanonicalName() != null\n                                && target.getClass().getCanonicalName().equals(\n                                \"java.util.concurrent.ThreadPoolExecutor.Worker\")) {\n                            Field executorField =\n                                target.getClass().getDeclaredField(\"this$0\");\n                            executorField.setAccessible(true);\n                            Object executor = executorField.get(target);\n                            if (executor instanceof ThreadPoolExecutor) {\n                                ((ThreadPoolExecutor) executor).shutdownNow();\n                                usingExecutor = true;\n                            }\n                        }\n                    } catch (SecurityException e) {\n                        log.warn(sm.getString(\n                                \"webappClassLoader.stopThreadFail\",\n                                thread.getName(), contextName), e);\n                    } catch (NoSuchFieldException e) {\n                        log.warn(sm.getString(\n                                \"webappClassLoader.stopThreadFail\",\n                                thread.getName(), contextName), e);\n                    } catch (IllegalArgumentException e) {\n                        log.warn(sm.getString(\n                                \"webappClassLoader.stopThreadFail\",\n                                thread.getName(), contextName), e);\n                    } catch (IllegalAccessException e) {\n                        log.warn(sm.getString(\n                                \"webappClassLoader.stopThreadFail\",\n                                thread.getName(), contextName), e);\n                    }\n\n                    if (usingExecutor) {\n                        // Executor may take a short time to stop all the\n                        // threads. Make a note of threads that should be\n                        // stopped and check them at the end of the method.\n                        executorThreadsToStop.add(thread);\n                    } else {\n                        // This method is deprecated and for good reason. This\n                        // is very risky code but is the only option at this\n                        // point. A *very* good reason for apps to do this\n                        // clean-up themselves.\n                        thread.stop();\n                    }\n                }\n            }\n        }\n\n        // If thread stopping is enabled, executor threads should have been\n        // stopped above when the executor was shut down but that depends on the\n        // thread correctly handling the interrupt. Give all the executor\n        // threads a few seconds shutdown and if they are still running\n        // Give threads up to 2 seconds to shutdown\n        int count = 0;\n        for (Thread t : executorThreadsToStop) {\n            while (t.isAlive() && count < 100) {\n                try {\n                    Thread.sleep(20);\n                } catch (InterruptedException e) {\n                    // Quit the while loop\n                    break;\n                }\n                count++;\n            }\n            if (t.isAlive()) {\n                // This method is deprecated and for good reason. This is\n                // very risky code but is the only option at this point.\n                // A *very* good reason for apps to do this clean-up\n                // themselves.\n                t.stop();\n            }\n        }\n    }",
        "    private boolean isRequestThread(Thread thread) {\n\n        StackTraceElement[] elements = thread.getStackTrace();\n\n        if (elements == null || elements.length == 0) {\n            // Must have stopped already. Too late to ignore it. Assume not a\n            // request processing thread.\n            return false;\n        }\n\n        // Step through the methods in reverse order looking for calls to any\n        // CoyoteAdapter method. All request threads will have this unless\n        // Tomcat has been heavily modified - in which case there isn't much we\n        // can do.\n        for (int i = 0; i < elements.length; i++) {\n            StackTraceElement element = elements[elements.length - (i+1)];\n            if (\"org.apache.catalina.connector.CoyoteAdapter\".equals(\n                    element.getClassName())) {\n                return true;\n            }\n        }\n        return false;\n    }",
        "    private void clearReferencesStopTimerThread(Thread thread) {\n\n        // Need to get references to:\n        // in Sun/Oracle JDK:\n        // - newTasksMayBeScheduled field (in java.util.TimerThread)\n        // - queue field\n        // - queue.clear()\n        // in IBM JDK, Apache Harmony:\n        // - cancel() method (in java.util.Timer$TimerImpl)\n\n        try {\n\n            try {\n                Field newTasksMayBeScheduledField =\n                    thread.getClass().getDeclaredField(\"newTasksMayBeScheduled\");\n                newTasksMayBeScheduledField.setAccessible(true);\n                Field queueField = thread.getClass().getDeclaredField(\"queue\");\n                queueField.setAccessible(true);\n\n                Object queue = queueField.get(thread);\n\n                Method clearMethod = queue.getClass().getDeclaredMethod(\"clear\");\n                clearMethod.setAccessible(true);\n\n                synchronized(queue) {\n                    newTasksMayBeScheduledField.setBoolean(thread, false);\n                    clearMethod.invoke(queue);\n                    queue.notify();  // In case queue was already empty.\n                }\n\n            }catch (NoSuchFieldException nfe){\n                Method cancelMethod = thread.getClass().getDeclaredMethod(\"cancel\");\n                synchronized(thread) {\n                    cancelMethod.setAccessible(true);\n                    cancelMethod.invoke(thread);\n                }\n            }\n\n            log.error(sm.getString(\"webappClassLoader.warnTimerThread\",\n                    contextName, thread.getName()));\n\n        } catch (Exception e) {\n            // So many things to go wrong above...\n            Throwable t = ExceptionUtils.unwrapInvocationTargetException(e);\n            ExceptionUtils.handleThrowable(t);\n            log.warn(sm.getString(\n                    \"webappClassLoader.stopTimerThreadFail\",\n                    thread.getName(), contextName), t);\n        }\n    }",
        "    private void checkThreadLocalsForLeaks() {\n        Thread[] threads = getThreads();\n\n        try {\n            // Make the fields in the Thread class that store ThreadLocals\n            // accessible\n            Field threadLocalsField =\n                Thread.class.getDeclaredField(\"threadLocals\");\n            threadLocalsField.setAccessible(true);\n            Field inheritableThreadLocalsField =\n                Thread.class.getDeclaredField(\"inheritableThreadLocals\");\n            inheritableThreadLocalsField.setAccessible(true);\n            // Make the underlying array of ThreadLoad.ThreadLocalMap.Entry objects\n            // accessible\n            Class<?> tlmClass = Class.forName(\"java.lang.ThreadLocal$ThreadLocalMap\");\n            Field tableField = tlmClass.getDeclaredField(\"table\");\n            tableField.setAccessible(true);\n            Method expungeStaleEntriesMethod = tlmClass.getDeclaredMethod(\"expungeStaleEntries\");\n            expungeStaleEntriesMethod.setAccessible(true);\n\n            for (int i = 0; i < threads.length; i++) {\n                Object threadLocalMap;\n                if (threads[i] != null) {\n\n                    // Clear the first map\n                    threadLocalMap = threadLocalsField.get(threads[i]);\n                    if (null != threadLocalMap){\n                        expungeStaleEntriesMethod.invoke(threadLocalMap);\n                        checkThreadLocalMapForLeaks(threadLocalMap, tableField);\n                    }\n\n                    // Clear the second map\n                    threadLocalMap =inheritableThreadLocalsField.get(threads[i]);\n                    if (null != threadLocalMap){\n                        expungeStaleEntriesMethod.invoke(threadLocalMap);\n                        checkThreadLocalMapForLeaks(threadLocalMap, tableField);\n                    }\n                }\n            }\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log.warn(sm.getString(\n                    \"webappClassLoader.checkThreadLocalsForLeaksFail\",\n                    getContextName()), t);\n        }\n    }",
        "    private boolean loadedByThisOrChild(Object o) {\n        if (o == null) {\n            return false;\n        }\n\n        Class<?> clazz;\n        if (o instanceof Class) {\n            clazz = (Class<?>) o;\n        } else {\n            clazz = o.getClass();\n        }\n\n        ClassLoader cl = clazz.getClassLoader();\n        while (cl != null) {\n            if (cl == this) {\n                return true;\n            }\n            cl = cl.getParent();\n        }\n\n        if (o instanceof Collection<?>) {\n            Iterator<?> iter = ((Collection<?>) o).iterator();\n            try {\n                while (iter.hasNext()) {\n                    Object entry = iter.next();\n                    if (loadedByThisOrChild(entry)) {\n                        return true;\n                    }\n                }\n            } catch (ConcurrentModificationException e) {\n                log.warn(sm.getString(\n                        \"webappClassLoader\", clazz.getName(), getContextName()),\n                        e);\n            }\n        }\n        return false;\n    }",
        "    private void clearReferencesRmiTargets() {\n        try {\n            // Need access to the ccl field of sun.rmi.transport.Target\n            Class<?> objectTargetClass =\n                Class.forName(\"sun.rmi.transport.Target\");\n            Field cclField = objectTargetClass.getDeclaredField(\"ccl\");\n            cclField.setAccessible(true);\n\n            // Clear the objTable map\n            Class<?> objectTableClass =\n                Class.forName(\"sun.rmi.transport.ObjectTable\");\n            Field objTableField = objectTableClass.getDeclaredField(\"objTable\");\n            objTableField.setAccessible(true);\n            Object objTable = objTableField.get(null);\n            if (objTable == null) {\n                return;\n            }\n\n            // Iterate over the values in the table\n            if (objTable instanceof Map<?,?>) {\n                Iterator<?> iter = ((Map<?,?>) objTable).values().iterator();\n                while (iter.hasNext()) {\n                    Object obj = iter.next();\n                    Object cclObject = cclField.get(obj);\n                    if (this == cclObject) {\n                        iter.remove();\n                    }\n                }\n            }\n\n            // Clear the implTable map\n            Field implTableField = objectTableClass.getDeclaredField(\"implTable\");\n            implTableField.setAccessible(true);\n            Object implTable = implTableField.get(null);\n            if (implTable == null) {\n                return;\n            }\n\n            // Iterate over the values in the table\n            if (implTable instanceof Map<?,?>) {\n                Iterator<?> iter = ((Map<?,?>) implTable).values().iterator();\n                while (iter.hasNext()) {\n                    Object obj = iter.next();\n                    Object cclObject = cclField.get(obj);\n                    if (this == cclObject) {\n                        iter.remove();\n                    }\n                }\n            }\n        } catch (ClassNotFoundException e) {\n            log.info(sm.getString(\"webappClassLoader.clearRmiInfo\",\n                    contextName), e);\n        } catch (SecurityException e) {\n            log.warn(sm.getString(\"webappClassLoader.clearRmiFail\",\n                    contextName), e);\n        } catch (NoSuchFieldException e) {\n            log.warn(sm.getString(\"webappClassLoader.clearRmiFail\",\n                    contextName), e);\n        } catch (IllegalArgumentException e) {\n            log.warn(sm.getString(\"webappClassLoader.clearRmiFail\",\n                    contextName), e);\n        } catch (IllegalAccessException e) {\n            log.warn(sm.getString(\"webappClassLoader.clearRmiFail\",\n                    contextName), e);\n        }\n    }",
        "    private void clearReferencesResourceBundles() {\n        // Get a reference to the cache\n        try {\n            Field cacheListField =\n                ResourceBundle.class.getDeclaredField(\"cacheList\");\n            cacheListField.setAccessible(true);\n\n            // Java 6 uses ConcurrentMap\n            // Java 5 uses SoftCache extends Abstract Map\n            // So use Map and it *should* work with both\n            Map<?,?> cacheList = (Map<?,?>) cacheListField.get(null);\n\n            // Get the keys (loader references are in the key)\n            Set<?> keys = cacheList.keySet();\n\n            Field loaderRefField = null;\n\n            // Iterate over the keys looking at the loader instances\n            Iterator<?> keysIter = keys.iterator();\n\n            int countRemoved = 0;\n\n            while (keysIter.hasNext()) {\n                Object key = keysIter.next();\n\n                if (loaderRefField == null) {\n                    loaderRefField =\n                        key.getClass().getDeclaredField(\"loaderRef\");\n                    loaderRefField.setAccessible(true);\n                }\n                WeakReference<?> loaderRef =\n                    (WeakReference<?>) loaderRefField.get(key);\n\n                ClassLoader loader = (ClassLoader) loaderRef.get();\n\n                while (loader != null && loader != this) {\n                    loader = loader.getParent();\n                }\n\n                if (loader != null) {\n                    keysIter.remove();\n                    countRemoved++;\n                }\n            }\n\n            if (countRemoved > 0 && log.isDebugEnabled()) {\n                log.debug(sm.getString(\n                        \"webappClassLoader.clearReferencesResourceBundlesCount\",\n                        Integer.valueOf(countRemoved), contextName));\n            }\n        } catch (SecurityException e) {\n            log.error(sm.getString(\n                    \"webappClassLoader.clearReferencesResourceBundlesFail\",\n                    contextName), e);\n        } catch (NoSuchFieldException e) {\n            if (Globals.IS_ORACLE_JVM) {\n                log.error(sm.getString(\n                        \"webappClassLoader.clearReferencesResourceBundlesFail\",\n                        getContextName()), e);\n            } else {\n                log.debug(sm.getString(\n                        \"webappClassLoader.clearReferencesResourceBundlesFail\",\n                        getContextName()), e);\n            }\n        } catch (IllegalArgumentException e) {\n            log.error(sm.getString(\n                    \"webappClassLoader.clearReferencesResourceBundlesFail\",\n                    contextName), e);\n        } catch (IllegalAccessException e) {\n            log.error(sm.getString(\n                    \"webappClassLoader.clearReferencesResourceBundlesFail\",\n                    contextName), e);\n        }\n    }",
        "    protected ResourceEntry findResourceInternal(String name, String path) {\n\n        if (!started) {\n            log.info(sm.getString(\"webappClassLoader.stopped\", name));\n            return null;\n        }\n\n        if ((name == null) || (path == null))\n            return null;\n\n        ResourceEntry entry = resourceEntries.get(name);\n        if (entry != null)\n            return entry;\n\n        int contentLength = -1;\n        InputStream binaryStream = null;\n        boolean isClassResource = path.endsWith(\".class\");\n\n        int jarFilesLength = jarFiles.length;\n        int repositoriesLength = repositories.length;\n\n        int i;\n\n        Resource resource = null;\n\n        boolean fileNeedConvert = false;\n\n        for (i = 0; (entry == null) && (i < repositoriesLength); i++) {\n            try {\n\n                String fullPath = repositories[i] + path;\n\n                Object lookupResult = resources.lookup(fullPath);\n                if (lookupResult instanceof Resource) {\n                    resource = (Resource) lookupResult;\n                }\n\n                // Note : Not getting an exception here means the resource was\n                // found\n\n                ResourceAttributes attributes =\n                    (ResourceAttributes) resources.getAttributes(fullPath);\n                contentLength = (int) attributes.getContentLength();\n                String canonicalPath = attributes.getCanonicalPath();\n                if (canonicalPath != null) {\n                    // we create the ResourceEntry based on the information returned\n                    // by the DirContext rather than just using the path to the\n                    // repository. This allows to have smart DirContext implementations\n                    // that \"virtualize\" the docbase (e.g. Eclipse WTP)\n                    entry = findResourceInternal(new File(canonicalPath), \"\");\n                } else {\n                    // probably a resource not in the filesystem (e.g. in a\n                    // packaged war)\n                    entry = findResourceInternal(files[i], path);\n                }\n                entry.lastModified = attributes.getLastModified();\n\n                if (resource != null) {\n\n\n                    try {\n                        binaryStream = resource.streamContent();\n                    } catch (IOException e) {\n                        return null;\n                    }\n\n                    if (needConvert) {\n                        if (path.endsWith(\".properties\")) {\n                            fileNeedConvert = true;\n                        }\n                    }\n\n                    // Register the full path for modification checking\n                    // Note: Only syncing on a 'constant' object is needed\n                    synchronized (allPermission) {\n\n                        int j;\n\n                        long[] result2 =\n                            new long[lastModifiedDates.length + 1];\n                        for (j = 0; j < lastModifiedDates.length; j++) {\n                            result2[j] = lastModifiedDates[j];\n                        }\n                        result2[lastModifiedDates.length] = entry.lastModified;\n                        lastModifiedDates = result2;\n\n                        String[] result = new String[paths.length + 1];\n                        for (j = 0; j < paths.length; j++) {\n                            result[j] = paths[j];\n                        }\n                        result[paths.length] = fullPath;\n                        paths = result;\n\n                    }\n\n                }\n\n            } catch (NamingException e) {\n                // Ignore\n            }\n        }\n\n        if ((entry == null) && (notFoundResources.containsKey(name)))\n            return null;\n\n        JarEntry jarEntry = null;\n\n        synchronized (jarFiles) {\n\n            try {\n                if (!openJARs()) {\n                    return null;\n                }\n                for (i = 0; (entry == null) && (i < jarFilesLength); i++) {\n\n                    jarEntry = jarFiles[i].getJarEntry(path);\n\n                    if (jarEntry != null) {\n\n                        entry = new ResourceEntry();\n                        try {\n                            entry.codeBase = getURI(jarRealFiles[i]);\n                            String jarFakeUrl = entry.codeBase.toString();\n                            jarFakeUrl = \"jar:\" + jarFakeUrl + \"!/\" + path;\n                            entry.source = new URL(jarFakeUrl);\n                            entry.lastModified = jarRealFiles[i].lastModified();\n                        } catch (MalformedURLException e) {\n                            return null;\n                        }\n                        contentLength = (int) jarEntry.getSize();\n                        try {\n                            entry.manifest = jarFiles[i].getManifest();\n                            binaryStream = jarFiles[i].getInputStream(jarEntry);\n                        } catch (IOException e) {\n                            return null;\n                        }\n\n                        // Extract resources contained in JAR to the workdir\n                        if (antiJARLocking && !(path.endsWith(\".class\"))) {\n                            byte[] buf = new byte[1024];\n                            File resourceFile = new File\n                                (loaderDir, jarEntry.getName());\n                            if (!resourceFile.exists()) {\n                                Enumeration<JarEntry> entries =\n                                    jarFiles[i].entries();\n                                while (entries.hasMoreElements()) {\n                                    JarEntry jarEntry2 =  entries.nextElement();\n                                    if (!(jarEntry2.isDirectory())\n                                        && (!jarEntry2.getName().endsWith\n                                            (\".class\"))) {\n                                        resourceFile = new File\n                                            (loaderDir, jarEntry2.getName());\n                                        try {\n                                            if (!resourceFile.getCanonicalPath().startsWith(\n                                                    canonicalLoaderDir)) {\n                                                throw new IllegalArgumentException(\n                                                        sm.getString(\"webappClassLoader.illegalJarPath\",\n                                                    jarEntry2.getName()));\n                                            }\n                                        } catch (IOException ioe) {\n                                            throw new IllegalArgumentException(\n                                                    sm.getString(\"webappClassLoader.validationErrorJarPath\",\n                                                            jarEntry2.getName()), ioe);\n                                        }\n                                        File parentFile = resourceFile.getParentFile();\n                                        if (!parentFile.mkdirs() && !parentFile.exists()) {\n                                            // Ignore the error (like the IOExceptions below)\n                                        }\n                                        FileOutputStream os = null;\n                                        InputStream is = null;\n                                        try {\n                                            is = jarFiles[i].getInputStream\n                                                (jarEntry2);\n                                            os = new FileOutputStream\n                                                (resourceFile);\n                                            while (true) {\n                                                int n = is.read(buf);\n                                                if (n <= 0) {\n                                                    break;\n                                                }\n                                                os.write(buf, 0, n);\n                                            }\n                                            resourceFile.setLastModified(\n                                                    jarEntry2.getTime());\n                                        } catch (IOException e) {\n                                            // Ignore\n                                        } finally {\n                                            try {\n                                                if (is != null) {\n                                                    is.close();\n                                                }\n                                            } catch (IOException e) {\n                                                // Ignore\n                                            }\n                                            try {\n                                                if (os != null) {\n                                                    os.close();\n                                                }\n                                            } catch (IOException e) {\n                                                // Ignore\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                    }\n\n                }\n\n                if (entry == null) {\n                    synchronized (notFoundResources) {\n                        notFoundResources.put(name, name);\n                    }\n                    return null;\n                }\n\n                /* Only cache the binary content if there is some content\n                 * available and either:\n                 * a) It is a class file since the binary content is only cached\n                 *    until the class has been loaded\n                 *    or\n                 * b) The file needs conversion to address encoding issues (see\n                 *    below)\n                 *\n                 * In all other cases do not cache the content to prevent\n                 * excessive memory usage if large resources are present (see\n                 * https://issues.apache.org/bugzilla/show_bug.cgi?id=53081).\n                 */\n                if (binaryStream != null &&\n                        (isClassResource || fileNeedConvert)) {\n\n                    byte[] binaryContent = new byte[contentLength];\n\n                    int pos = 0;\n                    try {\n\n                        while (true) {\n                            int n = binaryStream.read(binaryContent, pos,\n                                                      binaryContent.length - pos);\n                            if (n <= 0)\n                                break;\n                            pos += n;\n                        }\n                    } catch (IOException e) {\n                        log.error(sm.getString(\"webappClassLoader.readError\", name), e);\n                        return null;\n                    }\n                    if (fileNeedConvert) {\n                        // Workaround for certain files on platforms that use\n                        // EBCDIC encoding, when they are read through FileInputStream.\n                        // See commit message of rev.303915 for details\n                        // http://svn.apache.org/viewvc?view=revision&revision=303915\n                        String str = new String(binaryContent,0,pos);\n                        try {\n                            binaryContent = str.getBytes(CHARSET_UTF8);\n                        } catch (Exception e) {\n                            return null;\n                        }\n                    }\n                    entry.binaryContent = binaryContent;\n\n                    // The certificates are only available after the JarEntry\n                    // associated input stream has been fully read\n                    if (jarEntry != null) {\n                        entry.certificates = jarEntry.getCertificates();\n                    }\n\n                }\n            } finally {\n                if (binaryStream != null) {\n                    try {\n                        binaryStream.close();\n                    } catch (IOException e) { /* Ignore */}\n                }\n            }\n        }\n\n        // Add the entry in the local resource repository\n        synchronized (resourceEntries) {\n            // Ensures that all the threads which may be in a race to load\n            // a particular class all end up with the same ResourceEntry\n            // instance\n            ResourceEntry entry2 = resourceEntries.get(name);\n            if (entry2 == null) {\n                resourceEntries.put(name, entry);\n            } else {\n                entry = entry2;\n            }\n        }\n\n        return entry;\n\n    }",
        "    protected boolean filter(String name) {\n\n        if (name == null)\n            return false;\n\n        // Looking up the package\n        String packageName = null;\n        int pos = name.lastIndexOf('.');\n        if (pos != -1)\n            packageName = name.substring(0, pos);\n        else\n            return false;\n\n        for (int i = 0; i < packageTriggers.length; i++) {\n            if (packageName.startsWith(packageTriggers[i]))\n                return true;\n        }\n\n        return false;\n\n    }",
        "    protected boolean validate(String name) {\n\n        // Need to be careful with order here\n        if (name == null) {\n            // Can't load a class without a name\n            return false;\n        }\n        if (name.startsWith(\"java.\")) {\n            // Must never load java.* classes\n            return false;\n        }\n        if (name.startsWith(\"javax.servlet.jsp.jstl\")) {\n            // OK for web apps to package JSTL\n            return true;\n        }\n        if (name.startsWith(\"javax.servlet.\")) {\n            // Web apps should never package any other Servlet or JSP classes\n            return false;\n        }\n        if (name.startsWith(\"javax.el\")) {\n            // Must never load javax.el.* classes\n            return false;\n        }\n\n        // Assume everything else is OK\n        return true;\n\n    }",
        "    public void put(Selector s) throws IOException {\n        if ( SHARED ) return;\n        if ( enabled ) active.decrementAndGet();\n        if ( enabled && (maxSpareSelectors==-1 || spare.get() < Math.min(maxSpareSelectors,maxSelectors)) ) {\n            spare.incrementAndGet();\n            selectors.offer(s);\n        }\n        else s.close();\n    }\n\n    public void close() throws IOException {\n        enabled = false;\n        Selector s;\n        while ( (s = selectors.poll()) != null ) s.close();\n        spare.set(0);\n        active.set(0);\n        if (blockingSelector!=null) {\n            blockingSelector.close();\n        }\n        if ( SHARED && getSharedSelector()!=null ) {\n            getSharedSelector().close();\n            SHARED_SELECTOR = null;\n        }\n    }\n\n    public void open() throws IOException {\n        enabled = true;\n        getSharedSelector();\n        if (SHARED) {\n            blockingSelector = new NioBlockingSelector();\n            blockingSelector.open(getSharedSelector());\n        }\n\n    }",
        "    public void init(FilterConfig filterConfig) throws ServletException {\n        // Set the parameters\n        super.init(filterConfig);\n\n        try {\n            Class<?> clazz = Class.forName(randomClass);\n            randomSource = (Random) clazz.newInstance();\n        } catch (ClassNotFoundException e) {\n            ServletException se = new ServletException(sm.getString(\n                    \"csrfPrevention.invalidRandomClass\", randomClass), e);\n            throw se;\n        } catch (InstantiationException e) {\n            ServletException se = new ServletException(sm.getString(\n                    \"csrfPrevention.invalidRandomClass\", randomClass), e);\n            throw se;\n        } catch (IllegalAccessException e) {\n            ServletException se = new ServletException(sm.getString(\n                    \"csrfPrevention.invalidRandomClass\", randomClass), e);\n            throw se;\n        }\n    }"
    ],
    "56025": [
        "    public void addEndpoint(Class<?> pojo) throws DeploymentException {\n\n        ServerEndpoint annotation = pojo.getAnnotation(ServerEndpoint.class);\n        if (annotation == null) {\n            throw new DeploymentException(\n                    sm.getString(\"serverContainer.missingAnnotation\",\n                            pojo.getName()));\n        }\n        String path = annotation.value();\n\n        // Validate encoders\n        validateEncoders(annotation.encoders());\n\n        // Method mapping\n        PojoMethodMapping methodMapping = new PojoMethodMapping(pojo,\n                annotation.decoders(), path);\n\n        // ServerEndpointConfig\n        ServerEndpointConfig sec;\n        Class<? extends Configurator> configuratorClazz =\n                annotation.configurator();\n        Configurator configurator = null;\n        if (!configuratorClazz.equals(Configurator.class)) {\n            try {\n                configurator = annotation.configurator().newInstance();\n            } catch (InstantiationException e) {\n                throw new DeploymentException(sm.getString(\n                        \"serverContainer.configuratorFail\",\n                        annotation.configurator().getName(),\n                        pojo.getClass().getName()), e);\n            } catch (IllegalAccessException e) {\n                throw new DeploymentException(sm.getString(\n                        \"serverContainer.configuratorFail\",\n                        annotation.configurator().getName(),\n                        pojo.getClass().getName()), e);\n            }\n        }\n        sec = ServerEndpointConfig.Builder.create(pojo, path).\n                decoders(Arrays.asList(annotation.decoders())).\n                encoders(Arrays.asList(annotation.encoders())).\n                subprotocols(Arrays.asList(annotation.subprotocols())).\n                configurator(configurator).\n                build();\n        sec.getUserProperties().put(\n                PojoEndpointServer.POJO_METHOD_MAPPING_KEY,\n                methodMapping);\n\n        addEndpoint(sec);\n    }",
        "    protected void registerSession(Endpoint endpoint, WsSession wsSession) {\n        super.registerSession(endpoint, wsSession);\n        if (wsSession.isOpen() &&\n                wsSession.getUserPrincipal() != null &&\n                wsSession.getHttpSessionId() != null) {\n            registerAuthenticatedSession(wsSession,\n                    wsSession.getHttpSessionId());\n        }\n    }\n\n    protected void unregisterSession(Endpoint endpoint, WsSession wsSession) {\n        if (wsSession.getUserPrincipal() != null &&\n                wsSession.getHttpSessionId() != null) {\n            unregisterAuthenticatedSession(wsSession,\n                    wsSession.getHttpSessionId());\n        }\n        super.unregisterSession(endpoint, wsSession);\n    }\n\n    public void closeAuthenticatedSession(String httpSessionId) {\n        Set<WsSession> wsSessions = authenticatedSessions.remove(httpSessionId);\n\n        if (wsSessions != null && !wsSessions.isEmpty()) {\n            for (WsSession wsSession : wsSessions) {\n                try {\n                    wsSession.close(AUTHENTICATED_HTTP_SESSION_CLOSED);\n                } catch (IOException e) {\n                    // Any IOExceptions during close will have been caught and the\n                    // onError method called.\n                }\n            }\n        }\n    }",
        "    public void init() throws Exception {\n        // SSL implementation needs to be in place before end point is\n        // initialized\n        sslImplementation = SSLImplementation.getInstance(sslImplementationName);\n        super.init();\n    }",
        "    private void clearHandler(Throwable t, boolean useDispatch) {\n        // Setting the result marks this (partial) message as\n        // complete which means the next one may be sent which\n        // could update the value of the handler. Therefore, keep a\n        // local copy before signalling the end of the (partial)\n        // message.\n        SendHandler sh = handler;\n        handler = null;\n        if (sh != null) {\n            if (useDispatch) {\n                OnResultRunnable r = onResultRunnables.poll();\n                if (r == null) {\n                    r = new OnResultRunnable(onResultRunnables);\n                }\n                r.init(sh, t);\n                if (executorService == null || executorService.isShutdown()) {\n                    // Can't use the executor so call the runnable directly.\n                    // This may not be strictly specification compliant in all\n                    // cases but during shutdown only close messages are going\n                    // to be sent so there should not be the issue of nested\n                    // calls leading to stack overflow as described in bug\n                    // 55715. The issues with nested calls was the reason for\n                    // the separate thread requirement in the specification.\n                    r.run();\n                } else {\n                    executorService.execute(r);\n                }\n            } else {\n                if (t == null) {\n                    sh.onResult(new SendResult());\n                } else {\n                    sh.onResult(new SendResult(t));\n                }\n            }\n        }\n    }",
        "    public void onOpen(Session session, EndpointConfig endpointConfig) {\n\n        ServerEndpointConfig sec = (ServerEndpointConfig) endpointConfig;\n\n        Object pojo;\n        try {\n            pojo = sec.getConfigurator().getEndpointInstance(\n                    sec.getEndpointClass());\n        } catch (InstantiationException e) {\n            throw new IllegalArgumentException(sm.getString(\n                    \"pojoEndpointServer.getPojoInstanceFail\",\n                    sec.getEndpointClass().getName()), e);\n        }\n        setPojo(pojo);\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String,String> pathParameters =\n                (Map<String, String>) sec.getUserProperties().get(\n                        POJO_PATH_PARAM_KEY);\n        setPathParameters(pathParameters);\n\n        PojoMethodMapping methodMapping =\n                (PojoMethodMapping) sec.getUserProperties().get(\n                        POJO_METHOD_MAPPING_KEY);\n        setMethodMapping(methodMapping);\n\n        doOnOpen(session, endpointConfig);\n    }",
        "    protected final void doOnOpen(Session session, EndpointConfig config) {\n        PojoMethodMapping methodMapping = getMethodMapping();\n        Object pojo = getPojo();\n        Map<String,String> pathParameters = getPathParameters();\n\n        if (methodMapping.getOnOpen() != null) {\n            try {\n                methodMapping.getOnOpen().invoke(pojo,\n                        methodMapping.getOnOpenArgs(\n                                pathParameters, session, config));\n\n            } catch (IllegalAccessException e) {\n                // Reflection related problems\n                log.error(sm.getString(\n                        \"pojoEndpointBase.onOpenFail\",\n                        pojo.getClass().getName()), e);\n                handleOnOpenError(session, e);\n                return;\n            } catch (InvocationTargetException e) {\n                Throwable cause = e.getCause();\n                handleOnOpenError(session, cause);\n                return;\n            } catch (Throwable t) {\n                handleOnOpenError(session, t);\n                return;\n            }\n        }\n\n        for (MessageHandler mh : methodMapping.getMessageHandlers(pojo,\n                pathParameters, session, config)) {\n            session.addMessageHandler(mh);\n        }\n    }",
        "    private void handleOnOpenError(Session session, Throwable t) {\n        // If really fatal - re-throw\n        ExceptionUtils.handleThrowable(t);\n\n        // Trigger the error handler and close the session\n        onError(session, t);\n        try {\n            session.close();\n        } catch (IOException ioe) {\n            log.warn(sm.getString(\"pojoEndpointBase.closeSessionFail\"), ioe);\n        }\n    }\n\n    public final void onClose(Session session, CloseReason closeReason) {\n\n        if (methodMapping.getOnClose() != null) {\n            try {\n                methodMapping.getOnClose().invoke(pojo,\n                        methodMapping.getOnCloseArgs(pathParameters, session, closeReason));\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.error(sm.getString(\"pojoEndpointBase.onCloseFail\",\n                        pojo.getClass().getName()), t);\n            }\n        }\n\n        // Trigger the destroy method for any associated decoders\n        Set<MessageHandler> messageHandlers = session.getMessageHandlers();\n        for (MessageHandler messageHandler : messageHandlers) {\n            if (messageHandler instanceof PojoMessageHandlerWholeBase<?>) {\n                ((PojoMessageHandlerWholeBase<?>) messageHandler).onClose();\n            }\n        }\n    }",
        "    public final void onError(Session session, Throwable throwable) {\n\n        if (methodMapping.getOnError() == null) {\n            log.error(sm.getString(\"pojoEndpointBase.onError\",\n                    pojo.getClass().getName()), throwable);\n        } else {\n            try {\n                methodMapping.getOnError().invoke(\n                        pojo,\n                        methodMapping.getOnErrorArgs(pathParameters, session,\n                                throwable));\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.error(sm.getString(\"pojoEndpointBase.onErrorFail\",\n                        pojo.getClass().getName()), t);\n            }\n        }\n    }",
        "    public void init(WebConnection connection) {\n        if (ep == null) {\n            throw new IllegalStateException(\n                    sm.getString(\"wsHttpUpgradeHandler.noPreInit\"));\n        }\n\n        this.connection = connection;\n\n        AbstractServletInputStream sis;\n        AbstractServletOutputStream sos;\n        try {\n            sis = connection.getInputStream();\n            sos = connection.getOutputStream();\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n\n        String httpSessionId = null;\n        Object session = handshakeRequest.getHttpSession();\n        if (session != null ) {\n            httpSessionId = ((HttpSession) session).getId();\n        }\n\n        // Need to call onOpen using the web application's class loader\n        // Create the frame using the application's class loader so it can pick\n        // up application specific config from the ServerContainerImpl\n        Thread t = Thread.currentThread();\n        ClassLoader cl = t.getContextClassLoader();\n        t.setContextClassLoader(applicationClassLoader);\n        try {\n            WsRemoteEndpointImplServer wsRemoteEndpointServer =\n                    new WsRemoteEndpointImplServer(sos, webSocketContainer);\n            wsSession = new WsSession(ep, wsRemoteEndpointServer,\n                    webSocketContainer, handshakeRequest.getRequestURI(),\n                    handshakeRequest.getParameterMap(),\n                    handshakeRequest.getQueryString(),\n                    handshakeRequest.getUserPrincipal(), httpSessionId,\n                    subProtocol, pathParameters, secure, endpointConfig);\n            WsFrameServer wsFrame = new WsFrameServer(\n                    sis,\n                    wsSession);\n            sos.setWriteListener(\n                    new WsWriteListener(this, wsRemoteEndpointServer));\n            ep.onOpen(wsSession, endpointConfig);\n            webSocketContainer.registerSession(ep, wsSession);\n            sis.setReadListener(new WsReadListener(this, wsFrame));\n        } catch (DeploymentException e) {\n            throw new IllegalArgumentException(e);\n        } finally {\n            t.setContextClassLoader(cl);\n        }\n    }"
    ],
    "56010": [
        "    public void lifecycleEvent(LifecycleEvent event) {\n\n        if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {\n            try {\n                // Set JSP factory\n                Class.forName(\"org.apache.jasper.compiler.JspRuntimeContext\",\n                              true,\n                              this.getClass().getClassLoader());\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                // Should not occur, obviously\n                log.warn(\"Couldn't initialize Jasper\", t);\n            }\n            // Another possibility is to do directly:\n            // JspFactory.setDefaultFactory(new JspFactoryImpl());\n        }\n\n    }",
        "    public void resetBuffer() {\n        try {\n            jspWriter.clearBuffer();\n        } catch (IOException ioe) {\n        }\n    }",
        "    public void release() {\n        out = baseOut;\n        try {\n            if (isIncluded) {\n                ((JspWriterImpl) out).flushBuffer();\n                // push it into the including jspWriter\n            } else {\n                // Old code:\n                // out.flush();\n                // Do not flush the buffer even if we're not included (i.e.\n                // we are the main page. The servlet will flush it and close\n                // the stream.\n                ((JspWriterImpl) out).flushBuffer();\n            }\n        } catch (IOException ex) {\n            IllegalStateException ise = new IllegalStateException(Localizer.getMessage(\"jsp.error.flush\"), ex);\n            throw ise;\n        } finally {\n            servlet = null;\n            config = null;\n            context = null;\n            applicationContext = null;\n            elContext = null;\n            errorPageURL = null;\n            request = null;\n            response = null;\n            depth = -1;\n            baseOut.recycle();\n            session = null;\n            attributes.clear();\n            for (BodyContentImpl body: outs) {\n                body.recycle();\n            }\n        }\n    }",
        "    public void flush() throws IOException {\n        throw new IOException(\"Illegal to flush within a custom tag\");\n    }\n\n    public void clearBody() {\n        try {\n            this.clear();\n        } catch (IOException ex) {\n            // TODO -- clean this one up.\n            throw new Error(\"internal error!;\");\n        }\n    }",
        "    public void testDoForward() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        File appDir = new File(\"test/webapp-3.0\");\n        tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());\n\n        tomcat.start();\n\n        ByteChunk res = new ByteChunk();\n\n        int rc = getUrl(\"http://localhost:\" + getPort() +\n                \"/test/bug5nnnn/bug53545.jsp\", res, null);\n\n        Assert.assertEquals(HttpServletResponse.SC_OK, rc);\n\n        String body = res.toString();\n        Assert.assertTrue(body.contains(\"OK\"));\n        Assert.assertFalse(body.contains(\"FAIL\"));\n    }\n\n    public void testDefaultBufferSize() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        File appDir = new File(\"test/webapp-3.0\");\n        // app dir is relative to server home\n        Context ctx = tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());\n\n        // Add the Servlet\n        Tomcat.addServlet(ctx, \"bug56010\", new Bug56010());\n        ctx.addServletMapping(\"/bug56010\", \"bug56010\");\n\n        tomcat.start();\n\n        ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/test/bug56010\");\n\n        String result = res.toString();\n        Assert.assertTrue(result.contains(\"OK\"));\n    }"
    ],
    "55996": [
        "    public synchronized void asyncStart(AsyncContextCallback asyncCtxt) {\n        if (state == AsyncState.DISPATCHED) {\n            state = AsyncState.STARTING;\n            this.asyncCtxt = asyncCtxt;\n        } else {\n            throw new IllegalStateException(\n                    sm.getString(\"asyncStateMachine.invalidAsyncState\",\n                            \"asyncStart()\", state));\n        }\n    }\n\n    public synchronized SocketState asyncPostProcess() {\n        \n        if (state == AsyncState.STARTING) {\n            state = AsyncState.STARTED;\n            return SocketState.LONG;\n        } else if (state == AsyncState.MUST_COMPLETE) {\n            asyncCtxt.fireOnComplete();\n            state = AsyncState.DISPATCHED;\n            return SocketState.ASYNC_END;\n        } else if (state == AsyncState.COMPLETING) {\n            asyncCtxt.fireOnComplete();\n            state = AsyncState.DISPATCHED;\n            return SocketState.ASYNC_END;\n        } else if (state == AsyncState.MUST_DISPATCH) {\n            state = AsyncState.DISPATCHING;\n            return SocketState.ASYNC_END;\n        } else if (state == AsyncState.DISPATCHING) {\n            state = AsyncState.DISPATCHED;\n            return SocketState.ASYNC_END;\n        } else if (state == AsyncState.STARTED) {\n            // This can occur if an async listener does a dispatch to an async\n            // servlet during onTimeout\n            return SocketState.LONG;\n        } else {\n            throw new IllegalStateException(\n                    sm.getString(\"asyncStateMachine.invalidAsyncState\",\n                            \"asyncPostProcess()\", state));\n        }\n    }",
        "    public synchronized boolean asyncComplete() {\n        boolean doComplete = false;\n        \n        if (state == AsyncState.STARTING) {\n            state = AsyncState.MUST_COMPLETE;\n        } else if (state == AsyncState.STARTED) {\n            state = AsyncState.COMPLETING;\n            doComplete = true;\n        } else if (state == AsyncState.TIMING_OUT ||\n                state == AsyncState.ERROR) {\n            state = AsyncState.MUST_COMPLETE;\n        } else {\n            throw new IllegalStateException(\n                    sm.getString(\"asyncStateMachine.invalidAsyncState\",\n                            \"asyncComplete()\", state));\n            \n        }\n        return doComplete;\n    }\n\n    public synchronized boolean asyncTimeout() {\n        if (state == AsyncState.STARTED) {\n            state = AsyncState.TIMING_OUT;\n            return true;\n        } else if (state == AsyncState.COMPLETING ||\n                state == AsyncState.DISPATCHED) {\n            // NOOP - App called complete between the the timeout firing and\n            // execution reaching this point\n            return false;\n        } else {\n            throw new IllegalStateException(\n                    sm.getString(\"asyncStateMachine.invalidAsyncState\",\n                            \"asyncTimeout()\", state));\n        }\n    }",
        "    public synchronized boolean asyncDispatch() {\n        boolean doDispatch = false;\n        if (state == AsyncState.STARTING) {\n            state = AsyncState.MUST_DISPATCH;\n        } else if (state == AsyncState.STARTED ||\n                state == AsyncState.TIMING_OUT ||\n                state == AsyncState.ERROR) {\n            state = AsyncState.DISPATCHING;\n            doDispatch = true;\n        } else {\n            throw new IllegalStateException(\n                    sm.getString(\"asyncStateMachine.invalidAsyncState\",\n                            \"asyncDispatch()\", state));\n        }\n        return doDispatch;\n    }\n\n    public synchronized void asyncDispatched() {\n        if (state == AsyncState.DISPATCHING) {\n            state = AsyncState.DISPATCHED;\n        } else {\n            throw new IllegalStateException(\n                    sm.getString(\"asyncStateMachine.invalidAsyncState\",\n                            \"asyncDispatched()\", state));\n        }\n    }\n\n    public synchronized boolean asyncError() {\n        boolean doDispatch = false;\n        if (state == AsyncState.DISPATCHED ||\n                state == AsyncState.TIMING_OUT) {\n            state = AsyncState.ERROR;\n        } else {\n            throw new IllegalStateException(\n                    sm.getString(\"asyncStateMachine.invalidAsyncState\",\n                            \"asyncError()\", state));\n        }\n        return doDispatch;\n    }",
        "    public void testStop() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Wrapper w =\n            Tomcat.addServlet(root, \"tester\", new TesterServlet());\n        w.setAsyncSupported(true);\n        root.addServletMapping(\"/\", \"tester\");\n\n        Connector connector = tomcat.getConnector();\n\n        tomcat.start();\n\n        ByteChunk bc = new ByteChunk();\n        int rc = getUrl(\"http://localhost:\" + getPort() + \"/\", bc, null, null);\n\n        assertEquals(200, rc);\n        assertEquals(\"OK\", bc.toString());\n\n        rc = -1;\n        bc.recycle();\n\n        connector.stop();\n\n        try {\n            rc = getUrl(\"http://localhost:\" + getPort() + \"/\", bc, 1000,\n                    null, null);\n        } catch (SocketTimeoutException ste) {\n            // May also see this with NIO\n            // Make sure the test passes if we do\n            rc = 503;\n        }\n        assertEquals(503, rc);\n    }",
        "    public int handshake(boolean read, boolean write) throws IOException {\n        if ( handshakeComplete ) return 0; //we have done our initial handshake\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; //we still have data to write\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    //should never happen\n                    throw new IOException(\"NOT_HANDSHAKING during handshake\");\n                }\n                case FINISHED: {\n                    //we are complete if we have delivered the last package\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    //return 0 if we are complete, otherwise we still have data to write\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    //perform the wrap function\n                    handshake = handshakeWrap(write);\n                    if ( handshake.getStatus() == Status.OK ){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        //wrap should always work with our buffers\n                        throw new IOException(\"Unexpected status:\" + handshake.getStatus() + \" during handshake WRAP.\");\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        //should actually return OP_READ if we have NEED_UNWRAP\n                        return SelectionKey.OP_WRITE;\n                    }\n                    //fall down to NEED_UNWRAP on the same call, will result in a\n                    //BUFFER_UNDERFLOW if it needs data\n                }\n                //$FALL-THROUGH$\n                case NEED_UNWRAP: {\n                    //perform the unwrap function\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        //read more data, reregister for OP_READ\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(\"Invalid handshake status:\"+handshakeStatus+\" during handshake UNWRAP.\");\n                    }//switch\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(\"Invalid handshake status:\"+handshakeStatus);\n            }//switch\n        }//while\n        //return 0 if we are complete, otherwise reregister for any activity that\n        //would cause this method to be called again.\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }",
        "    public void rehandshake(long timeout) throws IOException {\n        //validate the network buffers are empty\n        if (netInBuffer.position() > 0 && netInBuffer.position()<netInBuffer.limit()) throw new IOException(\"Network input buffer still contains data. Handshake will fail.\");\n        if (netOutBuffer.position() > 0 && netOutBuffer.position()<netOutBuffer.limit()) throw new IOException(\"Network output buffer still contains data. Handshake will fail.\");\n        if (getBufHandler().getReadBuffer().position()>0 && getBufHandler().getReadBuffer().position()<getBufHandler().getReadBuffer().limit()) throw new IOException(\"Application input buffer still contains data. Data would have been lost.\");\n        if (getBufHandler().getWriteBuffer().position()>0 && getBufHandler().getWriteBuffer().position()<getBufHandler().getWriteBuffer().limit()) throw new IOException(\"Application output buffer still contains data. Data would have been lost.\");\n        reset();\n        boolean isReadable = true;\n        boolean isWriteable = true;\n        boolean handshaking = true;\n        Selector selector = null;\n        SelectionKey key = null;\n        try {\n            while (handshaking) {\n                int hsStatus = this.handshake(isReadable, isWriteable);\n                switch (hsStatus) {\n                    case -1 : throw new EOFException(\"EOF during handshake.\");\n                    case  0 : handshaking = false; break;\n                    default : {\n                        long now = System.currentTimeMillis();\n                        if (selector==null) {\n                            synchronized (Selector.class) {\n                                // Selector.open() isn't thread safe\n                                // http://bugs.sun.com/view_bug.do?bug_id=6427854\n                                // Affects 1.6.0_29, fixed in 1.7.0_01\n                                selector = Selector.open();\n                            }\n                            key = getIOChannel().register(selector, hsStatus);\n                        } else {\n                            key.interestOps(hsStatus);\n                        }\n                        int keyCount = selector.select(timeout);\n                        if (keyCount == 0 && ((System.currentTimeMillis()-now) >= timeout)) {\n                            throw new SocketTimeoutException(\"Handshake operation timed out.\");\n                        }\n                        isReadable = key.isReadable();\n                        isWriteable = key.isWritable();\n                    }\n                }\n            }\n        } catch (IOException x) {\n            throw x;\n        } catch (Exception cx) {\n            IOException x = new IOException(cx);\n            throw x;\n        } finally {\n            if (key!=null) try {key.cancel();} catch (Exception ignore) {}\n            if (selector!=null) try {selector.close();} catch (Exception ignore) {}\n        }\n    }",
        "    protected SSLEngineResult.HandshakeStatus tasks() {\n        Runnable r = null;\n        while ( (r = sslEngine.getDelegatedTask()) != null) {\n            r.run();\n        }\n        return sslEngine.getHandshakeStatus();\n    }\n\n    protected SSLEngineResult handshakeWrap(boolean doWrite) throws IOException {\n        //this should never be called with a network buffer that contains data\n        //so we can clear it here.\n        netOutBuffer.clear();\n        //perform the wrap\n        SSLEngineResult result = sslEngine.wrap(bufHandler.getWriteBuffer(), netOutBuffer);\n        //prepare the results to be written\n        netOutBuffer.flip();\n        //set the status\n        handshakeStatus = result.getHandshakeStatus();\n        //optimization, if we do have a writable channel, write it now\n        if ( doWrite ) flush(netOutBuffer);\n        return result;\n    }",
        "    protected SSLEngineResult handshakeUnwrap(boolean doread) throws IOException {\n\n        if (netInBuffer.position() == netInBuffer.limit()) {\n            //clear the buffer if we have emptied it out on data\n            netInBuffer.clear();\n        }\n        if ( doread )  {\n            //if we have data to read, read it\n            int read = sc.read(netInBuffer);\n            if (read == -1) throw new IOException(\"EOF encountered during handshake.\");\n        }\n        SSLEngineResult result;\n        boolean cont = false;\n        //loop while we can perform pure SSLEngine data\n        do {\n            //prepare the buffer with the incoming data\n            netInBuffer.flip();\n            //call unwrap\n            result = sslEngine.unwrap(netInBuffer, bufHandler.getReadBuffer());\n            //compact the buffer, this is an optional method, wonder what would happen if we didn't\n            netInBuffer.compact();\n            //read in the status\n            handshakeStatus = result.getHandshakeStatus();\n            if ( result.getStatus() == SSLEngineResult.Status.OK &&\n                 result.getHandshakeStatus() == HandshakeStatus.NEED_TASK ) {\n                //execute tasks if we need to\n                handshakeStatus = tasks();\n            }\n            //perform another unwrap?\n            cont = result.getStatus() == SSLEngineResult.Status.OK &&\n                   handshakeStatus == HandshakeStatus.NEED_UNWRAP;\n        }while ( cont );\n        return result;\n    }",
        "    public void close() throws IOException {\n        if (closing) return;\n        closing = true;\n        sslEngine.closeOutbound();\n\n        if (!flush(netOutBuffer)) {\n            throw new IOException(\"Remaining data in the network buffer, can't send SSL close message, force a close with close(true) instead\");\n        }\n        //prep the buffer for the close message\n        netOutBuffer.clear();\n        //perform the close, since we called sslEngine.closeOutbound\n        SSLEngineResult handshake = sslEngine.wrap(getEmptyBuf(), netOutBuffer);\n        //we should be in a close state\n        if (handshake.getStatus() != SSLEngineResult.Status.CLOSED) {\n            throw new IOException(\"Invalid close state, will not send network data.\");\n        }\n        //prepare the buffer for writing\n        netOutBuffer.flip();\n        //if there is data to be written\n        flush(netOutBuffer);\n\n        //is the channel closed?\n        closed = (!netOutBuffer.hasRemaining() && (handshake.getHandshakeStatus() != HandshakeStatus.NEED_WRAP));\n    }\n\n    public void close(boolean force) throws IOException {\n        try {\n            close();\n        }finally {\n            if ( force || closed ) {\n                closed = true;\n                sc.socket().close();\n                sc.close();\n            }\n        }\n    }",
        "    public int write(ByteBuffer src) throws IOException {\n        if ( src == this.netOutBuffer ) {\n            //we can get here through a recursive call\n            //by using the NioBlockingSelector\n            int written = sc.write(src);\n            return written;\n        } else {\n            //make sure we can handle expand, and that we only use on buffer\n            if ( (!this.isSendFile()) && (src != bufHandler.getWriteBuffer()) ) throw new IllegalArgumentException(\"You can only write using the application write buffer provided by the handler.\");\n            //are we closing or closed?\n            if ( closing || closed) throw new IOException(\"Channel is in closing state.\");\n\n            //the number of bytes written\n            int written = 0;\n\n            if (!flush(netOutBuffer)) {\n                //we haven't emptied out the buffer yet\n                return written;\n            }\n\n            /*\n             * The data buffer is empty, we can reuse the entire buffer.\n             */\n            netOutBuffer.clear();\n\n            SSLEngineResult result = sslEngine.wrap(src, netOutBuffer);\n            written = result.bytesConsumed();\n            netOutBuffer.flip();\n\n            if (result.getStatus() == Status.OK) {\n                if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) tasks();\n            } else {\n                throw new IOException(\"Unable to wrap data, invalid engine state: \" +result.getStatus());\n            }\n\n            //force a flush\n            flush(netOutBuffer);\n\n            return written;\n        }\n    }",
        "    public void complete() {\n        if (log.isDebugEnabled()) {\n            logDebug(\"complete   \");\n        }\n        check();\n        request.getCoyoteRequest().action(ActionCode.COMMIT, null);\n        request.getCoyoteRequest().action(ActionCode.ASYNC_COMPLETE, null);\n    }",
        "    public void fireOnComplete() {\n        List<AsyncListenerWrapper> listenersCopy =\n            new ArrayList<AsyncListenerWrapper>();\n        listenersCopy.addAll(listeners);\n\n        ClassLoader oldCL;\n        if (Globals.IS_SECURITY_ENABLED) {\n            PrivilegedAction<ClassLoader> pa = new PrivilegedGetTccl();\n            oldCL = AccessController.doPrivileged(pa);\n        } else {\n            oldCL = Thread.currentThread().getContextClassLoader();\n        }\n        ClassLoader newCL = context.getLoader().getClassLoader();\n\n        try {\n            if (Globals.IS_SECURITY_ENABLED) {\n                PrivilegedAction<Void> pa = new PrivilegedSetTccl(newCL);\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(newCL);\n            }\n            for (AsyncListenerWrapper listener : listenersCopy) {\n                try {\n                    listener.fireOnComplete(event);\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.warn(\"onComplete() failed for listener of type [\" +\n                            listener.getClass().getName() + \"]\", t);\n                }\n            }\n        } finally {\n            if (Globals.IS_SECURITY_ENABLED) {\n                PrivilegedAction<Void> pa = new PrivilegedSetTccl(oldCL);\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(oldCL);\n            }\n        }\n    }",
        "    public boolean timeout() {\n        AtomicBoolean result = new AtomicBoolean();\n        request.getCoyoteRequest().action(ActionCode.ASYNC_TIMEOUT, result);\n\n        if (result.get()) {\n\n            ClassLoader oldCL = Thread.currentThread().getContextClassLoader();\n            ClassLoader newCL = request.getContext().getLoader().getClassLoader();\n            try {\n                Thread.currentThread().setContextClassLoader(newCL);\n                List<AsyncListenerWrapper> listenersCopy =\n                    new ArrayList<AsyncListenerWrapper>();\n                listenersCopy.addAll(listeners);\n                for (AsyncListenerWrapper listener : listenersCopy) {\n                    try {\n                        listener.fireOnTimeout(event);\n                    } catch (Throwable t) {\n                        ExceptionUtils.handleThrowable(t);\n                        log.warn(\"onTimeout() failed for listener of type [\" +\n                                listener.getClass().getName() + \"]\", t);\n                    }\n                }\n                request.getCoyoteRequest().action(\n                        ActionCode.ASYNC_IS_TIMINGOUT, result);\n                return !result.get();\n            } finally {\n                Thread.currentThread().setContextClassLoader(oldCL);\n            }\n        }\n        return true;\n    }",
        "    public void dispatch(ServletContext context, String path) {\n        if (log.isDebugEnabled()) {\n            logDebug(\"dispatch   \");\n        }\n        check();\n        if (dispatch != null) {\n            throw new IllegalStateException(\n                    sm.getString(\"asyncContextImpl.dispatchingStarted\"));\n        }\n        if (request.getAttribute(ASYNC_REQUEST_URI)==null) {\n            request.setAttribute(ASYNC_REQUEST_URI, request.getRequestURI());\n            request.setAttribute(ASYNC_CONTEXT_PATH, request.getContextPath());\n            request.setAttribute(ASYNC_SERVLET_PATH, request.getServletPath());\n            request.setAttribute(ASYNC_PATH_INFO, request.getPathInfo());\n            request.setAttribute(ASYNC_QUERY_STRING, request.getQueryString());\n        }\n        final RequestDispatcher requestDispatcher = context.getRequestDispatcher(path);\n        if (!(requestDispatcher instanceof AsyncDispatcher)) {\n            throw new UnsupportedOperationException(\n                    sm.getString(\"asyncContextImpl.noAsyncDispatcher\"));\n        }\n        final AsyncDispatcher applicationDispatcher =\n                (AsyncDispatcher) requestDispatcher;\n        final ServletRequest servletRequest = getRequest();\n        final ServletResponse servletResponse = getResponse();\n        Runnable run = new Runnable() {\n            @Override\n            public void run() {\n                request.getCoyoteRequest().action(ActionCode.ASYNC_DISPATCHED, null);\n                try {\n                    applicationDispatcher.dispatch(servletRequest, servletResponse);\n                }catch (Exception x) {\n                    //log.error(\"Async.dispatch\",x);\n                    throw new RuntimeException(x);\n                }\n            }\n        };\n\n        this.dispatch = run;\n        this.request.getCoyoteRequest().action(ActionCode.ASYNC_DISPATCH, null);\n    }",
        "    public void start(final Runnable run) {\n        if (log.isDebugEnabled()) {\n            logDebug(\"start      \");\n        }\n        check();\n        Runnable wrapper = new RunnableWrapper(run, context);\n        this.request.getCoyoteRequest().action(ActionCode.ASYNC_RUN, wrapper);\n    }\n\n    public void recycle() {\n        if (log.isDebugEnabled()) {\n            logDebug(\"recycle    \");\n        }\n        context = null;\n        dispatch = null;\n        event = null;\n        hasOriginalRequestAndResponse = true;\n        instanceManager = null;\n        listeners.clear();\n        request = null;\n        servletRequest = null;\n        servletResponse = null;\n        timeout = -1;\n    }",
        "    protected void doInternalDispatch() throws ServletException, IOException {\n        if (log.isDebugEnabled()) {\n            logDebug(\"intDispatch\");\n        }\n        try {\n            Runnable runnable = dispatch;\n            dispatch = null;\n            runnable.run();\n            if (!request.isAsync()) {\n                fireOnComplete();\n            }\n        } catch (RuntimeException x) {\n            // doInternalComplete(true);\n            if (x.getCause() instanceof ServletException) {\n                throw (ServletException)x.getCause();\n            }\n            if (x.getCause() instanceof IOException) {\n                throw (IOException)x.getCause();\n            }\n            throw new ServletException(x);\n        }\n    }",
        "    private void check() {\n        if (request == null) {\n            // AsyncContext has been recycled and should not be being used\n            throw new IllegalStateException(sm.getString(\n                    \"asyncContextImpl.requestEnded\"));\n        }\n    }",
        "    public void put(Selector s) throws IOException {\n        if ( SHARED ) return;\n        if ( enabled ) active.decrementAndGet();\n        if ( enabled && (maxSpareSelectors==-1 || spare.get() < Math.min(maxSpareSelectors,maxSelectors)) ) {\n            spare.incrementAndGet();\n            selectors.offer(s);\n        }\n        else s.close();\n    }\n\n    public void close() throws IOException {\n        enabled = false;\n        Selector s;\n        while ( (s = selectors.poll()) != null ) s.close();\n        spare.set(0);\n        active.set(0);\n        if (blockingSelector!=null) {\n            blockingSelector.close();\n        }\n        if ( SHARED && getSharedSelector()!=null ) {\n            getSharedSelector().close();\n            SHARED_SELECTOR = null;\n        }\n    }\n\n    public void open() throws IOException {\n        enabled = true;\n        getSharedSelector();\n        if (SHARED) {\n            blockingSelector = new NioBlockingSelector();\n            blockingSelector.open(getSharedSelector());\n        }\n\n    }",
        "    public int write(ByteBuffer buf, NioChannel socket, Selector selector, long writeTimeout) throws IOException {\n        return write(buf,socket,selector,writeTimeout,true);\n    }\n\n    public int read(ByteBuffer buf, NioChannel socket, Selector selector, long readTimeout) throws IOException {\n        return read(buf,socket,selector,readTimeout,true);\n    }",
        "    public int read(ByteBuffer buf, NioChannel socket, Selector selector, long readTimeout, boolean block) throws IOException {\n        if ( SHARED && block ) {\n            return blockingSelector.read(buf,socket,readTimeout);\n        }\n        SelectionKey key = null;\n        int read = 0;\n        boolean timedout = false;\n        int keycount = 1; //assume we can write\n        long time = System.currentTimeMillis(); //start the timeout timer\n        try {\n            while ( (!timedout) ) {\n                int cnt = 0;\n                if ( keycount > 0 ) { //only read if we were registered for a read\n                    cnt = socket.read(buf);\n                    if (cnt == -1) throw new EOFException();\n                    read += cnt;\n                    if (cnt > 0) continue; //read some more\n                    if (cnt==0 && (read>0 || (!block) ) ) break; //we are done reading\n                }\n                if ( selector != null ) {//perform a blocking read\n                    //register OP_WRITE to the selector\n                    if (key==null) key = socket.getIOChannel().register(selector, SelectionKey.OP_READ);\n                    else key.interestOps(SelectionKey.OP_READ);\n                    keycount = selector.select(readTimeout);\n                }\n                if (readTimeout > 0 && (selector == null || keycount == 0) ) timedout = (System.currentTimeMillis()-time)>=readTimeout;\n            }//while\n            if ( timedout ) throw new SocketTimeoutException();\n        } finally {\n            if (key != null) {\n                key.cancel();\n                if (selector != null) selector.selectNow();//removes the key from this selector\n            }\n        }\n        return read;\n    }",
        "    protected void actionInternal(ActionCode actionCode, Object param) {\n\n        if (actionCode == ActionCode.ASYNC_COMPLETE) {\n            if (asyncStateMachine.asyncComplete()) {\n                ((NioEndpoint)endpoint).processSocket(this.socket,\n                        SocketStatus.OPEN_READ, false);\n            }\n\n        } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {\n            if (param == null) return;\n            long timeout = ((Long)param).longValue();\n            final KeyAttachment ka = (KeyAttachment)socket.getAttachment(false);\n            ka.setTimeout(timeout);\n\n        } else if (actionCode == ActionCode.ASYNC_DISPATCH) {\n            if (asyncStateMachine.asyncDispatch()) {\n                ((NioEndpoint)endpoint).processSocket(this.socket,\n                        SocketStatus.OPEN_READ, true);\n            }\n        }\n    }\n\n    protected void resetTimeouts() {\n        // The NIO connector uses the timeout configured on the wrapper in the\n        // poller. Therefore, it needs to be reset once asycn processing has\n        // finished.\n        final KeyAttachment attach = (KeyAttachment)socket.getAttachment(false);\n        if (!error && attach != null &&\n                asyncStateMachine.isAsyncDispatching()) {\n            long soTimeout = endpoint.getSoTimeout();\n\n            //reset the timeout\n            if (keepAliveTimeout > 0) {\n                attach.setTimeout(keepAliveTimeout);\n            } else {\n                attach.setTimeout(soTimeout);\n            }\n        }\n\n    }",
        "    protected void resetTimeouts() {\n        final NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socket.getSocket().getAttachment(false);\n        if (!error && attach != null &&\n                asyncStateMachine.isAsyncDispatching()) {\n            long soTimeout = endpoint.getSoTimeout();\n\n            //reset the timeout\n            if (keepAlive) {\n                attach.setTimeout(keepAliveTimeout);\n            } else {\n                attach.setTimeout(soTimeout);\n            }\n        }\n    }",
        "    protected boolean handleIncompleteRequestLineRead() {\n        // Haven't finished reading the request so keep the socket\n        // open\n        openSocket = true;\n        // Check to see if we have read any of the request line yet\n        if (inputBuffer.getParsingRequestLinePhase() < 2) {\n            if (socket.getLastAccess() > -1 || keptAlive) {\n                // Haven't read the request line and have previously processed a\n                // request. Must be keep-alive. Make sure poller uses keepAlive.\n                socket.setTimeout(endpoint.getKeepAliveTimeout());\n            }\n        } else {\n            // Started to read request line. Need to keep processor\n            // associated with socket\n            readComplete = false;\n            // Make sure poller uses soTimeout from here onwards\n            socket.setTimeout(endpoint.getSoTimeout());\n        }\n        if (endpoint.isPaused()) {\n            // 503 - Service unavailable\n            response.setStatus(503);\n            adapter.log(request, response, 0);\n            error = true;\n        } else {\n            return true;\n        }\n        return false;\n    }",
        "    public void actionInternal(ActionCode actionCode, Object param) {\n\n        if (actionCode == ActionCode.REQ_HOST_ADDR_ATTRIBUTE) {\n\n            // Get remote host address\n            if ((remoteAddr == null) && (socket != null)) {\n                InetAddress inetAddr = socket.getSocket().getIOChannel().socket().getInetAddress();\n                if (inetAddr != null) {\n                    remoteAddr = inetAddr.getHostAddress();\n                }\n            }\n            request.remoteAddr().setString(remoteAddr);\n\n        } else if (actionCode == ActionCode.REQ_LOCAL_NAME_ATTRIBUTE) {\n\n            // Get local host name\n            if ((localName == null) && (socket != null)) {\n                InetAddress inetAddr = socket.getSocket().getIOChannel().socket().getLocalAddress();\n                if (inetAddr != null) {\n                    localName = inetAddr.getHostName();\n                }\n            }\n            request.localName().setString(localName);\n\n        } else if (actionCode == ActionCode.REQ_HOST_ATTRIBUTE) {\n\n            // Get remote host name\n            if ((remoteHost == null) && (socket != null)) {\n                InetAddress inetAddr = socket.getSocket().getIOChannel().socket().getInetAddress();\n                if (inetAddr != null) {\n                    remoteHost = inetAddr.getHostName();\n                }\n                if(remoteHost == null) {\n                    if(remoteAddr != null) {\n                        remoteHost = remoteAddr;\n                    } else { // all we can do is punt\n                        request.remoteHost().recycle();\n                    }\n                }\n            }\n            request.remoteHost().setString(remoteHost);\n\n        } else if (actionCode == ActionCode.REQ_LOCAL_ADDR_ATTRIBUTE) {\n\n            if (localAddr == null) {\n                localAddr = socket.getSocket().getIOChannel().socket().getLocalAddress().getHostAddress();\n            }\n\n            request.localAddr().setString(localAddr);\n\n        } else if (actionCode == ActionCode.REQ_REMOTEPORT_ATTRIBUTE) {\n\n            if ((remotePort == -1 ) && (socket !=null)) {\n                remotePort = socket.getSocket().getIOChannel().socket().getPort();\n            }\n            request.setRemotePort(remotePort);\n\n        } else if (actionCode == ActionCode.REQ_LOCALPORT_ATTRIBUTE) {\n\n            if ((localPort == -1 ) && (socket !=null)) {\n                localPort = socket.getSocket().getIOChannel().socket().getLocalPort();\n            }\n            request.setLocalPort(localPort);\n\n        } else if (actionCode == ActionCode.REQ_SSL_ATTRIBUTE ) {\n\n            try {\n                if (sslSupport != null) {\n                    Object sslO = sslSupport.getCipherSuite();\n                    if (sslO != null) {\n                        request.setAttribute\n                            (SSLSupport.CIPHER_SUITE_KEY, sslO);\n                    }\n                    sslO = sslSupport.getPeerCertificateChain(false);\n                    if (sslO != null) {\n                        request.setAttribute\n                            (SSLSupport.CERTIFICATE_KEY, sslO);\n                    }\n                    sslO = sslSupport.getKeySize();\n                    if (sslO != null) {\n                        request.setAttribute\n                            (SSLSupport.KEY_SIZE_KEY, sslO);\n                    }\n                    sslO = sslSupport.getSessionId();\n                    if (sslO != null) {\n                        request.setAttribute\n                            (SSLSupport.SESSION_ID_KEY, sslO);\n                    }\n                    request.setAttribute(SSLSupport.SESSION_MGR, sslSupport);\n                }\n            } catch (Exception e) {\n                log.warn(sm.getString(\"http11processor.socket.ssl\"), e);\n            }\n\n        } else if (actionCode == ActionCode.REQ_SSL_CERTIFICATE) {\n\n            if( sslSupport != null) {\n                /*\n                 * Consume and buffer the request body, so that it does not\n                 * interfere with the client's handshake messages\n                 */\n                InputFilter[] inputFilters = inputBuffer.getFilters();\n                ((BufferedInputFilter) inputFilters[Constants.BUFFERED_FILTER])\n                    .setLimit(maxSavePostSize);\n                inputBuffer.addActiveFilter\n                    (inputFilters[Constants.BUFFERED_FILTER]);\n                SecureNioChannel sslChannel = (SecureNioChannel) socket.getSocket();\n                SSLEngine engine = sslChannel.getSslEngine();\n                if (!engine.getNeedClientAuth()) {\n                    // Need to re-negotiate SSL connection\n                    engine.setNeedClientAuth(true);\n                    try {\n                        sslChannel.rehandshake(endpoint.getSoTimeout());\n                        sslSupport = ((NioEndpoint)endpoint).getHandler()\n                                .getSslImplementation().getSSLSupport(\n                                        engine.getSession());\n                    } catch (IOException ioe) {\n                        log.warn(sm.getString(\"http11processor.socket.sslreneg\",ioe));\n                    }\n                }\n\n                try {\n                    // use force=false since re-negotiation is handled above\n                    // (and it is a NO-OP for NIO anyway)\n                    Object sslO = sslSupport.getPeerCertificateChain(false);\n                    if( sslO != null) {\n                        request.setAttribute\n                            (SSLSupport.CERTIFICATE_KEY, sslO);\n                    }\n                } catch (Exception e) {\n                    log.warn(sm.getString(\"http11processor.socket.ssl\"), e);\n                }\n            }\n\n        } else if (actionCode == ActionCode.AVAILABLE) {\n            request.setAvailable(inputBuffer.available());\n        } else if (actionCode == ActionCode.COMET_BEGIN) {\n            comet = true;\n        } else if (actionCode == ActionCode.COMET_END) {\n            comet = false;\n        }  else if (actionCode == ActionCode.COMET_CLOSE) {\n            if (socket==null || socket.getSocket().getAttachment(false)==null) {\n                return;\n            }\n            NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socket.getSocket().getAttachment(false);\n            attach.setCometOps(NioEndpoint.OP_CALLBACK);\n            RequestInfo rp = request.getRequestProcessor();\n            if (rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE) {\n                // Close event for this processor triggered by request\n                // processing in another processor, a non-Tomcat thread (i.e.\n                // an application controlled thread) or similar.\n                socket.getSocket().getPoller().add(socket.getSocket());\n            }\n        } else if (actionCode == ActionCode.COMET_SETTIMEOUT) {\n            if (param==null) {\n                return;\n            }\n            if (socket==null || socket.getSocket().getAttachment(false)==null) {\n                return;\n            }\n            NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socket.getSocket().getAttachment(false);\n            long timeout = ((Long)param).longValue();\n            //if we are not piggy backing on a worker thread, set the timeout\n            RequestInfo rp = request.getRequestProcessor();\n            if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) {\n                attach.setTimeout(timeout);\n            }\n        } else if (actionCode == ActionCode.ASYNC_COMPLETE) {\n            if (asyncStateMachine.asyncComplete()) {\n                ((NioEndpoint)endpoint).processSocket(this.socket.getSocket(),\n                        SocketStatus.OPEN_READ, true);\n            }\n        } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {\n            if (param==null) {\n                return;\n            }\n            if (socket==null || socket.getSocket().getAttachment(false)==null) {\n                return;\n            }\n            NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socket.getSocket().getAttachment(false);\n            long timeout = ((Long)param).longValue();\n            //if we are not piggy backing on a worker thread, set the timeout\n            attach.setTimeout(timeout);\n        } else if (actionCode == ActionCode.ASYNC_DISPATCH) {\n            if (asyncStateMachine.asyncDispatch()) {\n                ((NioEndpoint)endpoint).processSocket(this.socket.getSocket(),\n                        SocketStatus.OPEN_READ, true);\n            }\n        }\n    }",
        "    protected boolean prepareSendfile(OutputFilter[] outputFilters) {\n        String fileName = (String) request.getAttribute(\n                org.apache.coyote.Constants.SENDFILE_FILENAME_ATTR);\n        if (fileName != null) {\n            // No entity body sent here\n            outputBuffer.addActiveFilter(outputFilters[Constants.VOID_FILTER]);\n            contentDelimitation = true;\n            sendfileData = new NioEndpoint.SendfileData();\n            sendfileData.fileName = fileName;\n            sendfileData.pos = ((Long) request.getAttribute(\n                    org.apache.coyote.Constants.SENDFILE_FILE_START_ATTR)).longValue();\n            sendfileData.length = ((Long) request.getAttribute(\n                    org.apache.coyote.Constants.SENDFILE_FILE_END_ATTR)).longValue() - sendfileData.pos;\n            return true;\n        }\n        return false;\n    }",
        "    public void testAsyncStartNoComplete() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Minimise pauses during test\n        tomcat.getConnector().setAttribute(\n                \"connectionTimeout\", Integer.valueOf(3000));\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        AsyncStartNoCompleteServlet servlet =\n            new AsyncStartNoCompleteServlet();\n\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"servlet\", servlet);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        // Call the servlet the first time\n        ByteChunk bc1 = getUrl(\"http://localhost:\" + getPort() +\n                \"/?echo=run1\");\n        assertEquals(\"OK-run1\", bc1.toString());\n\n        // Call the servlet the second time with a request parameter\n        ByteChunk bc2 = getUrl(\"http://localhost:\" + getPort() +\n                \"/?echo=run2\");\n        assertEquals(\"OK-run2\", bc2.toString());\n\n        // Check the access log\n        alv.validateAccessLog(2, 500,\n                AsyncStartNoCompleteServlet.ASYNC_TIMEOUT,\n                AsyncStartNoCompleteServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN +\n                        REQUEST_TIME);\n    }",
        "    public void testTimeoutListenerCompleteNonAsyncDispatch() throws Exception {\n        // Should trigger an error - can't do both\n        doTestTimeout(Boolean.TRUE, Boolean.FALSE);\n    }\n\n    public void testTimeoutListenerCompleteAsyncDispatch() throws Exception {\n        // Should trigger an error - can't do both\n        doTestTimeout(Boolean.TRUE, Boolean.TRUE);\n    }\n\n    public void testTimeoutNoListener() throws Exception {\n        // Should work\n        doTestTimeout(null, null);\n    }",
        "    private void doTestDispatch(int iter, boolean useThread) throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        DispatchingServlet dispatch = new DispatchingServlet(false, false);\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"dispatch\", dispatch);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/stage1\", \"dispatch\");\n\n        NonAsyncServlet nonasync = new NonAsyncServlet();\n        Wrapper wrapper2 = Tomcat.addServlet(ctx, \"nonasync\", nonasync);\n        wrapper2.setAsyncSupported(true);\n        ctx.addServletMapping(\"/stage2\", \"nonasync\");\n\n        ctx.addApplicationListener(new ApplicationListener(\n                TrackingRequestListener.class.getName(), false));\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/stage1?iter=\");\n        url.append(iter);\n        if (useThread) {\n            url.append(\"&useThread=y\");\n        }\n        ByteChunk res = getUrl(url.toString());\n\n        StringBuilder expected = new StringBuilder(\"requestInitialized-\");\n        int loop = iter;\n        while (loop > 0) {\n            expected.append(\"DispatchingServletGet-\");\n            loop--;\n        }\n        expected.append(\"NonAsyncServletGet-\");\n        expected.append(\"requestDestroyed\");\n        assertEquals(expected.toString(), res.toString());\n\n        // Check the access log\n        alv.validateAccessLog(1, 200, 0, REQUEST_TIME);\n    }",
        "    public void testListeners() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n\n        TrackingServlet tracking = new TrackingServlet();\n        Wrapper wrapper = Tomcat.addServlet(ctx, \"tracking\", tracking);\n        wrapper.setAsyncSupported(true);\n        ctx.addServletMapping(\"/stage1\", \"tracking\");\n\n        TimeoutServlet timeout = new TimeoutServlet(Boolean.TRUE, null);\n        Wrapper wrapper2 = Tomcat.addServlet(ctx, \"timeout\", timeout);\n        wrapper2.setAsyncSupported(true);\n        ctx.addServletMapping(\"/stage2\", \"timeout\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        ctx.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/stage1\");\n\n        ByteChunk res = getUrl(url.toString());\n\n        assertEquals(\n                \"DispatchingServletGet-DispatchingServletGet-onStartAsync-\" +\n                \"TimeoutServletGet-onStartAsync-onTimeout-onComplete-\",\n                res.toString());\n\n        // Check the access log\n        alv.validateAccessLog(1, 200, TimeoutServlet.ASYNC_TIMEOUT,\n                TimeoutServlet.ASYNC_TIMEOUT + TIMEOUT_MARGIN + REQUEST_TIME);\n    }",
        "    public void testBug53843() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        File docBase = new File(System.getProperty(\"java.io.tmpdir\"));\n\n        Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());\n        Bug53843ServletA servletA = new Bug53843ServletA();\n        Wrapper a = Tomcat.addServlet(ctx, \"ServletA\", servletA);\n        a.setAsyncSupported(true);\n        Tomcat.addServlet(ctx, \"ServletB\", new Bug53843ServletB());\n\n        ctx.addServletMapping(\"/ServletA\", \"ServletA\");\n        ctx.addServletMapping(\"/ServletB\", \"ServletB\");\n\n        tomcat.start();\n\n        StringBuilder url = new StringBuilder(48);\n        url.append(\"http://localhost:\");\n        url.append(getPort());\n        url.append(\"/ServletA\");\n\n        ByteChunk body = new ByteChunk();\n        int rc = getUrl(url.toString(), body, null);\n\n        assertEquals(HttpServletResponse.SC_OK, rc);\n        assertEquals(\"OK\", body.toString());\n        assertTrue(servletA.isAsyncWhenExpected());\n    }\n\n    public void testTimeoutErrorDispatchNone() throws Exception {\n        doTestTimeoutErrorDispatch(null, null);\n    }\n\n    public void testTimeoutErrorDispatchNonAsync() throws Exception {\n        doTestTimeoutErrorDispatch(Boolean.FALSE, null);\n    }",
        "    public synchronized void sendMessage(Member[] destination, ChannelMessage msg) throws ChannelException {\n        long start = System.currentTimeMillis();\n        this.setUdpBased((msg.getOptions()&Channel.SEND_OPTIONS_UDP) == Channel.SEND_OPTIONS_UDP);\n        byte[] data = XByteBuffer.createDataPackage((ChannelData)msg);\n        NioSender[] senders = setupForSend(destination);\n        connect(senders);\n        setData(senders,data);\n\n        int remaining = senders.length;\n        ChannelException cx = null;\n        try {\n            //loop until complete, an error happens, or we timeout\n            long delta = System.currentTimeMillis() - start;\n            boolean waitForAck = (Channel.SEND_OPTIONS_USE_ACK & msg.getOptions()) == Channel.SEND_OPTIONS_USE_ACK;\n            while ( (remaining>0) && (delta<getTimeout()) ) {\n                try {\n                    remaining -= doLoop(selectTimeout, getMaxRetryAttempts(),waitForAck,msg);\n                } catch (Exception x ) {\n                    if (log.isTraceEnabled()) log.trace(\"Error sending message\", x);\n                    int faulty = (cx == null)?0:cx.getFaultyMembers().length;\n                    if ( cx == null ) {\n                        if ( x instanceof ChannelException ) cx = (ChannelException)x;\n                        else cx = new ChannelException(\"Parallel NIO send failed.\", x);\n                    } else {\n                        if (x instanceof ChannelException) cx.addFaultyMember( ( (ChannelException) x).getFaultyMembers());\n                    }\n                    //count down the remaining on an error\n                    if (faulty<cx.getFaultyMembers().length) remaining -= (cx.getFaultyMembers().length-faulty);\n                }\n                //bail out if all remaining senders are failing\n                if ( cx != null && cx.getFaultyMembers().length == remaining ) throw cx;\n                delta = System.currentTimeMillis() - start;\n            }\n            if ( remaining > 0 ) {\n                //timeout has occurred\n                ChannelException cxtimeout = new ChannelException(\"Operation has timed out(\"+getTimeout()+\" ms.).\");\n                if ( cx==null ) cx = new ChannelException(\"Operation has timed out(\"+getTimeout()+\" ms.).\");\n                for (int i=0; i<senders.length; i++ ) {\n                    if (!senders[i].isComplete() ) cx.addFaultyMember(senders[i].getDestination(),cxtimeout);\n                }\n                throw cx;\n            } else if ( cx != null ) {\n                //there was an error\n                throw cx;\n            }\n        } catch (Exception x ) {\n            try { this.disconnect(); } catch (Exception e) {/*Ignore*/}\n            if ( x instanceof ChannelException ) throw (ChannelException)x;\n            else throw new ChannelException(x);\n        }\n\n    }",
        "    private int doLoop(long selectTimeOut, int maxAttempts, boolean waitForAck, ChannelMessage msg) throws IOException, ChannelException {\n        int completed = 0;\n        int selectedKeys = selector.select(selectTimeOut);\n\n        if (selectedKeys == 0) {\n            return 0;\n        }\n\n        Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n        while (it.hasNext()) {\n            SelectionKey sk = it.next();\n            it.remove();\n            int readyOps = sk.readyOps();\n            sk.interestOps(sk.interestOps() & ~readyOps);\n            NioSender sender = (NioSender) sk.attachment();\n            try {\n                if (sender.process(sk,waitForAck)) {\n                    completed++;\n                    sender.setComplete(true);\n                    if ( Logs.MESSAGES.isTraceEnabled() ) {\n                        Logs.MESSAGES.trace(\"ParallelNioSender - Sent msg:\" + new UniqueId(msg.getUniqueId()) + \" at \" +new java.sql.Timestamp(System.currentTimeMillis())+ \" to \"+sender.getDestination().getName());\n                    }\n                    SenderState.getSenderState(sender.getDestination()).setReady();\n                }//end if\n            } catch (Exception x) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Error while processing send to \" + sender.getDestination().getName(), x);\n                }\n                SenderState state = SenderState.getSenderState(sender.getDestination());\n                int attempt = sender.getAttempt()+1;\n                boolean retry = (sender.getAttempt() <= maxAttempts && maxAttempts>0);\n                synchronized (state) {\n\n                    //sk.cancel();\n                    if (state.isSuspect()) state.setFailing();\n                    if (state.isReady()) {\n                        state.setSuspect();\n                        if ( retry )\n                            log.warn(\"Member send is failing for:\" + sender.getDestination().getName() +\" ; Setting to suspect and retrying.\");\n                        else\n                            log.warn(\"Member send is failing for:\" + sender.getDestination().getName() +\" ; Setting to suspect.\", x);\n                    }\n                }\n                if ( !isConnected() ) {\n                    log.warn(\"Not retrying send for:\" + sender.getDestination().getName() + \"; Sender is disconnected.\");\n                    ChannelException cx = new ChannelException(\"Send failed, and sender is disconnected. Not retrying.\",x);\n                    cx.addFaultyMember(sender.getDestination(),x);\n                    throw cx;\n                }\n\n                byte[] data = sender.getMessage();\n                if ( retry ) {\n                    try {\n                        sender.disconnect();\n                        sender.connect();\n                        sender.setAttempt(attempt);\n                        sender.setMessage(data);\n                    }catch ( Exception ignore){\n                        state.setFailing();\n                    }\n                } else {\n                    ChannelException cx = new ChannelException(\"Send failed, attempt:\"+sender.getAttempt()+\" max:\"+maxAttempts,x);\n                    cx.addFaultyMember(sender.getDestination(),x);\n                    throw cx;\n                }//end if\n            }\n        }\n        return completed;\n\n    }",
        "    public boolean keepalive() {\n        boolean result = false;\n        for ( Iterator<Entry<Member, NioSender>> i = nioSenders.entrySet().iterator(); i.hasNext();) {\n            Map.Entry<Member, NioSender> entry = i.next();\n            NioSender sender = entry.getValue();\n            if ( sender.keepalive() ) {\n                //nioSenders.remove(entry.getKey());\n                i.remove();\n                result = true;\n            } else {\n                try {\n                    sender.read(null);\n                }catch ( IOException x ) {\n                    sender.disconnect();\n                    sender.reset();\n                    //nioSenders.remove(entry.getKey());\n                    i.remove();\n                    result = true;\n                }catch ( Exception x ) {\n                    log.warn(\"Error during keepalive test for sender:\"+sender,x);\n                }\n            }\n        }\n        //clean up any cancelled keys\n        if ( result ) try { selector.selectNow(); }catch (Exception e){/*Ignore*/}\n        return result;\n    }",
        "    public void flush() throws IOException {\n        NioEndpoint.KeyAttachment att =\n                (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);\n        if (att == null) {\n            throw new IOException(\"Key must be cancelled\");\n        }\n        long writeTimeout = att.getTimeout();\n        Selector selector = null;\n        try {\n            selector = pool.get();\n        } catch ( IOException x ) {\n            //ignore\n        }\n        try {\n            do {\n                if (nioChannel.flush(true, selector, writeTimeout)) {\n                    break;\n                }\n            } while (true);\n        } finally {\n            if (selector != null) {\n                pool.put(selector);\n            }\n        }\n    }\n\n    public void write(int b) throws IOException {\n        writeToSocket(new byte[] {(byte) b}, 0, 1);\n    }\n\n    public void write(byte[]b, int off, int len) throws IOException {\n        int written = 0;\n        while (len - written > maxWrite) {\n            written += writeToSocket(b, off + written, maxWrite);\n        }\n        writeToSocket(b, off + written, len - written);\n    }",
        "    public int read() throws IOException {\n        byte[] bytes = new byte[1];\n        int result = readSocket(true, bytes, 0, 1);\n        if (result == -1) {\n            return -1;\n        } else {\n            return bytes[0] & 0xFF;\n        }\n    }\n\n    private int fillReadBuffer(boolean block) throws IOException {\n        int nRead;\n        if (block) {\n            Selector selector = null;\n            try {\n                selector = pool.get();\n            } catch ( IOException x ) {\n                // Ignore\n            }\n            try {\n                NioEndpoint.KeyAttachment att =\n                        (NioEndpoint.KeyAttachment) nioChannel.getAttachment(false);\n                if (att == null) {\n                    throw new IOException(\"Key must be cancelled.\");\n                }\n                nRead = pool.read(nioChannel.getBufHandler().getReadBuffer(),\n                        nioChannel, selector, att.getTimeout());\n            } catch (EOFException eof) {\n                nRead = -1;\n            } finally {\n                if (selector != null) {\n                    pool.put(selector);\n                }\n            }\n        } else {\n            nRead = nioChannel.read(nioChannel.getBufHandler().getReadBuffer());\n        }\n        return nRead;\n    }",
        "    public void sendAck() throws IOException {\n\n        if (!committed) {\n            //Socket.send(socket, Constants.ACK_BYTES, 0, Constants.ACK_BYTES.length) < 0\n            socket.getBufHandler() .getWriteBuffer().put(Constants.ACK_BYTES,0,Constants.ACK_BYTES.length);    \n            writeToSocket(socket.getBufHandler() .getWriteBuffer(),true,true);\n        }\n\n    }\n\n    private synchronized int writeToSocket(ByteBuffer bytebuffer, boolean block, boolean flip) throws IOException {\n        if ( flip ) bytebuffer.flip();\n\n        int written = 0;\n        NioEndpoint.KeyAttachment att = (NioEndpoint.KeyAttachment)socket.getAttachment(false);\n        if ( att == null ) throw new IOException(\"Key must be cancelled\");\n        long writeTimeout = att.getWriteTimeout();\n        Selector selector = null;\n        try {\n            selector = pool.get();\n        } catch ( IOException x ) {\n            //ignore\n        }\n        try {\n            written = pool.write(bytebuffer, socket, selector, writeTimeout, block);\n            //make sure we are flushed \n            do {\n                if (socket.flush(true,selector,writeTimeout)) break;\n            }while ( true );\n        }finally { \n            if ( selector != null ) pool.put(selector);\n        }\n        if ( block ) bytebuffer.clear(); //only clear\n        return written;\n    } ",
        "    private synchronized void addToBB(byte[] buf, int offset, int length) throws IOException {\n        while (length > 0) {\n            int thisTime = length;\n            if (socket.getBufHandler().getWriteBuffer().position() ==\n                    socket.getBufHandler().getWriteBuffer().capacity()\n                    || socket.getBufHandler().getWriteBuffer().remaining()==0) {\n                flushBuffer();\n            }\n            if (thisTime > socket.getBufHandler().getWriteBuffer().remaining()) {\n                thisTime = socket.getBufHandler().getWriteBuffer().remaining();\n            }\n            socket.getBufHandler().getWriteBuffer().put(buf, offset, thisTime);\n            length = length - thisTime;\n            offset = offset + thisTime;\n        }\n        NioEndpoint.KeyAttachment ka = (NioEndpoint.KeyAttachment)socket.getAttachment(false);\n        if ( ka!= null ) ka.access();//prevent timeouts for just doing client writes\n    }\n\n    private void flushBuffer() throws IOException {\n\n        //prevent timeout for async,\n        SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());\n        if (key != null) {\n            NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) key.attachment();\n            attach.access();\n        }\n\n        //write to the socket, if there is anything to write\n        if (socket.getBufHandler().getWriteBuffer().position() > 0) {\n            socket.getBufHandler().getWriteBuffer().flip();\n            writeToSocket(socket.getBufHandler().getWriteBuffer(),true, false);\n        }\n    }",
        "    public void reset(E socket, long timeout) {\n        async = false;\n        blockingStatus = true;\n        comet = false;\n        error = false;\n        keepAliveLeft = 100;\n        lastAccess = System.currentTimeMillis();\n        this.socket = socket;\n        this.timeout = timeout;\n        upgraded = false;\n    }",
        "    public void stopInternal() {\n        releaseConnectionLatch();\n        if (!paused) {\n            pause();\n        }\n        if (running) {\n            running = false;\n            unlockAccept();\n            for (int i=0; pollers!=null && i<pollers.length; i++) {\n                if (pollers[i]==null) continue;\n                pollers[i].destroy();\n                pollers[i] = null;\n            }\n            try {\n                stopLatch.await(selectorTimeout + 100, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException ignore) {\n            }\n        }\n        eventCache.clear();\n        keyCache.clear();\n        nioChannels.clear();\n        processorCache.clear();\n        shutdownExecutor();\n\n    }"
    ],
    "55995": [
        "    public Compiler createCompiler() {\n        if (jspCompiler != null ) {\n            return jspCompiler;\n        }\n        jspCompiler = null;\n        if (options.getCompilerClassName() != null) {\n            jspCompiler = createCompiler(options.getCompilerClassName());\n        } else {\n            if (options.getCompiler() == null) {\n                jspCompiler = createCompiler(\"org.apache.jasper.compiler.JDTCompiler\");\n                if (jspCompiler == null) {\n                    jspCompiler = createCompiler(\"org.apache.jasper.compiler.AntCompiler\");\n                }\n            } else {\n                jspCompiler = createCompiler(\"org.apache.jasper.compiler.AntCompiler\");\n                if (jspCompiler == null) {\n                    jspCompiler = createCompiler(\"org.apache.jasper.compiler.JDTCompiler\");\n                }\n            }\n        }\n        if (jspCompiler == null) {\n            throw new IllegalStateException(Localizer.getMessage(\"jsp.error.compiler\"));\n        }\n        jspCompiler.init(this, jsw);\n        return jspCompiler;\n    }",
        "    public void compile() throws JasperException, FileNotFoundException {\n        createCompiler();\n        if (jspCompiler.isOutDated()) {\n            if (isRemoved()) {\n                throw new FileNotFoundException(jspUri);\n            }\n            try {\n                jspCompiler.removeGeneratedFiles();\n                jspLoader = null;\n                jspCompiler.compile();\n                jsw.setReload(true);\n                jsw.setCompilationException(null);\n            } catch (JasperException ex) {\n                // Cache compilation exception\n                jsw.setCompilationException(ex);\n                if (options.getDevelopment() && options.getRecompileOnFail()) {\n                    // Force a recompilation attempt on next access\n                    jsw.setLastModificationTest(-1);\n                }\n                throw ex;\n            } catch (FileNotFoundException fnfe) {\n                // Re-throw to let caller handle this - will result in a 404\n                throw fnfe;\n            } catch (Exception ex) {\n                JasperException je = new JasperException(\n                            Localizer.getMessage(\"jsp.error.unable.compile\"),\n                            ex);\n                // Cache compilation exception\n                jsw.setCompilationException(je);\n                throw je;\n            }\n        }\n    }",
        "    protected void createOutputDir() {\n        String path = null;\n        if (isTagFile()) {\n            String tagName = tagInfo.getTagClassName();\n            path = tagName.replace('.', File.separatorChar);\n            path = path.substring(0, path.lastIndexOf(File.separatorChar));\n        } else {\n            path = getServletPackageName().replace('.',File.separatorChar);\n        }\n\n            // Append servlet or tag handler path to scratch dir\n            try {\n                File base = options.getScratchDir();\n                baseUrl = base.toURI().toURL();\n                outputDir = base.getAbsolutePath() + File.separator + path +\n                    File.separator;\n                if (!makeOutputDir()) {\n                    throw new IllegalStateException(Localizer.getMessage(\"jsp.error.outputfolder\"));\n                }\n            } catch (MalformedURLException e) {\n                throw new IllegalStateException(Localizer.getMessage(\"jsp.error.outputfolder\"), e);\n            }\n    }",
        "    public Class<?> loadTagFile() throws JasperException {\n\n        try {\n            if (ctxt.isRemoved()) {\n                throw new FileNotFoundException(jspUri);\n            }\n            if (options.getDevelopment() || firstTime ) {\n                synchronized (this) {\n                    firstTime = false;\n                    ctxt.compile();\n                }\n            } else {\n                if (compileException != null) {\n                    throw compileException;\n                }\n            }\n\n            if (reload) {\n                tagHandlerClass = ctxt.load();\n                reload = false;\n            }\n        } catch (FileNotFoundException ex) {\n            throw new JasperException(ex);\n        }\n\n        return tagHandlerClass;\n    }\n\n    public Class<?> loadTagFilePrototype() throws JasperException {\n\n        ctxt.setPrototypeMode(true);\n        try {\n            return loadTagFile();\n        } finally {\n            ctxt.setPrototypeMode(false);\n        }\n    }",
        "    public void destroy() {\n        if (theServlet != null) {\n            theServlet.destroy();\n            InstanceManager instanceManager = InstanceManagerFactory.getInstanceManager(config);\n            try {\n                instanceManager.destroyInstance(theServlet);\n            } catch (Exception e) {\n                Throwable t = ExceptionUtils.unwrapInvocationTargetException(e);\n                ExceptionUtils.handleThrowable(t);\n                // Log any exception, since it can't be passed along\n                log.error(Localizer.getMessage(\"jsp.error.file.not.found\",\n                        e.getMessage()), t);\n            }\n        }\n    }",
        "    private String initClassPath() {\n\n        StringBuilder cpath = new StringBuilder();\n        String sep = System.getProperty(\"path.separator\");\n\n        if (parentClassLoader instanceof URLClassLoader) {\n            URL [] urls = ((URLClassLoader)parentClassLoader).getURLs();\n    \n            for(int i = 0; i < urls.length; i++) {\n                // Tomcat 4 can use URL's other than file URL's,\n                // a protocol other than file: will generate a\n                // bad file system path, so only add file:\n                // protocol URL's to the classpath.\n                \n                if( urls[i].getProtocol().equals(\"file\") ) {\n                    cpath.append(urls[i].getFile()+sep);\n                }\n            }\n        }\n\n        cpath.append(options.getScratchDir() + sep);\n\n        String cp = (String) context.getAttribute(Constants.SERVLET_CLASSPATH);\n        if (cp == null || cp.equals(\"\")) {\n            cp = options.getClassPath();\n        }\n\n        String path = cpath.toString() + cp;\n\n        if(log.isDebugEnabled()) {\n            log.debug(\"Compilation classpath initialized: \" + path);\n        }\n        return path;\n    }",
        "    private SecurityHolder initSecurity() {\n\n        // Setup the PermissionCollection for this web app context\n        // based on the permissions configured for the root of the\n        // web app context directory, then add a file read permission\n        // for that directory.\n        Policy policy = Policy.getPolicy();\n        CodeSource source = null;\n        PermissionCollection permissions = null;\n        if( policy != null ) {\n            try {          \n                // Get the permissions for the web app context\n                String docBase = context.getRealPath(\"/\");\n                if( docBase == null ) {\n                    docBase = options.getScratchDir().toString();\n                }\n                String codeBase = docBase;\n                if (!codeBase.endsWith(File.separator)){\n                    codeBase = codeBase + File.separator;\n                }\n                File contextDir = new File(codeBase);\n                URL url = contextDir.getCanonicalFile().toURI().toURL();\n                source = new CodeSource(url,(Certificate[])null);\n                permissions = policy.getPermissions(source);\n\n                // Create a file read permission for web app context directory\n                if (!docBase.endsWith(File.separator)){\n                    permissions.add\n                        (new FilePermission(docBase,\"read\"));\n                    docBase = docBase + File.separator;\n                } else {\n                    permissions.add\n                        (new FilePermission\n                            (docBase.substring(0,docBase.length() - 1),\"read\"));\n                }\n                docBase = docBase + \"-\";\n                permissions.add(new FilePermission(docBase,\"read\"));\n\n                // Spec says apps should have read/write for their temp\n                // directory. This is fine, as no security sensitive files, at\n                // least any that the app doesn't have full control of anyway,\n                // will be written here.\n                String workDir = options.getScratchDir().toString();\n                if (!workDir.endsWith(File.separator)){\n                    permissions.add\n                        (new FilePermission(workDir,\"read,write\"));\n                    workDir = workDir + File.separator;\n                }\n                workDir = workDir + \"-\";\n                permissions.add(new FilePermission(\n                        workDir,\"read,write,delete\"));\n\n                // Allow the JSP to access org.apache.jasper.runtime.HttpJspBase\n                permissions.add( new RuntimePermission(\n                    \"accessClassInPackage.org.apache.jasper.runtime\") );\n\n                if (parentClassLoader instanceof URLClassLoader) {\n                    URL [] urls = ((URLClassLoader)parentClassLoader).getURLs();\n                    String jarUrl = null;\n                    String jndiUrl = null;\n                    for (int i=0; i<urls.length; i++) {\n                        if (jndiUrl == null\n                                && urls[i].toString().startsWith(\"jndi:\") ) {\n                            jndiUrl = urls[i].toString() + \"-\";\n                        }\n                        if (jarUrl == null\n                                && urls[i].toString().startsWith(\"jar:jndi:\")\n                                ) {\n                            jarUrl = urls[i].toString();\n                            jarUrl = jarUrl.substring(0,jarUrl.length() - 2);\n                            jarUrl = jarUrl.substring(0,\n                                     jarUrl.lastIndexOf('/')) + \"/-\";\n                        }\n                    }\n                    if (jarUrl != null) {\n                        permissions.add(\n                                new FilePermission(jarUrl,\"read\"));\n                        permissions.add(\n                                new FilePermission(jarUrl.substring(4),\"read\"));\n                    }\n                    if (jndiUrl != null)\n                        permissions.add(\n                                new FilePermission(jndiUrl,\"read\") );\n                }\n            } catch(Exception e) {\n                context.log(\"Security Init for context failed\",e);\n            }\n        }\n        return new SecurityHolder(source, permissions);\n    }",
        "    public void init(ServletConfig config) throws ServletException {\n        \n        super.init(config);\n        this.config = config;\n        this.context = config.getServletContext();\n        \n        // Initialize the JSP Runtime Context\n        // Check for a custom Options implementation\n        String engineOptionsName = \n            config.getInitParameter(\"engineOptionsClass\");\n        if (engineOptionsName != null) {\n            // Instantiate the indicated Options implementation\n            try {\n                ClassLoader loader = Thread.currentThread()\n                        .getContextClassLoader();\n                Class<?> engineOptionsClass =\n                    loader.loadClass(engineOptionsName);\n                Class<?>[] ctorSig =\n                    { ServletConfig.class, ServletContext.class };\n                Constructor<?> ctor =\n                    engineOptionsClass.getConstructor(ctorSig);\n                Object[] args = { config, context };\n                options = (Options) ctor.newInstance(args);\n            } catch (Throwable e) {\n                e = ExceptionUtils.unwrapInvocationTargetException(e);\n                ExceptionUtils.handleThrowable(e);\n                // Need to localize this.\n                log.warn(\"Failed to load engineOptionsClass\", e);\n                // Use the default Options implementation\n                options = new EmbeddedServletOptions(config, context);\n            }\n        } else {\n            // Use the default Options implementation\n            options = new EmbeddedServletOptions(config, context);\n        }\n        rctxt = new JspRuntimeContext(context, options);\n        if (config.getInitParameter(\"jspFile\") != null) {\n            jspFile = config.getInitParameter(\"jspFile\");\n            try {\n                if (null == context.getResource(jspFile)) {\n                    throw new ServletException(\"missing jspFile: [\" + jspFile + \"]\");\n                }\n            } catch (MalformedURLException e) {\n                throw new ServletException(\"Can not locate jsp file\", e);\n            }\n            try {\n                if (SecurityUtil.isPackageProtectionEnabled()){\n                   AccessController.doPrivileged(new PrivilegedExceptionAction<Object>(){\n                        @Override\n                        public Object run() throws IOException, ServletException {\n                            serviceJspFile(null, null, jspFile, true);\n                            return null;\n                        }\n                    });\n                } else {\n                    serviceJspFile(null, null, jspFile, true);\n                }\n            } catch (IOException e) {\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n            } catch (PrivilegedActionException e) {\n                Throwable t = e.getCause();\n                if (t instanceof ServletException) throw (ServletException)t;\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n            }\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(Localizer.getMessage(\"jsp.message.scratch.dir.is\",\n                    options.getScratchDir().toString()));\n            log.debug(Localizer.getMessage(\"jsp.message.dont.modify.servlets\"));\n        }\n    }",
        "    boolean preCompile(HttpServletRequest request) throws ServletException {\n\n        String queryString = request.getQueryString();\n        if (queryString == null) {\n            return (false);\n        }\n        int start = queryString.indexOf(Constants.PRECOMPILE);\n        if (start < 0) {\n            return (false);\n        }\n        queryString =\n            queryString.substring(start + Constants.PRECOMPILE.length());\n        if (queryString.length() == 0) {\n            return (true);             // ?jsp_precompile\n        }\n        if (queryString.startsWith(\"&\")) {\n            return (true);             // ?jsp_precompile&foo=bar...\n        }\n        if (!queryString.startsWith(\"=\")) {\n            return (false);            // part of some other name or value\n        }\n        int limit = queryString.length();\n        int ampersand = queryString.indexOf(\"&\");\n        if (ampersand > 0) {\n            limit = ampersand;\n        }\n        String value = queryString.substring(1, limit);\n        if (value.equals(\"true\")) {\n            return (true);             // ?jsp_precompile=true\n        } else if (value.equals(\"false\")) {\n            // Spec says if jsp_precompile=false, the request should not\n            // be delivered to the JSP page; the easiest way to implement\n            // this is to set the flag to true, and precompile the page anyway.\n            // This still conforms to the spec, since it says the\n            // precompilation request can be ignored.\n            return (true);             // ?jsp_precompile=false\n        } else {\n            throw new ServletException(\"Cannot have request parameter \" +\n                                       Constants.PRECOMPILE + \" set to \" +\n                                       value);\n        }\n\n    }",
        "    public void doTag(TagPluginContext ctxt) {\n        boolean hasContext, hasVar, hasScope, hasVarReader, hasCharEncoding;\n        \n        //flags\n        hasContext  = ctxt.isAttributeSpecified(\"context\");\n        hasVar = ctxt.isAttributeSpecified(\"var\");\n        hasScope = ctxt.isAttributeSpecified(\"scope\");\n        hasVarReader = ctxt.isAttributeSpecified(\"varReader\");\n        hasCharEncoding = ctxt.isAttributeSpecified(\"charEncoding\");\n        \n        //variables' names\n        String urlName = ctxt.getTemporaryVariableName();           \n        String contextName = ctxt.getTemporaryVariableName();       \n        String iauName = ctxt.getTemporaryVariableName();           // is absolute url\n        String urlObjName = ctxt.getTemporaryVariableName();        //URL object\n        String ucName = ctxt.getTemporaryVariableName();            //URLConnection\n        String inputStreamName = ctxt.getTemporaryVariableName();   \n        String tempReaderName = ctxt.getTemporaryVariableName();\n        String tempReaderName2 = ctxt.getTemporaryVariableName();\n        String charSetName = ctxt.getTemporaryVariableName();\n        String charEncodingName = ctxt.getTemporaryVariableName();\n        String contentTypeName = ctxt.getTemporaryVariableName();\n        String varReaderName = ctxt.getTemporaryVariableName();\n        String servletContextName = ctxt.getTemporaryVariableName();\n        String servletPathName = ctxt.getTemporaryVariableName();\n        String requestDispatcherName = ctxt.getTemporaryVariableName();\n        String irwName = ctxt.getTemporaryVariableName();           //ImportResponseWrapper name\n        String brName = ctxt.getTemporaryVariableName();            //BufferedReader name\n        String sbName = ctxt.getTemporaryVariableName();            //StringBuilder name\n        String tempStringName = ctxt.getTemporaryVariableName();\n        \n        //is absolute url\n        ctxt.generateJavaSource(\"boolean \" + iauName + \";\");\n        \n        //get the url value\n        ctxt.generateJavaSource(\"String \" + urlName + \" = \");\n        ctxt.generateAttribute(\"url\");\n        ctxt.generateJavaSource(\";\");\n        \n        //validate the url\n        ctxt.generateJavaSource(\"if(\" + urlName + \" == null || \" + urlName + \".equals(\\\"\\\")){\");\n        ctxt.generateJavaSource(\"    throw new JspTagException(\\\"The \\\\\\\"url\\\\\\\" attribute \" +\n        \"illegally evaluated to \\\\\\\"null\\\\\\\" or \\\\\\\"\\\\\\\" in &lt;import&gt;\\\");\");\n        ctxt.generateJavaSource(\"}\");\n        \n        //initialize the is_absolute_url\n        ctxt.generateJavaSource(iauName + \" = \" +\n                \"org.apache.jasper.tagplugins.jstl.Util.isAbsoluteUrl(\" + urlName + \");\");\n        \n        //validate the context\n        if(hasContext){\n            \n            ctxt.generateJavaSource(\"String \" + contextName + \" = \");\n            ctxt.generateAttribute(\"context\");\n            ctxt.generateJavaSource(\";\");\n            \n            ctxt.generateJavaSource(\"if((!\" + contextName + \".startsWith(\\\"/\\\")) \" +\n                    \"|| (!\" + urlName + \".startsWith(\\\"/\\\"))){\");\n            ctxt.generateJavaSource(\"    throw new JspTagException\" +\n                    \"(\\\"In URL tags, when the \\\\\\\"context\\\\\\\" attribute is specified, \" +\n            \"values of both \\\\\\\"context\\\\\\\" and \\\\\\\"url\\\\\\\" must start with \\\\\\\"/\\\\\\\".\\\");\");\n            ctxt.generateJavaSource(\"}\");\n            \n        }\n        \n        //define charset\n        ctxt.generateJavaSource(\"String \" + charSetName + \" = null;\");\n        \n        //if the charEncoding attribute is specified\n        if(hasCharEncoding){\n            \n            //initialize the charEncoding\n            ctxt.generateJavaSource(\"String \" + charEncodingName + \" = \");\n            ctxt.generateAttribute(\"charEncoding\");\n            ctxt.generateJavaSource(\";\");\n            \n            //assign appropriate value to the charset\n            ctxt.generateJavaSource(\"if(null != \" + charEncodingName + \" \" +\n                    \"&& !\" + charEncodingName + \".equals(\\\"\\\")){\");\n            ctxt.generateJavaSource(\"    \" + charSetName + \" = \" \n                    + charEncodingName + \";\");\n            ctxt.generateJavaSource(\"}\");\n        }\n        \n        //reshape the url string\n        ctxt.generateJavaSource(\"if(!\"+iauName+\"){\");\n        ctxt.generateJavaSource(\"    if(!\" + urlName + \".startsWith(\\\"/\\\")){\");\n        ctxt.generateJavaSource(\"        String \" + servletPathName + \" = \" +\n        \"((HttpServletRequest)pageContext.getRequest()).getServletPath();\");\n        ctxt.generateJavaSource(\"        \" + urlName + \" = \" \n                + servletPathName + \".substring(0,\" + servletPathName + \".lastIndexOf('/')) + '/' + \" + urlName + \";\");\n        ctxt.generateJavaSource(\"    }\");\n        ctxt.generateJavaSource(\"}\");\n        \n        //if the varReader attribute specified\n        if(hasVarReader){\n            \n            //get the String value of varReader\n            ctxt.generateJavaSource(\"String \" + varReaderName + \" = \");\n            ctxt.generateAttribute(\"varReader\");\n            ctxt.generateJavaSource(\";\");\n            \n            //if the url is absolute url\n            ctxt.generateJavaSource(\"if(\" + iauName + \"){\");\n            \n            //get the content of the target\n            ctxt.generateJavaSource(\"    java.net.URL \" + urlObjName + \" = new java.net.URL(\" + urlName + \");\");\n            ctxt.generateJavaSource(\"    java.net.URLConnection \" + ucName + \" = \" \n                    + urlObjName + \".openConnection();\");\n            ctxt.generateJavaSource(\"    java.io.InputStream \" + inputStreamName + \" = \" \n                    + ucName + \".getInputStream();\");\n            \n            ctxt.generateJavaSource(\"    if(\" + charSetName + \" == null){\");\n            ctxt.generateJavaSource(\"        String \" + contentTypeName + \" = \" \n                    + ucName + \".getContentType();\");\n            ctxt.generateJavaSource(\"        if(null != \" + contentTypeName + \"){\");\n            ctxt.generateJavaSource(\"            \" + charSetName + \" = \" +\n                    \"org.apache.jasper.tagplugins.jstl.Util.getContentTypeAttribute(\" + contentTypeName + \", \\\"charset\\\");\");\n            ctxt.generateJavaSource(\"            if(\" + charSetName + \" == null) \" \n                    + charSetName + \" = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;\");\n            ctxt.generateJavaSource(\"        }else{\");\n            ctxt.generateJavaSource(\"            \" + charSetName + \" = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;\");\n            ctxt.generateJavaSource(\"        }\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            if(!hasCharEncoding){\n                ctxt.generateJavaSource(\"    String \" + contentTypeName + \" = \" + ucName + \".getContentType();\");\n            }\n            \n            //define the Reader\n            ctxt.generateJavaSource(\"    java.io.Reader \" + tempReaderName + \" = null;\");\n            \n            //initialize the Reader object\n            ctxt.generateJavaSource(\"    try{\");\n            ctxt.generateJavaSource(\"        \" + tempReaderName + \" = new java.io.InputStreamReader(\" + inputStreamName + \", \" + charSetName + \");\");\n            ctxt.generateJavaSource(\"    }catch(Exception ex){\");\n            ctxt.generateJavaSource(\"        \" + tempReaderName + \" = new java.io.InputStreamReader(\" + inputStreamName + \", org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING);\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            //validate the response\n            ctxt.generateJavaSource(\"    if(\" + ucName + \" instanceof java.net.HttpURLConnection){\");\n            ctxt.generateJavaSource(\"        int status = ((java.net.HttpURLConnection) \" + ucName + \").getResponseCode();\");\n            ctxt.generateJavaSource(\"        if(status < 200 || status > 299){\");\n            ctxt.generateJavaSource(\"            throw new JspTagException(status + \\\" \\\" + \" + urlName + \");\");\n            ctxt.generateJavaSource(\"        }\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            //set attribute in the page context scope\n            ctxt.generateJavaSource(\"    pageContext.setAttribute(\" + varReaderName + \", \" + tempReaderName + \");\");\n            \n            //if the url is relative\n            ctxt.generateJavaSource(\"}else{\");\n            \n            //if the url is relative, http request is needed\n            ctxt.generateJavaSource(\"    if (!(pageContext.getRequest() instanceof HttpServletRequest  \" +\n            \"&& pageContext.getResponse() instanceof HttpServletResponse)){\");\n            ctxt.generateJavaSource(\"        throw new JspTagException(\\\"Relative &lt;import&gt; from non-HTTP request not allowed\\\");\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            //get the servlet context of the context defined in the context attribute\n            ctxt.generateJavaSource(\"    ServletContext \" + servletContextName + \" = null;\");\n            if(hasContext){\n                ctxt.generateJavaSource(\"    if(null != \" + contextName + \"){\");\n                ctxt.generateJavaSource(\"        \" + servletContextName + \" = pageContext.getServletContext().getContext(\" + contextName + \");\" );\n                ctxt.generateJavaSource(\"    }else{\");\n                ctxt.generateJavaSource(\"        \" + servletContextName + \" = pageContext.getServletContext();\");\n                ctxt.generateJavaSource(\"    }\");\n            }else{\n                ctxt.generateJavaSource(\"    \" + servletContextName + \" = pageContext.getServletContext();\");\n            }\n            \n            //\n            ctxt.generateJavaSource(\"    if(\" + servletContextName + \" == null){\");\n            if(hasContext){\n                ctxt.generateJavaSource(\"        throw new JspTagException(\\\"Unable to get RequestDispatcher for Context: \\\\\\\" \\\"+\" + contextName + \"+\\\" \\\\\\\" and URL: \\\\\\\" \\\" +\" + urlName + \"+ \\\" \\\\\\\". Verify values and/or enable cross context access.\\\");\");\n            }else{\n                ctxt.generateJavaSource(\"        throw new JspTagException(\\\"Unable to get RequestDispatcher for  URL: \\\\\\\" \\\" +\" + urlName + \"+ \\\" \\\\\\\". Verify values and/or enable cross context access.\\\");\");\n            }\n            ctxt.generateJavaSource(\"    }\");\n            \n            //get the request dispatcher\n            ctxt.generateJavaSource(\"    RequestDispatcher \" + requestDispatcherName + \" = \" + servletContextName + \".getRequestDispatcher(org.apache.jasper.tagplugins.jstl.Util.stripSession(\"+urlName+\"));\");\n            ctxt.generateJavaSource(\"    if(\" + requestDispatcherName + \" == null) throw new JspTagException(org.apache.jasper.tagplugins.jstl.Util.stripSession(\"+urlName+\"));\");\n            \n            //initialize a ImportResponseWrapper to include the resource\n            ctxt.generateJavaSource(\"    org.apache.jasper.tagplugins.jstl.Util.ImportResponseWrapper \" + irwName + \" = new org.apache.jasper.tagplugins.jstl.Util.ImportResponseWrapper((HttpServletResponse) pageContext.getResponse());\");\n            ctxt.generateJavaSource(\"    if(\" + charSetName + \" == null){\");\n            ctxt.generateJavaSource(\"        \" + charSetName + \" = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;\");\n            ctxt.generateJavaSource(\"    }\");\n            ctxt.generateJavaSource(\"    \" + irwName + \".setCharEncoding(\" + charSetName + \");\");\n            ctxt.generateJavaSource(\"    try{\");\n            ctxt.generateJavaSource(\"        \" + requestDispatcherName + \".include(pageContext.getRequest(), \" + irwName + \");\");\n            ctxt.generateJavaSource(\"    }catch(java.io.IOException ex){\");\n            ctxt.generateJavaSource(\"        throw new JspException(ex);\");\n            ctxt.generateJavaSource(\"    }catch(RuntimeException ex){\");\n            ctxt.generateJavaSource(\"        throw new JspException(ex);\");\n            ctxt.generateJavaSource(\"    }catch(ServletException ex){\");\n            ctxt.generateJavaSource(\"        Throwable rc = ex.getRootCause();\");\n            ctxt.generateJavaSource(\"        if (rc == null)\");\n            ctxt.generateJavaSource(\"            throw new JspException(ex);\");\n            ctxt.generateJavaSource(\"        else\");\n            ctxt.generateJavaSource(\"            throw new JspException(rc);\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            //validate the response status\n            ctxt.generateJavaSource(\"    if(\" + irwName + \".getStatus() < 200 || \" + irwName + \".getStatus() > 299){\");\n            ctxt.generateJavaSource(\"        throw new JspTagException(\" + irwName + \".getStatus()+\\\" \\\" + org.apache.jasper.tagplugins.jstl.Util.stripSession(\" + urlName + \"));\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            //push in the page context\n            ctxt.generateJavaSource(\"    java.io.Reader \" + tempReaderName + \" = new java.io.StringReader(\" + irwName + \".getString());\");\n            ctxt.generateJavaSource(\"    pageContext.setAttribute(\" + varReaderName + \", \" + tempReaderName + \");\");\n            \n            ctxt.generateJavaSource(\"}\");\n            \n            //execute the body action\n            ctxt.generateBody();\n            \n            //close the reader\n            ctxt.generateJavaSource(\"java.io.Reader \" + tempReaderName2 + \" = (java.io.Reader)pageContext.getAttribute(\" + varReaderName + \");\");\n            ctxt.generateJavaSource(\"if(\" + tempReaderName2 + \" != null) \" + tempReaderName2 + \".close();\");\n            ctxt.generateJavaSource(\"pageContext.removeAttribute(\" + varReaderName + \",1);\");\n        }\n        \n        //if the varReader is not specified \n        else{\n            \n            ctxt.generateJavaSource(\"pageContext.setAttribute(\\\"url_without_param\\\",\" + urlName + \");\");\n            ctxt.generateBody();\n            ctxt.generateJavaSource(urlName + \" = (String)pageContext.getAttribute(\\\"url_without_param\\\");\");\n            ctxt.generateJavaSource(\"pageContext.removeAttribute(\\\"url_without_param\\\");\");\n            String strScope = \"page\";\n            if(hasScope){\n                strScope = ctxt.getConstantAttribute(\"scope\");\n            }\n            int iScope = Util.getScope(strScope);\n            \n            ctxt.generateJavaSource(\"String \" + tempStringName + \" = null;\");\n            \n            ctxt.generateJavaSource(\"if(\" + iauName + \"){\");\n            \n            //get the content of the target\n            ctxt.generateJavaSource(\"    java.net.URL \" + urlObjName + \" = new java.net.URL(\" + urlName + \");\");\n            ctxt.generateJavaSource(\"    java.net.URLConnection \" + ucName + \" = \" + urlObjName + \".openConnection();\");\n            ctxt.generateJavaSource(\"    java.io.InputStream \" + inputStreamName + \" = \" + ucName + \".getInputStream();\");\n            ctxt.generateJavaSource(\"    java.io.Reader \" + tempReaderName + \" = null;\");\n            \n            ctxt.generateJavaSource(\"    if(\" + charSetName + \" == null){\");\n            ctxt.generateJavaSource(\"        String \" + contentTypeName + \" = \" \n                    + ucName + \".getContentType();\");\n            ctxt.generateJavaSource(\"        if(null != \" + contentTypeName + \"){\");\n            ctxt.generateJavaSource(\"            \" + charSetName + \" = \" +\n                    \"org.apache.jasper.tagplugins.jstl.Util.getContentTypeAttribute(\" + contentTypeName + \", \\\"charset\\\");\");\n            ctxt.generateJavaSource(\"            if(\" + charSetName + \" == null) \" \n                    + charSetName + \" = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;\");\n            ctxt.generateJavaSource(\"        }else{\");\n            ctxt.generateJavaSource(\"            \" + charSetName + \" = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;\");\n            ctxt.generateJavaSource(\"        }\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            ctxt.generateJavaSource(\"    try{\");\n            ctxt.generateJavaSource(\"        \" + tempReaderName + \" = new java.io.InputStreamReader(\" + inputStreamName + \",\" + charSetName + \");\");\n            ctxt.generateJavaSource(\"    }catch(Exception ex){\");\n            //ctxt.generateJavaSource(\"        throw new JspTagException(ex.toString());\");\n            ctxt.generateJavaSource(\"        \" + tempReaderName + \" = new java.io.InputStreamReader(\" + inputStreamName + \",org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING);\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            //validate the response\n            ctxt.generateJavaSource(\"    if(\" + ucName + \" instanceof java.net.HttpURLConnection){\");\n            ctxt.generateJavaSource(\"        int status = ((java.net.HttpURLConnection) \" + ucName + \").getResponseCode();\");\n            ctxt.generateJavaSource(\"        if(status < 200 || status > 299){\");\n            ctxt.generateJavaSource(\"            throw new JspTagException(status + \\\" \\\" + \" + urlName + \");\");\n            ctxt.generateJavaSource(\"        }\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            ctxt.generateJavaSource(\"    java.io.BufferedReader \" + brName + \" =  new java.io.BufferedReader(\" + tempReaderName + \");\");\n            ctxt.generateJavaSource(\"    StringBuilder \" + sbName + \" = new StringBuilder();\");\n            String index = ctxt.getTemporaryVariableName();\n            ctxt.generateJavaSource(\"    int \" + index + \";\");\n            ctxt.generateJavaSource(\"    while((\"+index+\" = \"+brName+\".read()) != -1) \"+sbName+\".append((char)\"+index+\");\");\n            ctxt.generateJavaSource(\"    \" + tempStringName + \" = \" +sbName + \".toString();\");\n            \n            ctxt.generateJavaSource(\"}else{\");\n            \n            //if the url is relative, http request is needed.\n            ctxt.generateJavaSource(\"    if (!(pageContext.getRequest() instanceof HttpServletRequest  \" +\n            \"&& pageContext.getResponse() instanceof HttpServletResponse)){\");\n            ctxt.generateJavaSource(\"        throw new JspTagException(\\\"Relative &lt;import&gt; from non-HTTP request not allowed\\\");\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            //get the servlet context of the context defined in the context attribute\n            ctxt.generateJavaSource(\"    ServletContext \" + servletContextName + \" = null;\");\n            if(hasContext){\n                ctxt.generateJavaSource(\"    if(null != \" + contextName + \"){\");\n                ctxt.generateJavaSource(\"        \" + servletContextName + \" = pageContext.getServletContext().getContext(\" + contextName + \");\" );\n                ctxt.generateJavaSource(\"    }else{\");\n                ctxt.generateJavaSource(\"        \" + servletContextName + \" = pageContext.getServletContext();\");\n                ctxt.generateJavaSource(\"    }\");\n            }else{\n                ctxt.generateJavaSource(\"    \" + servletContextName + \" = pageContext.getServletContext();\");\n            }\n            \n            //\n            ctxt.generateJavaSource(\"    if(\" + servletContextName + \" == null){\");\n            if(hasContext){\n                ctxt.generateJavaSource(\"        throw new JspTagException(\\\"Unable to get RequestDispatcher for Context: \\\\\\\" \\\" +\" + contextName + \"+ \\\" \\\\\\\" and URL: \\\\\\\" \\\" +\" + urlName + \"+ \\\" \\\\\\\". Verify values and/or enable cross context access.\\\");\");\n            }else{\n                ctxt.generateJavaSource(\"        throw new JspTagException(\\\"Unable to get RequestDispatcher for URL: \\\\\\\" \\\" +\" + urlName + \"+ \\\" \\\\\\\". Verify values and/or enable cross context access.\\\");\");\n            }\n            ctxt.generateJavaSource(\"    }\");\n            \n            //get the request dispatcher\n            ctxt.generateJavaSource(\"    RequestDispatcher \" + requestDispatcherName + \" = \" + servletContextName + \".getRequestDispatcher(org.apache.jasper.tagplugins.jstl.Util.stripSession(\"+urlName+\"));\");\n            ctxt.generateJavaSource(\"    if(\" + requestDispatcherName + \" == null) throw new JspTagException(org.apache.jasper.tagplugins.jstl.Util.stripSession(\"+urlName+\"));\");\n            \n            //initialize a ImportResponseWrapper to include the resource\n            ctxt.generateJavaSource(\"    org.apache.jasper.tagplugins.jstl.Util.ImportResponseWrapper \" + irwName + \" = new org.apache.jasper.tagplugins.jstl.Util.ImportResponseWrapper((HttpServletResponse) pageContext.getResponse());\");\n            ctxt.generateJavaSource(\"    if(\" + charSetName + \" == null){\");\n            ctxt.generateJavaSource(\"        \" + charSetName + \" = org.apache.jasper.tagplugins.jstl.Util.DEFAULT_ENCODING;\");\n            ctxt.generateJavaSource(\"    }\");\n            ctxt.generateJavaSource(\"    \" + irwName + \".setCharEncoding(\" + charSetName + \");\");\n            ctxt.generateJavaSource(\"    try{\");\n            ctxt.generateJavaSource(\"        \" + requestDispatcherName + \".include(pageContext.getRequest(), \" + irwName + \");\");\n            ctxt.generateJavaSource(\"    }catch(java.io.IOException ex){\");\n            ctxt.generateJavaSource(\"        throw new JspException(ex);\");\n            ctxt.generateJavaSource(\"    }catch(RuntimeException ex){\");\n            ctxt.generateJavaSource(\"        throw new JspException(ex);\");\n            ctxt.generateJavaSource(\"    }catch(ServletException ex){\");\n            ctxt.generateJavaSource(\"        Throwable rc = ex.getRootCause();\");\n            ctxt.generateJavaSource(\"        if (rc == null)\");\n            ctxt.generateJavaSource(\"            throw new JspException(ex);\");\n            ctxt.generateJavaSource(\"        else\");\n            ctxt.generateJavaSource(\"            throw new JspException(rc);\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            //validate the response status\n            ctxt.generateJavaSource(\"    if(\" + irwName + \".getStatus() < 200 || \" + irwName + \".getStatus() > 299){\");\n            ctxt.generateJavaSource(\"        throw new JspTagException(\" + irwName + \".getStatus()+\\\" \\\" + org.apache.jasper.tagplugins.jstl.Util.stripSession(\" + urlName + \"));\");\n            ctxt.generateJavaSource(\"    }\");\n            \n            ctxt.generateJavaSource(\"    \" + tempStringName + \" = \" + irwName + \".getString();\");\n            \n            ctxt.generateJavaSource(\"}\");\n            \n            if(hasVar){\n                String strVar = ctxt.getConstantAttribute(\"var\");\n                ctxt.generateJavaSource(\"pageContext.setAttribute(\\\"\"+strVar+\"\\\",\" + tempStringName + \",\" + iScope + \");\");\n            }else{\n                ctxt.generateJavaSource(\"pageContext.getOut().print(\" + tempStringName + \");\");\n            }\n        }\n    }",
        "    protected void mergeIntoWebXml() throws IOException {\n\n        File webappBase = new File(uriRoot);\n        File webXml = new File(webappBase, \"WEB-INF/web.xml\");\n        File webXml2 = new File(webappBase, \"WEB-INF/web2.xml\");\n        String insertStartMarker =\n            Localizer.getMessage(\"jspc.webinc.insertStart\");\n        String insertEndMarker =\n            Localizer.getMessage(\"jspc.webinc.insertEnd\");\n\n        BufferedReader reader = new BufferedReader(openWebxmlReader(webXml));\n        BufferedReader fragmentReader = new BufferedReader(\n                openWebxmlReader(new File(webxmlFile)));\n        PrintWriter writer = new PrintWriter(openWebxmlWriter(webXml2));\n\n        // Insert the <servlet> and <servlet-mapping> declarations\n        boolean inserted = false;\n        int current = reader.read();\n        while (current > -1) {\n            if (current == '<') {\n                String element = getElement(reader);\n                if (!inserted && insertBefore.contains(element)) {\n                    // Insert generated content here\n                    writer.println(insertStartMarker);\n                    while (true) {\n                        String line = fragmentReader.readLine();\n                        if (line == null) {\n                            writer.println();\n                            break;\n                        }\n                        writer.println(line);\n                    }\n                    writer.println(insertEndMarker);\n                    writer.println();\n                    writer.write(element);\n                    inserted = true;\n                } else if (element.equals(insertStartMarker)) {\n                    // Skip the previous auto-generated content\n                    while (true) {\n                        current = reader.read();\n                        if (current < 0) {\n                            throw new EOFException();\n                        }\n                        if (current == '<') {\n                            element = getElement(reader);\n                            if (element.equals(insertEndMarker)) {\n                                break;\n                            }\n                        }\n                    }\n                    current = reader.read();\n                    while (current == '\\n' || current == '\\r') {\n                        current = reader.read();\n                    }\n                    continue;\n                } else {\n                    writer.write(element);\n                }\n            } else {\n                writer.write(current);\n            }\n            current = reader.read();\n        }\n        writer.close();\n\n        reader.close();\n        fragmentReader.close();\n\n        FileInputStream fis = new FileInputStream(webXml2);\n        FileOutputStream fos = new FileOutputStream(webXml);\n\n        byte buf[] = new byte[512];\n        while (true) {\n            int n = fis.read(buf);\n            if (n < 0) {\n                break;\n            }\n            fos.write(buf, 0, n);\n        }\n\n        fis.close();\n        fos.close();\n\n        if(!webXml2.delete() && log.isDebugEnabled())\n            log.debug(Localizer.getMessage(\"jspc.delete.fail\",\n                    webXml2.toString()));\n        \n        if (!(new File(webxmlFile)).delete() && log.isDebugEnabled())\n            log.debug(Localizer.getMessage(\"jspc.delete.fail\", webxmlFile));\n\n    }",
        "    public void scanFiles( File base ) throws JasperException {\n        Stack<String> dirs = new Stack<String>();\n        dirs.push(base.toString());\n\n        // Make sure default extensions are always included\n        if ((getExtensions() == null) || (getExtensions().size() < 2)) {\n            addExtension(\"jsp\");\n            addExtension(\"jspx\");\n        }\n\n        while (!dirs.isEmpty()) {\n            String s = dirs.pop();\n            File f = new File(s);\n            if (f.exists() && f.isDirectory()) {\n                String[] files = f.list();\n                String ext;\n                for (int i = 0; (files != null) && i < files.length; i++) {\n                    File f2 = new File(s, files[i]);\n                    if (f2.isDirectory()) {\n                        dirs.push(f2.getPath());\n                    } else {\n                        String path = f2.getPath();\n                        String uri = path.substring(uriRoot.length());\n                        ext = files[i].substring(files[i].lastIndexOf('.') +1);\n                        if (getExtensions().contains(ext) ||\n                            jspConfig.isJspPage(uri)) {\n                            pages.add(path);\n                        }\n                    }\n                }\n            }\n        }\n    }",
        "    protected String nextArg() {\n        if ((argPos >= args.length)\n            || (fullstop = SWITCH_FULL_STOP.equals(args[argPos]))) {\n            return null;\n        } else {\n            return args[argPos++];\n        }\n    }\n\n    protected String nextFile() {\n        if (fullstop) argPos++;\n        if (argPos >= args.length) {\n            return null;\n        } else {\n            return args[argPos++];\n        }\n    }\n\n    protected void initWebXml() {\n        try {\n            if (webxmlLevel >= INC_WEBXML) {\n                mapout = openWebxmlWriter(new File(webxmlFile));\n                servletout = new CharArrayWriter();\n                mappingout = new CharArrayWriter();\n            } else {\n                mapout = null;\n                servletout = null;\n                mappingout = null;\n            }\n            if (webxmlLevel >= ALL_WEBXML) {\n                mapout.write(Localizer.getMessage(\"jspc.webxml.header\"));\n                mapout.flush();\n            } else if ((webxmlLevel>= INC_WEBXML) && !addWebXmlMappings) {\n                mapout.write(Localizer.getMessage(\"jspc.webinc.header\"));\n                mapout.flush();\n            }\n        } catch (IOException ioe) {\n            mapout = null;\n            servletout = null;\n            mappingout = null;\n        }\n    }",
        "    protected void completeWebXml() {\n        if (mapout != null) {\n            try {\n                servletout.writeTo(mapout);\n                mappingout.writeTo(mapout);\n                if (webxmlLevel >= ALL_WEBXML) {\n                    mapout.write(Localizer.getMessage(\"jspc.webxml.footer\"));\n                } else if ((webxmlLevel >= INC_WEBXML) && !addWebXmlMappings) {\n                    mapout.write(Localizer.getMessage(\"jspc.webinc.footer\"));\n                }\n                mapout.close();\n            } catch (IOException ioe) {\n                // noting to do if it fails since we are done with it\n            }\n        }\n    }\n\n    protected void initServletContext() {\n        try {\n            context =new JspCServletContext\n                (new PrintWriter(System.out),\n                 new URL(\"file:\" + uriRoot.replace('\\\\','/') + '/'));\n            tldLocationsCache = TldLocationsCache.getInstance(context);\n        } catch (MalformedURLException me) {\n            System.out.println(\"**\" + me);\n        }\n        if (isValidateTld()) {\n            context.setInitParameter(Constants.XML_VALIDATION_TLD_INIT_PARAM, \"true\");\n        }\n        context.setInitParameter(Constants.XML_BLOCK_EXTERNAL_INIT_PARAM,\n                String.valueOf(isBlockExternal()));\n\n        rctxt = new JspRuntimeContext(context, this);\n        jspConfig = new JspConfig(context);\n        tagPluginManager = new TagPluginManager(context);\n    }",
        "    protected void locateUriRoot( File f ) {\n        String tUriBase = uriBase;\n        if (tUriBase == null) {\n            tUriBase = \"/\";\n        }\n        try {\n            if (f.exists()) {\n                f = new File(f.getAbsolutePath());\n                while (true) {\n                    File g = new File(f, \"WEB-INF\");\n                    if (g.exists() && g.isDirectory()) {\n                        uriRoot = f.getCanonicalPath();\n                        uriBase = tUriBase;\n                        if (log.isInfoEnabled()) {\n                            log.info(Localizer.getMessage(\n                                        \"jspc.implicit.uriRoot\",\n                                        uriRoot));\n                        }\n                        break;\n                    }\n                    if (f.exists() && f.isDirectory()) {\n                        tUriBase = \"/\" + f.getName() + \"/\" + tUriBase;\n                    }\n\n                    String fParent = f.getParent();\n                    if (fParent == null) {\n                        break;\n                    } else {\n                        f = new File(fParent);\n                    }\n\n                    // If there is no acceptable candidate, uriRoot will\n                    // remain null to indicate to the CompilerContext to\n                    // use the current working/user dir.\n                }\n\n                if (uriRoot != null) {\n                    File froot = new File(uriRoot);\n                    uriRoot = froot.getCanonicalPath();\n                }\n            }\n        } catch (IOException ioe) {\n            // since this is an optional default and a null value\n            // for uriRoot has a non-error meaning, we can just\n            // pass straight through\n        }\n    }",
        "     protected File resolveFile(final String s) {\n         if(getProject() == null) {\n             // Note FileUtils.getFileUtils replaces FileUtils.newFileUtils in Ant 1.6.3\n             return FileUtils.getFileUtils().resolveFile(null, s);\n         } else {\n             return FileUtils.getFileUtils().resolveFile(getProject().getBaseDir(), s);\n         }\n     }\n\n    private Reader openWebxmlReader(File file) throws IOException {\n        FileInputStream fis = new FileInputStream(file);\n        try {\n            return webxmlEncoding != null ? new InputStreamReader(fis,\n                    webxmlEncoding) : new InputStreamReader(fis);\n        } catch (IOException ex) {\n            fis.close();\n            throw ex;\n        }\n    }\n\n    private Writer openWebxmlWriter(File file) throws IOException {\n        FileOutputStream fos = new FileOutputStream(file);\n        try {\n            return webxmlEncoding != null ? new OutputStreamWriter(fos,\n                    webxmlEncoding) : new OutputStreamWriter(fos);\n        } catch (IOException ex) {\n            fos.close();\n            throw ex;\n        }\n    }",
        "    public void log(Exception exception, String message) {\n\n        log(message, exception);\n\n    }\n\n    public void log(String message, Throwable exception) {\n\n        myLogWriter.println(message);\n        exception.printStackTrace(myLogWriter);\n\n    }",
        "    protected String[] generateJava() throws Exception {\n\n        String[] smapStr = null;\n\n        long t1, t2, t3, t4;\n\n        t1 = t2 = t3 = t4 = 0;\n\n        if (log.isDebugEnabled()) {\n            t1 = System.currentTimeMillis();\n        }\n\n        // Setup page info area\n        pageInfo = new PageInfo(new BeanRepository(ctxt.getClassLoader(),\n                errDispatcher), ctxt.getJspFile(), ctxt.isTagFile());\n\n        JspConfig jspConfig = options.getJspConfig();\n        JspConfig.JspProperty jspProperty = jspConfig.findJspProperty(ctxt\n                .getJspFile());\n\n        /*\n         * If the current uri is matched by a pattern specified in a\n         * jsp-property-group in web.xml, initialize pageInfo with those\n         * properties.\n         */\n        if (jspProperty.isELIgnored() != null) {\n            pageInfo.setELIgnored(JspUtil.booleanValue(jspProperty\n                    .isELIgnored()));\n        }\n        if (jspProperty.isScriptingInvalid() != null) {\n            pageInfo.setScriptingInvalid(JspUtil.booleanValue(jspProperty\n                    .isScriptingInvalid()));\n        }\n        if (jspProperty.getIncludePrelude() != null) {\n            pageInfo.setIncludePrelude(jspProperty.getIncludePrelude());\n        }\n        if (jspProperty.getIncludeCoda() != null) {\n            pageInfo.setIncludeCoda(jspProperty.getIncludeCoda());\n        }\n        if (jspProperty.isDeferedSyntaxAllowedAsLiteral() != null) {\n            pageInfo.setDeferredSyntaxAllowedAsLiteral(JspUtil.booleanValue(jspProperty\n                    .isDeferedSyntaxAllowedAsLiteral()));\n        }\n        if (jspProperty.isTrimDirectiveWhitespaces() != null) {\n            pageInfo.setTrimDirectiveWhitespaces(JspUtil.booleanValue(jspProperty\n                    .isTrimDirectiveWhitespaces()));\n        }\n        // Default ContentType processing is deferred until after the page has\n        // been parsed\n        if (jspProperty.getBuffer() != null) {\n            pageInfo.setBufferValue(jspProperty.getBuffer(), null,\n                    errDispatcher);\n        }\n        if (jspProperty.isErrorOnUndeclaredNamespace() != null) {\n            pageInfo.setErrorOnUndeclaredNamespace(\n                    JspUtil.booleanValue(\n                            jspProperty.isErrorOnUndeclaredNamespace()));\n        }\n        if (ctxt.isTagFile()) {\n            try {\n                double libraryVersion = Double.parseDouble(ctxt.getTagInfo()\n                        .getTagLibrary().getRequiredVersion());\n                if (libraryVersion < 2.0) {\n                    pageInfo.setIsELIgnored(\"true\", null, errDispatcher, true);\n                }\n                if (libraryVersion < 2.1) {\n                    pageInfo.setDeferredSyntaxAllowedAsLiteral(\"true\", null,\n                            errDispatcher, true);\n                }\n            } catch (NumberFormatException ex) {\n                errDispatcher.jspError(ex);\n            }\n        }\n\n        ctxt.checkOutputDir();\n        String javaFileName = ctxt.getServletJavaFileName();\n\n        ServletWriter writer = null;\n        try {\n            /*\n             * The setting of isELIgnored changes the behaviour of the parser\n             * in subtle ways. To add to the 'fun', isELIgnored can be set in\n             * any file that forms part of the translation unit so setting it\n             * in a file included towards the end of the translation unit can\n             * change how the parser should have behaved when parsing content\n             * up to the point where isELIgnored was set. Arghh!\n             * Previous attempts to hack around this have only provided partial\n             * solutions. We now use two passes to parse the translation unit.\n             * The first just parses the directives and the second parses the\n             * whole translation unit once we know how isELIgnored has been set.\n             * TODO There are some possible optimisations of this process.  \n             */ \n            // Parse the file\n            ParserController parserCtl = new ParserController(ctxt, this);\n            \n            // Pass 1 - the directives\n            Node.Nodes directives =\n                parserCtl.parseDirectives(ctxt.getJspFile());\n            Validator.validateDirectives(this, directives);\n            \n            // Pass 2 - the whole translation unit\n            pageNodes = parserCtl.parse(ctxt.getJspFile());\n\n            // Leave this until now since it can only be set once - bug 49726\n            if (pageInfo.getContentType() == null &&\n                    jspProperty.getDefaultContentType() != null) {\n                pageInfo.setContentType(jspProperty.getDefaultContentType());\n            }\n\n            if (ctxt.isPrototypeMode()) {\n                // generate prototype .java file for the tag file\n                writer = setupContextWriter(javaFileName);\n                Generator.generate(writer, this, pageNodes);\n                writer.close();\n                writer = null;\n                return null;\n            }\n\n            // Validate and process attributes - don't re-validate the\n            // directives we validated in pass 1\n            Validator.validateExDirectives(this, pageNodes);\n\n            if (log.isDebugEnabled()) {\n                t2 = System.currentTimeMillis();\n            }\n\n            // Collect page info\n            Collector.collect(this, pageNodes);\n\n            // Compile (if necessary) and load the tag files referenced in\n            // this compilation unit.\n            tfp = new TagFileProcessor();\n            tfp.loadTagFiles(this, pageNodes);\n\n            if (log.isDebugEnabled()) {\n                t3 = System.currentTimeMillis();\n            }\n\n            // Determine which custom tag needs to declare which scripting vars\n            ScriptingVariabler.set(pageNodes, errDispatcher);\n\n            // Optimizations by Tag Plugins\n            TagPluginManager tagPluginManager = options.getTagPluginManager();\n            tagPluginManager.apply(pageNodes, errDispatcher, pageInfo);\n\n            // Optimization: concatenate contiguous template texts.\n            TextOptimizer.concatenate(this, pageNodes);\n\n            // Generate static function mapper codes.\n            ELFunctionMapper.map(pageNodes);\n\n            // generate servlet .java file\n            writer = setupContextWriter(javaFileName);\n            Generator.generate(writer, this, pageNodes);\n            writer.close();\n            writer = null;\n\n            // The writer is only used during the compile, dereference\n            // it in the JspCompilationContext when done to allow it\n            // to be GC'd and save memory.\n            ctxt.setWriter(null);\n\n            if (log.isDebugEnabled()) {\n                t4 = System.currentTimeMillis();\n                log.debug(\"Generated \" + javaFileName + \" total=\" + (t4 - t1)\n                        + \" generate=\" + (t4 - t3) + \" validate=\" + (t2 - t1));\n            }\n\n        } catch (Exception e) {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (Exception e1) {\n                    // do nothing\n                }\n            }\n            // Remove the generated .java file\n            File file = new File(javaFileName);\n            if (file.exists()) {\n                if (!file.delete()) {\n                    log.warn(Localizer.getMessage(\n                            \"jsp.warning.compiler.javafile.delete.fail\",\n                            file.getAbsolutePath()));\n                }\n            }\n            throw e;\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                } catch (Exception e2) {\n                    // do nothing\n                }\n            }\n        }\n\n        // JSR45 Support\n        if (!options.isSmapSuppressed()) {\n            smapStr = SmapUtil.generateSmap(ctxt, pageNodes);\n        }\n\n        // If any proto type .java and .class files was generated,\n        // the prototype .java may have been replaced by the current\n        // compilation (if the tag file is self referencing), but the\n        // .class file need to be removed, to make sure that javac would\n        // generate .class again from the new .java file just generated.\n        tfp.removeProtoTypeFiles(ctxt.getClassFileName());\n\n        return smapStr;\n    }",
        "    public boolean isOutDated(boolean checkClass) {\n\n        if (jsw != null\n                && (ctxt.getOptions().getModificationTestInterval() > 0)) {\n\n            if (jsw.getLastModificationTest()\n                    + (ctxt.getOptions().getModificationTestInterval() * 1000) > System\n                    .currentTimeMillis()) {\n                return false;\n            }\n            jsw.setLastModificationTest(System.currentTimeMillis());\n        }\n\n        Long jspRealLastModified = ctxt.getLastModified(ctxt.getJspFile());\n        if (jspRealLastModified.longValue() < 0) {\n            // Something went wrong - assume modification\n            return true;\n        }\n\n        long targetLastModified = 0;\n        File targetFile;\n\n        if (checkClass) {\n            targetFile = new File(ctxt.getClassFileName());\n        } else {\n            targetFile = new File(ctxt.getServletJavaFileName());\n        }\n\n        if (!targetFile.exists()) {\n            return true;\n        }\n\n        targetLastModified = targetFile.lastModified();\n        if (checkClass && jsw != null) {\n            jsw.setServletClassLastModifiedTime(targetLastModified);\n        }\n        if (targetLastModified != jspRealLastModified.longValue()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Compiler: outdated: \" + targetFile + \" \"\n                        + targetLastModified);\n            }\n            return true;\n        }\n\n        // determine if source dependent files (e.g. includes using include\n        // directives) have been changed.\n        if (jsw == null) {\n            return false;\n        }\n\n        Map<String,Long> depends = jsw.getDependants();\n        if (depends == null) {\n            return false;\n        }\n\n        Iterator<Entry<String,Long>> it = depends.entrySet().iterator();\n        while (it.hasNext()) {\n            Entry<String,Long> include = it.next();\n            try {\n                String key = include.getKey();\n                URL includeUrl;\n                if (key.startsWith(\"jar:\") || key.startsWith(\"file:\")) {\n                    includeUrl = new URL(key);\n                } else {\n                    includeUrl = ctxt.getResource(include.getKey());\n                }\n                if (includeUrl == null) {\n                    return true;\n                }\n\n                URLConnection iuc = includeUrl.openConnection();\n                long includeLastModified = 0;\n                if (iuc instanceof JarURLConnection) {\n                    includeLastModified =\n                        ((JarURLConnection) iuc).getJarEntry().getTime();\n                } else {\n                    includeLastModified = iuc.getLastModified();\n                }\n                iuc.getInputStream().close();\n\n                if (includeLastModified != include.getValue().longValue()) {\n                    return true;\n                }\n            } catch (Exception e) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Problem accessing resource. Treat as outdated.\",\n                            e);\n                return true;\n            }\n        }\n\n        return false;\n\n    }",
        "    public void removeGeneratedFiles() {\n        removeGeneratedClassFiles();\n\n        try {\n            String javaFileName = ctxt.getServletJavaFileName();\n            if (javaFileName != null) {\n                File javaFile = new File(javaFileName);\n                if (log.isDebugEnabled())\n                    log.debug(\"Deleting \" + javaFile);\n                if (javaFile.exists()) {\n                    if (!javaFile.delete()) {\n                        log.warn(Localizer.getMessage(\n                                \"jsp.warning.compiler.javafile.delete.fail\",\n                                javaFile.getAbsolutePath()));\n                    }\n                }\n            }\n        } catch (Exception e) {\n            // Remove as much as possible, log possible exceptions\n            log.warn(Localizer.getMessage(\"jsp.warning.compiler.classfile.delete.fail.unknown\"),\n                     e);\n        }\n    }",
        "    public void removeGeneratedClassFiles() {\n        try {\n            String classFileName = ctxt.getClassFileName();\n            if (classFileName != null) {\n                File classFile = new File(classFileName);\n                if (log.isDebugEnabled())\n                    log.debug(\"Deleting \" + classFile);\n                if (classFile.exists()) {\n                    if (!classFile.delete()) {\n                        log.warn(Localizer.getMessage(\n                                \"jsp.warning.compiler.classfile.delete.fail\",\n                                classFile.getAbsolutePath()));\n                    }\n                }\n            }\n        } catch (Exception e) {\n            // Remove as much as possible, log possible exceptions\n            log.warn(Localizer.getMessage(\"jsp.warning.compiler.classfile.delete.fail.unknown\"),\n                     e);\n        }\n    }",
        "    private void initClassCache(){\n        Class<?>[] clazz = new Class[]{String.class};\n        classCache.put(\"getContext\", clazz);\n        classCache.put(\"getMimeType\", clazz);\n        classCache.put(\"getResourcePaths\", clazz);\n        classCache.put(\"getResource\", clazz);\n        classCache.put(\"getResourceAsStream\", clazz);\n        classCache.put(\"getRequestDispatcher\", clazz);\n        classCache.put(\"getNamedDispatcher\", clazz);\n        classCache.put(\"getServlet\", clazz);\n        classCache.put(\"setInitParameter\", new Class[]{String.class, String.class});\n        classCache.put(\"createServlet\", new Class[]{Class.class});\n        classCache.put(\"addServlet\", new Class[]{String.class, String.class});\n        classCache.put(\"createFilter\", new Class[]{Class.class});\n        classCache.put(\"addFilter\", new Class[]{String.class, String.class});\n        classCache.put(\"createListener\", new Class[]{Class.class});\n        classCache.put(\"addListener\", clazz);\n        classCache.put(\"getFilterRegistration\", clazz);\n        classCache.put(\"getServletRegistration\", clazz);\n        classCache.put(\"getInitParameter\", clazz);\n        classCache.put(\"setAttribute\", new Class[]{String.class, Object.class});\n        classCache.put(\"removeAttribute\", clazz);\n        classCache.put(\"getRealPath\", clazz);\n        classCache.put(\"getAttribute\", clazz);\n        classCache.put(\"log\", clazz);\n        classCache.put(\"setSessionTrackingModes\", new Class[]{Set.class} );\n    }\n\n    public void log(String msg) {\n        if (SecurityUtil.isPackageProtectionEnabled()) {\n            doPrivileged(\"log\", new Object[]{msg} );\n        } else {\n            context.log(msg);\n        }\n    }",
        "    public void log(Exception exception, String msg) {\n        if (SecurityUtil.isPackageProtectionEnabled()) {\n            doPrivileged(\"log\", new Class[]{Exception.class, String.class}, \n                         new Object[]{exception,msg});\n        } else {\n            context.log(exception, msg);\n        }\n    }\n\n    public void log(String message, Throwable throwable) {\n        if (SecurityUtil.isPackageProtectionEnabled()) {\n            doPrivileged(\"log\", new Class[]{String.class, Throwable.class}, \n                         new Object[]{message, throwable});\n        } else {\n            context.log(message, throwable);\n        }\n    }\n\n    public void removeAttribute(String name) {\n        if (SecurityUtil.isPackageProtectionEnabled()) {\n            doPrivileged(\"removeAttribute\", new Object[]{name});\n        } else {\n            context.removeAttribute(name);\n        }\n    }",
        "    public void log(String message) {\n\n        context.getLogger().info(message);\n\n    }\n\n    public void log(Exception exception, String message) {\n\n        context.getLogger().error(message, exception);\n\n    }\n\n    public void log(String message, Throwable throwable) {\n\n        context.getLogger().error(message, throwable);\n\n    }",
        "    private void populateSessionTrackingModes() {\n        // URL re-writing is always enabled by default\n        defaultSessionTrackingModes = EnumSet.of(SessionTrackingMode.URL);\n        supportedSessionTrackingModes = EnumSet.of(SessionTrackingMode.URL);\n\n        if (context.getCookies()) {\n            defaultSessionTrackingModes.add(SessionTrackingMode.COOKIE);\n            supportedSessionTrackingModes.add(SessionTrackingMode.COOKIE);\n        }\n\n        // SSL not enabled by default as it can only used on its own\n        // Context > Host > Engine > Service\n        Service s = ((Engine) context.getParent().getParent()).getService();\n        Connector[] connectors = s.findConnectors();\n        // Need at least one SSL enabled connector to use the SSL session ID.\n        for (Connector connector : connectors) {\n            if (Boolean.TRUE.equals(connector.getAttribute(\"SSLEnabled\"))) {\n                supportedSessionTrackingModes.add(SessionTrackingMode.SSL);\n                break;\n            }\n        }\n    }\n\n    public void addListener(Class<? extends EventListener> listenerClass) {\n        EventListener listener;\n        try {\n            listener = createListener(listenerClass);\n        } catch (ServletException e) {\n            throw new IllegalArgumentException(sm.getString(\n                    \"applicationContext.addListener.iae.init\",\n                    listenerClass.getName()), e);\n        }\n        addListener(listener);\n    }",
        "    public void connect() throws IOException {\n\n        if (!connected) {\n\n            try {\n                date = System.currentTimeMillis();\n                path = URL_DECODER.convert(getURL().getFile(), false);\n                if (context instanceof ProxyDirContext) {\n                    ProxyDirContext proxyDirContext =\n                        (ProxyDirContext) context;\n                    String hostName = proxyDirContext.getHostName();\n                    String contextPath = proxyDirContext.getContextPath();\n                    if (hostName != null) {\n                        if (!path.startsWith(\"/\" + hostName + \"/\"))\n                            return;\n                        path = path.substring(hostName.length()+ 1);\n                    }\n                    if (contextPath != null) {\n                        if (!path.startsWith(contextPath + \"/\")) {\n                            return;\n                        }\n                        path = path.substring(contextPath.length());\n                    }\n                }\n                object = context.lookup(path);\n                attributes = context.getAttributes(path);\n                if (object instanceof Resource)\n                    resource = (Resource) object;\n                if (object instanceof DirContext)\n                    collection = (DirContext) object;\n            } catch (NamingException e) {\n                // Object not found\n            }\n\n            connected = true;\n        }\n    }"
    ],
    "55893": [
        "    public synchronized void backgroundProcess() {\n        if (getState().isAvailable() && getEnabled() && writer != null &&\n                buffered) {\n            writer.flush();\n        }\n    }\n\n    public void invoke(Request request, Response response) throws IOException,\n\n    public void log(Request request, Response response, long time) {\n        if (!getState().isAvailable() || !getEnabled() || logElements == null\n                || condition != null\n                && null != request.getRequest().getAttribute(condition)\n                || conditionIf != null\n                && null == request.getRequest().getAttribute(conditionIf)) {\n            return;\n        }\n\n        /**\n         * XXX This is a bit silly, but we want to have start and stop time and\n         * duration consistent. It would be better to keep start and stop\n         * simply in the request and/or response object and remove time\n         * (duration) from the interface.\n         */\n        long start = request.getCoyoteRequest().getStartTime();\n        Date date = getDate(start + time);\n\n        StringBuilder result = new StringBuilder(128);\n\n        for (int i = 0; i < logElements.length; i++) {\n            logElements[i].addElement(result, date, request, response, time);\n        }\n\n        log(result.toString());\n    }",
        "    public synchronized boolean rotate(String newFileName) {\n\n        if (currentLogFile != null) {\n            File holder = currentLogFile;\n            close(false);\n            try {\n                holder.renameTo(new File(newFileName));\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                log.error(sm.getString(\"accessLogValve.rotateFail\"), e);\n            }\n\n            /* Make sure date is correct */\n            dateStamp = fileDateFormatter.format(\n                    new Date(System.currentTimeMillis()));\n\n            open();\n            return true;\n        } else {\n            return false;\n        }\n\n    }\n\n    private void restore() {\n        File newLogFile = getLogFile(false);\n        File rotatedLogFile = getLogFile(true);\n        if (rotatedLogFile.exists() && !newLogFile.exists() &&\n            !rotatedLogFile.equals(newLogFile)) {\n            try {\n                if (!rotatedLogFile.renameTo(newLogFile)) {\n                    log.error(sm.getString(\"accessLogValve.renameFail\", rotatedLogFile, newLogFile));\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                log.error(sm.getString(\"accessLogValve.renameFail\", rotatedLogFile, newLogFile), e);\n            }\n        }\n    }",
        "    private synchronized void close(boolean rename) {\n        if (writer == null) {\n            return;\n        }\n        writer.flush();\n        writer.close();\n        if (rename && renameOnRotate) {\n            File newLogFile = getLogFile(true);\n            if (!newLogFile.exists()) {\n                try {\n                    if (!currentLogFile.renameTo(newLogFile)) {\n                        log.error(sm.getString(\"accessLogValve.renameFail\", currentLogFile, newLogFile));\n                    }\n                } catch (Throwable e) {\n                    ExceptionUtils.handleThrowable(e);\n                    log.error(sm.getString(\"accessLogValve.renameFail\", currentLogFile, newLogFile), e);\n                }\n            } else {\n                log.error(sm.getString(\"accessLogValve.alreadyExists\", currentLogFile, newLogFile));\n            }\n        }\n        writer = null;\n        dateStamp = \"\";\n        currentLogFile = null;\n    }",
        "    public void log(String message) {\n\n        rotate();\n\n        /* In case something external rotated the file instead */\n        if (checkExists) {\n            synchronized (this) {\n                if (currentLogFile != null && !currentLogFile.exists()) {\n                    try {\n                        close(false);\n                    } catch (Throwable e) {\n                        ExceptionUtils.handleThrowable(e);\n                        log.info(sm.getString(\"accessLogValve.closeFail\"), e);\n                    }\n\n                    /* Make sure date is correct */\n                    dateStamp = fileDateFormatter.format(\n                            new Date(System.currentTimeMillis()));\n\n                    open();\n                }\n            }\n        }\n\n        // Log this message\n        synchronized(this) {\n            if (writer != null) {\n                writer.println(message);\n                if (!buffered) {\n                    writer.flush();\n                }\n            }\n        }\n\n    }",
        "    protected static Locale findLocale(String name, Locale fallback) {\n        if (name == null || name.isEmpty()) {\n            return Locale.getDefault();\n        } else {\n            for (Locale l: Locale.getAvailableLocales()) {\n                if (name.equals(l.toString())) {\n                    return(l);\n                }\n            }\n        }\n        log.error(sm.getString(\"accessLogValve.invalidLocale\", name));\n        return fallback;\n    }\n\n    protected synchronized void startInternal() throws LifecycleException {\n\n        // Initialize the Date formatters\n        String format = getFileDateFormat();\n        fileDateFormatter = new SimpleDateFormat(format, Locale.US);\n        fileDateFormatter.setTimeZone(TimeZone.getDefault());\n        dateStamp = fileDateFormatter.format(new Date(System.currentTimeMillis()));\n        if (rotatable && renameOnRotate) {\n            restore();\n        }\n        open();\n\n        setState(LifecycleState.STARTING);\n    }\n\n    protected synchronized void stopInternal() throws LifecycleException {\n\n        setState(LifecycleState.STOPPING);\n        close(false);\n    }",
        "    protected AccessLogElement[] createLogElements() {\n        List<AccessLogElement> list = new ArrayList<AccessLogElement>();\n        boolean replace = false;\n        StringBuilder buf = new StringBuilder();\n        for (int i = 0; i < pattern.length(); i++) {\n            char ch = pattern.charAt(i);\n            if (replace) {\n                /*\n                 * For code that processes {, the behavior will be ... if I do\n                 * not encounter a closing } - then I ignore the {\n                 */\n                if ('{' == ch) {\n                    StringBuilder name = new StringBuilder();\n                    int j = i + 1;\n                    for (; j < pattern.length() && '}' != pattern.charAt(j); j++) {\n                        name.append(pattern.charAt(j));\n                    }\n                    if (j + 1 < pattern.length()) {\n                        /* the +1 was to account for } which we increment now */\n                        j++;\n                        list.add(createAccessLogElement(name.toString(),\n                                pattern.charAt(j)));\n                        i = j; /* Since we walked more than one character */\n                    } else {\n                        // D'oh - end of string - pretend we never did this\n                        // and do processing the \"old way\"\n                        list.add(createAccessLogElement(ch));\n                    }\n                } else {\n                    list.add(createAccessLogElement(ch));\n                }\n                replace = false;\n            } else if (ch == '%') {\n                replace = true;\n                list.add(new StringElement(buf.toString()));\n                buf = new StringBuilder();\n            } else {\n                buf.append(ch);\n            }\n        }\n        if (buf.length() > 0) {\n            list.add(new StringElement(buf.toString()));\n        }\n        return list.toArray(new AccessLogElement[0]);\n    }",
        "    protected AccessLogElement createAccessLogElement(char pattern) {\n        switch (pattern) {\n        case 'a':\n            return new RemoteAddrElement();\n        case 'A':\n            return new LocalAddrElement();\n        case 'b':\n            return new ByteSentElement(true);\n        case 'B':\n            return new ByteSentElement(false);\n        case 'D':\n            return new ElapsedTimeElement(true);\n        case 'F':\n            return new FirstByteTimeElement();\n        case 'h':\n            return new HostElement();\n        case 'H':\n            return new ProtocolElement();\n        case 'l':\n            return new LogicalUserNameElement();\n        case 'm':\n            return new MethodElement();\n        case 'p':\n            return new LocalPortElement();\n        case 'q':\n            return new QueryElement();\n        case 'r':\n            return new RequestElement();\n        case 's':\n            return new HttpStatusCodeElement();\n        case 'S':\n            return new SessionIdElement();\n        case 't':\n            return new DateAndTimeElement();\n        case 'T':\n            return new ElapsedTimeElement(false);\n        case 'u':\n            return new UserElement();\n        case 'U':\n            return new RequestURIElement();\n        case 'v':\n            return new LocalServerNameElement();\n        case 'I':\n            return new ThreadNameElement();\n        default:\n            return new StringElement(\"???\" + pattern + \"???\");\n        }\n    }",
        "    protected AccessLogElement[] createLogElements() {\n        if (log.isDebugEnabled()) {\n            log.debug(\"decodePattern, pattern =\" + pattern);\n        }\n        List<AccessLogElement> list = new ArrayList<AccessLogElement>();\n\n        PatternTokenizer tokenizer = new PatternTokenizer(pattern);\n        try {\n\n            // Ignore leading whitespace.\n            tokenizer.getWhiteSpaces();\n\n            if (tokenizer.isEnded()) {\n                log.info(\"pattern was just empty or whitespace\");\n                return null;\n            }\n\n            String token = tokenizer.getToken();\n            while (token != null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"token = \" + token);\n                }\n                AccessLogElement element = getLogElement(token, tokenizer);\n                if (element == null) {\n                    break;\n                }\n                list.add(element);\n                String whiteSpaces = tokenizer.getWhiteSpaces();\n                if (whiteSpaces.length() > 0) {\n                    list.add(new StringElement(whiteSpaces));\n                }\n                if (tokenizer.isEnded()) {\n                    break;\n                }\n                token = tokenizer.getToken();\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"finished decoding with element size of: \" + list.size());\n            }\n            return list.toArray(new AccessLogElement[0]);\n        } catch (IOException e) {\n            log.error(\"parse error\", e);\n            return null;\n        }\n    }",
        "    public String format(LogRecord record) {\n        StringBuilder sb = new StringBuilder();\n\n        // Timestamp\n        addTimestamp(sb, record.getMillis());\n\n        // Severity\n        sb.append(' ');\n        sb.append(record.getLevel());\n\n        // Thread\n        sb.append(' ');\n        sb.append('[');\n        sb.append(Thread.currentThread().getName());\n        sb.append(']');\n\n        // Source\n        sb.append(' ');\n        sb.append(record.getSourceClassName());\n        sb.append('.');\n        sb.append(record.getSourceMethodName());\n\n        // Message\n        sb.append(' ');\n        sb.append(formatMessage(record));\n\n        // Stack trace\n        if (record.getThrown() != null) {\n            sb.append(ST_SEP);\n            StringWriter sw = new StringWriter();\n            PrintWriter pw = new PrintWriter(sw);\n            record.getThrown().printStackTrace(pw);\n            pw.close();\n            sb.append(sw.getBuffer());\n        }\n\n        // New line for next record\n        sb.append(LINE_SEP);\n\n        return sb.toString();\n    }",
        "    public String format(LogRecord record) {\n        // Timestamp\n        StringBuilder sb = new StringBuilder(record.getMessage());\n        \n        // New line for next record\n        sb.append(LINE_SEP);\n\n        return sb.toString();\n    }",
        "    public static String escape(String value) {\n        // The only invalid char is \\n\n        // We also need to keep the string short and split it with \\nSPACE\n        // XXX TODO\n        int idx=value.indexOf( \"\\n\" );\n        if( idx < 0 ) return value;\n\n        int prev=0;\n        StringBuilder sb=new StringBuilder();\n        while( idx >= 0 ) {\n            appendHead(sb, value, prev, idx);\n\n            sb.append( \"\\\\n\\n \");\n            prev=idx+1;\n            if( idx==value.length() -1 ) break;\n            idx=value.indexOf('\\n', idx+1);\n        }\n        if( prev < value.length() )\n            appendHead( sb, value, prev, value.length());\n        return sb.toString();\n    }"
    ],
    "55978": [
        "    public void init(WebConnection connection) {\n        if (ep == null) {\n            throw new IllegalStateException(\n                    sm.getString(\"wsHttpUpgradeHandler.noPreInit\"));\n        }\n\n        this.connection = connection;\n\n        AbstractServletInputStream sis;\n        AbstractServletOutputStream sos;\n        try {\n            sis = connection.getInputStream();\n            sos = connection.getOutputStream();\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n\n        String httpSessionId = null;\n        Object session = handshakeRequest.getHttpSession();\n        if (session != null ) {\n            httpSessionId = ((HttpSession) session).getId();\n        }\n\n        // Need to call onOpen using the web application's class loader\n        // Create the frame using the application's class loader so it can pick\n        // up application specific config from the ServerContainerImpl\n        Thread t = Thread.currentThread();\n        ClassLoader cl = t.getContextClassLoader();\n        t.setContextClassLoader(applicationClassLoader);\n        try {\n            WsRemoteEndpointImplServer wsRemoteEndpointServer =\n                    new WsRemoteEndpointImplServer(sos, webSocketContainer);\n            wsSession = new WsSession(ep, wsRemoteEndpointServer,\n                    webSocketContainer, handshakeRequest.getRequestURI(),\n                    handshakeRequest.getParameterMap(),\n                    handshakeRequest.getQueryString(),\n                    handshakeRequest.getUserPrincipal(), httpSessionId,\n                    subProtocol, pathParameters, secure, endpointConfig);\n            WsFrameServer wsFrame = new WsFrameServer(\n                    sis,\n                    wsSession);\n            sos.setWriteListener(\n                    new WsWriteListener(this, wsRemoteEndpointServer));\n            ep.onOpen(wsSession, endpointConfig);\n            webSocketContainer.registerSession(ep, wsSession);\n            sis.setReadListener(new WsReadListener(this, wsFrame));\n        } catch (DeploymentException e) {\n            throw new IllegalArgumentException(e);\n        } finally {\n            t.setContextClassLoader(cl);\n        }\n    }",
        "    public final boolean isReady() {\n        if (listener == null) {\n            throw new IllegalStateException(\n                    sm.getString(\"upgrade.sos.canWrite.is\"));\n        }\n\n        // Make sure isReady() and onWritePossible() have a consistent view of\n        // buffer and fireListener when determining if the listener should fire\n        synchronized (fireListenerLock) {\n            boolean result = (buffer == null);\n            fireListener = !result;\n            return result;\n        }\n    }\n\n    public void write(int b) throws IOException {\n        synchronized (writeLock) {\n            preWriteChecks();\n            writeInternal(new byte[] { (byte) b }, 0, 1);\n        }\n    }\n\n    public void write(byte[] b, int off, int len) throws IOException {\n        synchronized (writeLock) {\n            preWriteChecks();\n            writeInternal(b, off, len);\n        }\n    }",
        "    public void close() throws IOException {\n        closeRequired = true;\n        doClose();\n    }\n\n    private void preWriteChecks() {\n        if (buffer != null) {\n            throw new IllegalStateException(\n                    sm.getString(\"upgrade.sis.write.ise\"));\n        }\n    }\n\n    private void writeInternal(byte[] b, int off, int len) throws IOException {\n        if (listener == null) {\n            // Simple case - blocking IO\n            doWrite(true, b, off, len);\n        } else {\n            // Non-blocking IO\n            // If the non-blocking read does not complete, doWrite() will add\n            // the socket back into the poller. The poller may trigger a new\n            // write event before this method has finished updating buffer. The\n            // writeLock sync makes sure that buffer is updated before the next\n            // write executes.\n            int written = doWrite(false, b, off, len);\n            if (written < len) {\n                // TODO: - Reuse the buffer\n                //       - Only reallocate if it gets too big (>8k?)\n                buffer = new byte[len - written];\n                System.arraycopy(b, off + written, buffer, 0, len - written);\n            } else {\n                buffer = null;\n            }\n        }\n    }",
        "    protected final void onWritePossible() throws IOException {\n        synchronized (writeLock) {\n            try {\n                writeInternal(buffer, 0, buffer.length);\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                Thread thread = Thread.currentThread();\n                ClassLoader originalClassLoader = thread.getContextClassLoader();\n                try {\n                    thread.setContextClassLoader(applicationLoader);\n                    listener.onError(t);\n                } finally {\n                    thread.setContextClassLoader(originalClassLoader);\n                }\n                if (t instanceof IOException) {\n                    throw (IOException) t;\n                } else {\n                    throw new IOException(t);\n                }\n            }\n\n           // Make sure isReady() and onWritePossible() have a consistent view of\n            // buffer and fireListener when determining if the listener should fire\n            boolean fire = false;\n\n            synchronized (fireListenerLock) {\n                if (buffer == null && fireListener) {\n                    fireListener = false;\n                    fire = true;\n                }\n            }\n            if (fire) {\n                Thread thread = Thread.currentThread();\n                ClassLoader originalClassLoader = thread.getContextClassLoader();\n                try {\n                    thread.setContextClassLoader(applicationLoader);\n                    listener.onWritePossible();\n                } finally {\n                    thread.setContextClassLoader(originalClassLoader);\n                }\n            }\n        }\n    }",
        "    public final boolean isFinished() {\n        if (listener == null) {\n            throw new IllegalStateException(\n                    sm.getString(\"upgrade.sis.isFinished.ise\"));\n        }\n        // The only way to finish an HTTP Upgrade connection is to close the\n        // socket.\n        return false;\n    }\n\n    public final boolean isReady() {\n        if (listener == null) {\n            throw new IllegalStateException(\n                    sm.getString(\"upgrade.sis.isReady.ise\"));\n        }\n\n        // If we already know the current state, return it.\n        if (ready != null) {\n            return ready.booleanValue();\n        }\n\n        try {\n            ready = Boolean.valueOf(doIsReady());\n        } catch (IOException e) {\n            Thread thread = Thread.currentThread();\n            ClassLoader originalClassLoader = thread.getContextClassLoader();\n            try {\n                thread.setContextClassLoader(applicationLoader);\n                listener.onError(e);\n            } finally {\n                thread.setContextClassLoader(originalClassLoader);\n            }\n            ready = Boolean.FALSE;\n        }\n        return ready.booleanValue();\n    }\n\n    public final int read() throws IOException {\n        preReadChecks();\n\n        return readInternal();\n    }",
        "    private void preReadChecks() {\n        if (listener != null && (ready == null || !ready.booleanValue())) {\n            throw new IllegalStateException(\n                    sm.getString(\"upgrade.sis.read.ise\"));\n        }\n        // No longer know if data is available\n        ready = null;\n    }\n\n    private int readInternal() throws IOException {\n        // Single byte reads for non-blocking need special handling so all\n        // single byte reads run through this method.\n        byte[] b = new byte[1];\n        int result;\n        try {\n            result = doRead(listener == null, b, 0, 1);\n        } catch (IOException ioe) {\n            closeRequired = true;\n            throw ioe;\n        }\n        if (result == 0) {\n            return -1;\n        } else if (result == -1) {\n            // Will never happen with a network socket. An IOException will be\n            // thrown when the client closes the connection.\n            // Echo back the -1 to be safe.\n            return -1;\n        } else {\n            return b[0] & 0xFF;\n        }\n    }",
        "    protected void doWrite(SendHandler handler, ByteBuffer... buffers) {\n        this.handler = handler;\n        this.buffers = buffers;\n        // This is definitely the same thread that triggered the write so a\n        // dispatch will be required.\n        onWritePossible(true);\n    }",
        "    public void onWritePossible(boolean useDispatch) {\n        boolean complete = true;\n        try {\n            // If this is false there will be a call back when it is true\n            while (sos.isReady()) {\n                complete = true;\n                for (ByteBuffer buffer : buffers) {\n                    if (buffer.hasRemaining()) {\n                        complete = false;\n                        sos.write(buffer.array(), buffer.arrayOffset(),\n                                buffer.limit());\n                        buffer.position(buffer.limit());\n                        break;\n                    }\n                }\n                if (complete) {\n                    wsWriteTimeout.unregister(this);\n                    clearHandler(null, useDispatch);\n                    if (close) {\n                        close();\n                    }\n                    break;\n                }\n            }\n\n        } catch (IOException ioe) {\n            wsWriteTimeout.unregister(this);\n            clearHandler(ioe, useDispatch);\n            close();\n        }\n        if (!complete) {\n            // Async write is in progress\n\n            long timeout = getSendTimeout();\n            if (timeout > 0) {\n                // Register with timeout thread\n                timeoutExpiry = timeout + System.currentTimeMillis();\n                wsWriteTimeout.register(this);\n            }\n        }\n    }",
        "    public abstract SocketState event(SocketStatus status) throws IOException;\n\n    public abstract SocketState upgradeDispatch() throws IOException;",
        "    public final SocketState upgradeDispatch() throws IOException {\n        return upgradeInbound.onData();\n    }\n\n    public SocketState upgradeDispatch(SocketStatus status) throws IOException {\n        return null;\n    }\n\n    public final SocketState event(SocketStatus status) throws IOException {\n        return null;\n    }"
    ],
    "55976": [
        "    public void testStop() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Wrapper w =\n            Tomcat.addServlet(root, \"tester\", new TesterServlet());\n        w.setAsyncSupported(true);\n        root.addServletMapping(\"/\", \"tester\");\n\n        Connector connector = tomcat.getConnector();\n\n        tomcat.start();\n\n        ByteChunk bc = new ByteChunk();\n        int rc = getUrl(\"http://localhost:\" + getPort() + \"/\", bc, null, null);\n\n        assertEquals(200, rc);\n        assertEquals(\"OK\", bc.toString());\n\n        rc = -1;\n        bc.recycle();\n\n        connector.stop();\n\n        try {\n            rc = getUrl(\"http://localhost:\" + getPort() + \"/\", bc, 1000,\n                    null, null);\n        } catch (SocketTimeoutException ste) {\n            // May also see this with NIO\n            // Make sure the test passes if we do\n            rc = 503;\n        }\n        assertEquals(503, rc);\n    }",
        "    public void testPort() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        Connector connector1 = tomcat.getConnector();\n        connector1.setPort(0);\n\n        Connector connector2 = new Connector();\n        connector2.setPort(0);\n\n        tomcat.getService().addConnector(connector2);\n\n        tomcat.start();\n\n        int localPort1 = connector1.getLocalPort();\n        int localPort2 = connector2.getLocalPort();\n\n        assertTrue(localPort1 > 0);\n        assertTrue(localPort2 > 0);\n    }",
        "    public void reset() throws IOException {\n        super.reset();\n        netOutBuffer.position(0);\n        netOutBuffer.limit(0);\n        netInBuffer.position(0);\n        netInBuffer.limit(0);\n        handshakeComplete = false;\n        closed = false;\n        closing = false;\n        //initiate handshake\n        sslEngine.beginHandshake();\n        handshakeStatus = sslEngine.getHandshakeStatus();\n    }\n\n    protected boolean flush(ByteBuffer buf) throws IOException {\n        int remaining = buf.remaining();\n        if ( remaining > 0 ) {\n            int written = sc.write(buf);\n            return written >= remaining;\n        }else {\n            return true;\n        }\n    }",
        "    public int handshake(boolean read, boolean write) throws IOException {\n        if ( handshakeComplete ) return 0; //we have done our initial handshake\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; //we still have data to write\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    //should never happen\n                    throw new IOException(\"NOT_HANDSHAKING during handshake\");\n                }\n                case FINISHED: {\n                    //we are complete if we have delivered the last package\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    //return 0 if we are complete, otherwise we still have data to write\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    //perform the wrap function\n                    handshake = handshakeWrap(write);\n                    if ( handshake.getStatus() == Status.OK ){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        //wrap should always work with our buffers\n                        throw new IOException(\"Unexpected status:\" + handshake.getStatus() + \" during handshake WRAP.\");\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        //should actually return OP_READ if we have NEED_UNWRAP\n                        return SelectionKey.OP_WRITE;\n                    }\n                    //fall down to NEED_UNWRAP on the same call, will result in a\n                    //BUFFER_UNDERFLOW if it needs data\n                }\n                //$FALL-THROUGH$\n                case NEED_UNWRAP: {\n                    //perform the unwrap function\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        //read more data, reregister for OP_READ\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(\"Invalid handshake status:\"+handshakeStatus+\" during handshake UNWRAP.\");\n                    }//switch\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(\"Invalid handshake status:\"+handshakeStatus);\n            }//switch\n        }//while\n        //return 0 if we are complete, otherwise reregister for any activity that\n        //would cause this method to be called again.\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }",
        "    public void rehandshake(long timeout) throws IOException {\n        //validate the network buffers are empty\n        if (netInBuffer.position() > 0 && netInBuffer.position()<netInBuffer.limit()) throw new IOException(\"Network input buffer still contains data. Handshake will fail.\");\n        if (netOutBuffer.position() > 0 && netOutBuffer.position()<netOutBuffer.limit()) throw new IOException(\"Network output buffer still contains data. Handshake will fail.\");\n        if (getBufHandler().getReadBuffer().position()>0 && getBufHandler().getReadBuffer().position()<getBufHandler().getReadBuffer().limit()) throw new IOException(\"Application input buffer still contains data. Data would have been lost.\");\n        if (getBufHandler().getWriteBuffer().position()>0 && getBufHandler().getWriteBuffer().position()<getBufHandler().getWriteBuffer().limit()) throw new IOException(\"Application output buffer still contains data. Data would have been lost.\");\n        reset();\n        boolean isReadable = true;\n        boolean isWriteable = true;\n        boolean handshaking = true;\n        Selector selector = null;\n        SelectionKey key = null;\n        try {\n            while (handshaking) {\n                int hsStatus = this.handshake(isReadable, isWriteable);\n                switch (hsStatus) {\n                    case -1 : throw new EOFException(\"EOF during handshake.\");\n                    case  0 : handshaking = false; break;\n                    default : {\n                        long now = System.currentTimeMillis();\n                        if (selector==null) {\n                            synchronized (Selector.class) {\n                                // Selector.open() isn't thread safe\n                                // http://bugs.sun.com/view_bug.do?bug_id=6427854\n                                // Affects 1.6.0_29, fixed in 1.7.0_01\n                                selector = Selector.open();\n                            }\n                            key = getIOChannel().register(selector, hsStatus);\n                        } else {\n                            key.interestOps(hsStatus);\n                        }\n                        int keyCount = selector.select(timeout);\n                        if (keyCount == 0 && ((System.currentTimeMillis()-now) >= timeout)) {\n                            throw new SocketTimeoutException(\"Handshake operation timed out.\");\n                        }\n                        isReadable = key.isReadable();\n                        isWriteable = key.isWritable();\n                    }\n                }\n            }\n        } catch (IOException x) {\n            throw x;\n        } catch (Exception cx) {\n            IOException x = new IOException(cx);\n            throw x;\n        } finally {\n            if (key!=null) try {key.cancel();} catch (Exception ignore) {}\n            if (selector!=null) try {selector.close();} catch (Exception ignore) {}\n        }\n    }",
        "    protected SSLEngineResult.HandshakeStatus tasks() {\n        Runnable r = null;\n        while ( (r = sslEngine.getDelegatedTask()) != null) {\n            r.run();\n        }\n        return sslEngine.getHandshakeStatus();\n    }\n\n    protected SSLEngineResult handshakeWrap(boolean doWrite) throws IOException {\n        //this should never be called with a network buffer that contains data\n        //so we can clear it here.\n        netOutBuffer.clear();\n        //perform the wrap\n        SSLEngineResult result = sslEngine.wrap(bufHandler.getWriteBuffer(), netOutBuffer);\n        //prepare the results to be written\n        netOutBuffer.flip();\n        //set the status\n        handshakeStatus = result.getHandshakeStatus();\n        //optimization, if we do have a writable channel, write it now\n        if ( doWrite ) flush(netOutBuffer);\n        return result;\n    }",
        "    protected SSLEngineResult handshakeUnwrap(boolean doread) throws IOException {\n\n        if (netInBuffer.position() == netInBuffer.limit()) {\n            //clear the buffer if we have emptied it out on data\n            netInBuffer.clear();\n        }\n        if ( doread )  {\n            //if we have data to read, read it\n            int read = sc.read(netInBuffer);\n            if (read == -1) throw new IOException(\"EOF encountered during handshake.\");\n        }\n        SSLEngineResult result;\n        boolean cont = false;\n        //loop while we can perform pure SSLEngine data\n        do {\n            //prepare the buffer with the incoming data\n            netInBuffer.flip();\n            //call unwrap\n            result = sslEngine.unwrap(netInBuffer, bufHandler.getReadBuffer());\n            //compact the buffer, this is an optional method, wonder what would happen if we didn't\n            netInBuffer.compact();\n            //read in the status\n            handshakeStatus = result.getHandshakeStatus();\n            if ( result.getStatus() == SSLEngineResult.Status.OK &&\n                 result.getHandshakeStatus() == HandshakeStatus.NEED_TASK ) {\n                //execute tasks if we need to\n                handshakeStatus = tasks();\n            }\n            //perform another unwrap?\n            cont = result.getStatus() == SSLEngineResult.Status.OK &&\n                   handshakeStatus == HandshakeStatus.NEED_UNWRAP;\n        }while ( cont );\n        return result;\n    }",
        "    public void close() throws IOException {\n        if (closing) return;\n        closing = true;\n        sslEngine.closeOutbound();\n\n        if (!flush(netOutBuffer)) {\n            throw new IOException(\"Remaining data in the network buffer, can't send SSL close message, force a close with close(true) instead\");\n        }\n        //prep the buffer for the close message\n        netOutBuffer.clear();\n        //perform the close, since we called sslEngine.closeOutbound\n        SSLEngineResult handshake = sslEngine.wrap(getEmptyBuf(), netOutBuffer);\n        //we should be in a close state\n        if (handshake.getStatus() != SSLEngineResult.Status.CLOSED) {\n            throw new IOException(\"Invalid close state, will not send network data.\");\n        }\n        //prepare the buffer for writing\n        netOutBuffer.flip();\n        //if there is data to be written\n        flush(netOutBuffer);\n\n        //is the channel closed?\n        closed = (!netOutBuffer.hasRemaining() && (handshake.getHandshakeStatus() != HandshakeStatus.NEED_WRAP));\n    }\n\n    public void close(boolean force) throws IOException {\n        try {\n            close();\n        }finally {\n            if ( force || closed ) {\n                closed = true;\n                sc.socket().close();\n                sc.close();\n            }\n        }\n    }",
        "    public int read(ByteBuffer dst) throws IOException {\n        //if we want to take advantage of the expand function, make sure we only use the ApplicationBufferHandler's buffers\n        if ( dst != bufHandler.getReadBuffer() ) throw new IllegalArgumentException(\"You can only read using the application read buffer provided by the handler.\");\n        //are we in the middle of closing or closed?\n        if ( closing || closed) return -1;\n        //did we finish our handshake?\n        if (!handshakeComplete) throw new IllegalStateException(\"Handshake incomplete, you must complete handshake before reading data.\");\n\n        //read from the network\n        int netread = sc.read(netInBuffer);\n        //did we reach EOF? if so send EOF up one layer.\n        if (netread == -1) return -1;\n\n        //the data read\n        int read = 0;\n        //the SSL engine result\n        SSLEngineResult unwrap;\n        do {\n            //prepare the buffer\n            netInBuffer.flip();\n            //unwrap the data\n            unwrap = sslEngine.unwrap(netInBuffer, dst);\n            //compact the buffer\n            netInBuffer.compact();\n\n            if ( unwrap.getStatus()==Status.OK || unwrap.getStatus()==Status.BUFFER_UNDERFLOW ) {\n                //we did receive some data, add it to our total\n                read += unwrap.bytesProduced();\n                //perform any tasks if needed\n                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK) tasks();\n                //if we need more network data, then bail out for now.\n                if ( unwrap.getStatus() == Status.BUFFER_UNDERFLOW ) break;\n            }else if ( unwrap.getStatus()==Status.BUFFER_OVERFLOW && read>0 ) {\n                //buffer overflow can happen, if we have read data, then\n                //empty out the dst buffer before we do another read\n                break;\n            }else {\n                //here we should trap BUFFER_OVERFLOW and call expand on the buffer\n                //for now, throw an exception, as we initialized the buffers\n                //in the constructor\n                throw new IOException(\"Unable to unwrap data, invalid status: \" + unwrap.getStatus());\n            }\n        } while ( (netInBuffer.position() != 0)); //continue to unwrapping as long as the input buffer has stuff\n        return (read);\n    }",
        "    public int write(ByteBuffer src) throws IOException {\n        if ( src == this.netOutBuffer ) {\n            //we can get here through a recursive call\n            //by using the NioBlockingSelector\n            int written = sc.write(src);\n            return written;\n        } else {\n            //make sure we can handle expand, and that we only use on buffer\n            if ( (!this.isSendFile()) && (src != bufHandler.getWriteBuffer()) ) throw new IllegalArgumentException(\"You can only write using the application write buffer provided by the handler.\");\n            //are we closing or closed?\n            if ( closing || closed) throw new IOException(\"Channel is in closing state.\");\n\n            //the number of bytes written\n            int written = 0;\n\n            if (!flush(netOutBuffer)) {\n                //we haven't emptied out the buffer yet\n                return written;\n            }\n\n            /*\n             * The data buffer is empty, we can reuse the entire buffer.\n             */\n            netOutBuffer.clear();\n\n            SSLEngineResult result = sslEngine.wrap(src, netOutBuffer);\n            written = result.bytesConsumed();\n            netOutBuffer.flip();\n\n            if (result.getStatus() == Status.OK) {\n                if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) tasks();\n            } else {\n                throw new IOException(\"Unable to wrap data, invalid engine state: \" +result.getStatus());\n            }\n\n            //force a flush\n            flush(netOutBuffer);\n\n            return written;\n        }\n    }",
        "    public boolean flushOutbound() throws IOException {\n        int remaining = netOutBuffer.remaining();\n        flush(netOutBuffer);\n        int remaining2= netOutBuffer.remaining();\n        return remaining2 < remaining;\n    }",
        "    public void testWithHttpSep() throws Exception {\n        System.setProperty(\n                \"org.apache.tomcat.util.http.ServerCookie.ALLOW_HTTP_SEPARATORS_IN_V0\",\n                \"true\");\n\n        TestCookieHttpSepClient client = new TestCookieHttpSepClient();\n        client.doRequest();\n    }",
        "    public void testTrailingHeadersSizeLimit() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        Tomcat.addServlet(ctx, \"servlet\", new EchoHeaderServlet());\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        // Limit the size of the trailing header\n        tomcat.getConnector().setProperty(\"maxTrailerSize\", \"10\");\n        tomcat.start();\n\n        String[] request = new String[]{\n            \"POST /echo-params.jsp HTTP/1.1\" + SimpleHttpClient.CRLF +\n            \"Host: any\" + SimpleHttpClient.CRLF +\n            \"Transfer-encoding: chunked\" + SimpleHttpClient.CRLF +\n            \"Content-Type: application/x-www-form-urlencoded\" +\n                    SimpleHttpClient.CRLF +\n            \"Connection: close\" + SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF +\n            \"3\" + SimpleHttpClient.CRLF +\n            \"a=0\" + SimpleHttpClient.CRLF +\n            \"4\" + SimpleHttpClient.CRLF +\n            \"&b=1\" + SimpleHttpClient.CRLF +\n            \"0\" + SimpleHttpClient.CRLF +\n            \"x-trailer: Test\" + SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF };\n\n        TrailerClient client =\n                new TrailerClient(tomcat.getConnector().getLocalPort());\n        client.setRequest(request);\n\n        client.connect();\n        client.processRequest();\n        // Expected to fail because the trailers are longer\n        // than the set limit of 10 bytes\n        assertTrue(client.isResponse500());\n    }",
        "    private void doTestExtensionSizeLimit(int len, boolean ok) throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        tomcat.getConnector().setProperty(\n                \"maxExtensionSize\", Integer.toString(EXT_SIZE_LIMIT));\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        Tomcat.addServlet(ctx, \"servlet\", new EchoHeaderServlet());\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        tomcat.start();\n\n        String extName = \";foo=\";\n        StringBuilder extValue = new StringBuilder(len);\n        for (int i = 0; i < (len - extName.length()); i++) {\n            extValue.append(\"x\");\n        }\n\n        String[] request = new String[]{\n            \"POST /echo-params.jsp HTTP/1.1\" + SimpleHttpClient.CRLF +\n            \"Host: any\" + SimpleHttpClient.CRLF +\n            \"Transfer-encoding: chunked\" + SimpleHttpClient.CRLF +\n            \"Content-Type: application/x-www-form-urlencoded\" +\n                    SimpleHttpClient.CRLF +\n            \"Connection: close\" + SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF +\n            \"3\" + extName + extValue.toString() + SimpleHttpClient.CRLF +\n            \"a=0\" + SimpleHttpClient.CRLF +\n            \"4\" + SimpleHttpClient.CRLF +\n            \"&b=1\" + SimpleHttpClient.CRLF +\n            \"0\" + SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF };\n\n        TrailerClient client =\n                new TrailerClient(tomcat.getConnector().getLocalPort());\n        client.setRequest(request);\n\n        client.connect();\n        client.processRequest();\n\n        if (ok) {\n            assertTrue(client.isResponse200());\n        } else {\n            assertTrue(client.isResponse500());\n        }\n    }",
        "    public void testNoTrailingHeaders() throws Exception {\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n\n        Tomcat.addServlet(ctx, \"servlet\", new EchoHeaderServlet());\n        ctx.addServletMapping(\"/\", \"servlet\");\n\n        tomcat.start();\n\n        String request =\n            \"POST /echo-params.jsp HTTP/1.1\" + SimpleHttpClient.CRLF +\n            \"Host: any\" + SimpleHttpClient.CRLF +\n            \"Transfer-encoding: chunked\" + SimpleHttpClient.CRLF +\n            \"Content-Type: application/x-www-form-urlencoded\" +\n                    SimpleHttpClient.CRLF +\n            \"Connection: close\" + SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF +\n            \"3\" + SimpleHttpClient.CRLF +\n            \"a=0\" + SimpleHttpClient.CRLF +\n            \"4\" + SimpleHttpClient.CRLF +\n            \"&b=1\" + SimpleHttpClient.CRLF +\n            \"0\" + SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF;\n\n        TrailerClient client =\n                new TrailerClient(tomcat.getConnector().getLocalPort());\n        client.setRequest(new String[] {request});\n\n        client.connect();\n        client.processRequest();\n        assertEquals(\"nullnull7nullnull\", client.getResponseBody());\n    }",
        "    public void testAsyncClose() throws Exception {\n\n        if (!isCometSupported()) {\n            log.info(\"This test is skipped, because this connector does not support Comet.\");\n            return;\n        }\n\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Tomcat.addServlet(root, \"comet\", new SimpleCometServlet());\n        root.addServletMapping(\"/comet\", \"comet\");\n        Tomcat.addServlet(root, \"hello\", new HelloWorldServlet());\n        root.addServletMapping(\"/hello\", \"hello\");\n        root.getPipeline().addValve(new AsyncCometCloseValve());\n        tomcat.getConnector().setProperty(\"connectionTimeout\", \"5000\");\n        tomcat.start();\n\n        // Create connection to Comet servlet\n        final Socket socket =\n            SocketFactory.getDefault().createSocket(\"localhost\", getPort());\n        socket.setSoTimeout(5000);\n\n        final OutputStream os = socket.getOutputStream();\n        String requestLine = \"POST http://localhost:\" + getPort() +\n                \"/comet HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"transfer-encoding: chunked\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n\n        InputStream is = socket.getInputStream();\n        ResponseReaderThread readThread = new ResponseReaderThread(is);\n        readThread.start();\n\n        // Wait for the comet request/response to finish\n        int count = 0;\n        while (count < 10 && !readThread.getResponse().endsWith(\"0\\r\\n\\r\\n\")) {\n            Thread.sleep(500);\n            count++;\n        }\n\n        if (count == 10) {\n            fail(\"Comet request did not complete\");\n        }\n\n        // Send a standard HTTP request on the same connection\n        requestLine = \"GET http://localhost:\" + getPort() +\n                \"/hello HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n\n        // Check for the expected response\n        count = 0;\n        while (count < 10 && !readThread.getResponse().contains(\n                HelloWorldServlet.RESPONSE_TEXT)) {\n            Thread.sleep(500);\n            count++;\n        }\n\n        if (count == 10) {\n            fail(\"Non-comet request did not complete\");\n        }\n\n        readThread.join();\n        os.close();\n        is.close();\n    }",
        "    public void testSyncClose() throws Exception {\n\n        if (!isCometSupported()) {\n            log.info(\"This test is skipped, because this connector does not support Comet.\");\n            return;\n        }\n\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Tomcat.addServlet(root, \"comet\", new CometCloseServlet());\n        root.addServletMapping(\"/comet\", \"comet\");\n        Tomcat.addServlet(root, \"hello\", new HelloWorldServlet());\n        root.addServletMapping(\"/hello\", \"hello\");\n        tomcat.getConnector().setProperty(\"connectionTimeout\", \"5000\");\n        tomcat.start();\n\n        // Create connection to Comet servlet\n        final Socket socket =\n            SocketFactory.getDefault().createSocket(\"localhost\", getPort());\n        socket.setSoTimeout(5000);\n\n        final OutputStream os = socket.getOutputStream();\n        String requestLine = \"POST http://localhost:\" + getPort() +\n                \"/comet HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"transfer-encoding: chunked\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n        // Don't send any data\n        os.write(\"0\\r\\n\\r\\n\".getBytes());\n\n        InputStream is = socket.getInputStream();\n        ResponseReaderThread readThread = new ResponseReaderThread(is);\n        readThread.start();\n\n        // Wait for the comet request/response to finish\n        int count = 0;\n        while (count < 10 && !readThread.getResponse().endsWith(\"0\\r\\n\\r\\n\")) {\n            Thread.sleep(500);\n            count++;\n        }\n\n        Assert.assertTrue(readThread.getResponse().contains(\"2\\r\\nOK\"));\n\n        if (count == 10) {\n            fail(\"Comet request did not complete\");\n        }\n\n        // Send a standard HTTP request on the same connection\n        requestLine = \"GET http://localhost:\" + getPort() +\n                \"/hello HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"connection: close\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n\n        // Check for the expected response\n        count = 0;\n        while (count < 10 && !readThread.getResponse().contains(\n                HelloWorldServlet.RESPONSE_TEXT)) {\n            Thread.sleep(500);\n            count++;\n        }\n\n        if (count == 10) {\n            fail(\"Non-comet request did not complete\");\n        }\n\n        readThread.join();\n        os.close();\n        is.close();\n    }",
        "    public void testCometConnectorStop() throws Exception {\n\n        if (!isCometSupported()) {\n            log.info(\"This test is skipped, because this connector does not support Comet.\");\n            return;\n        }\n\n        // Setup Tomcat instance\n        SimpleCometServlet servlet = new SimpleCometServlet();\n        Tomcat tomcat = getTomcatInstance();\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Tomcat.addServlet(root, \"comet\", servlet);\n        root.addServletMapping(\"/\", \"comet\");\n        tomcat.start();\n\n        // Create connection to Comet servlet\n        final Socket socket =\n            SocketFactory.getDefault().createSocket(\"localhost\", getPort());\n        socket.setSoTimeout(10000);\n\n        final OutputStream os = socket.getOutputStream();\n        String requestLine = \"POST http://localhost:\" + getPort() +\n                \"/ HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"transfer-encoding: chunked\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n\n        PingWriterThread writeThread = new PingWriterThread(100, os);\n        writeThread.start();\n\n        InputStream is = socket.getInputStream();\n        ResponseReaderThread readThread = new ResponseReaderThread(is);\n        readThread.start();\n\n        // Allow the first couple of PING messages to be written\n        Thread.sleep(3000);\n\n        tomcat.getConnector().stop();\n\n        int count = 0;\n        // Wait for the read thread to stop\n        while (readThread.isAlive() && count < 50) {\n            Thread.sleep(100);\n            count ++;\n        }\n\n        // Wait for the write thread to stop\n        count = 0;\n        while (writeThread.isAlive() && count < 50) {\n            Thread.sleep(100);\n            count ++;\n        }\n\n        // Destroy the connector once the executor has sent the end event\n        tomcat.getConnector().destroy();\n\n        String[] response = readThread.getResponse().split(\"\\r\\n\");\n        String lastMessage = \"\";\n        String lastResponseLine = \"\";\n        for (int i = response.length; --i >= 0;) {\n            lastMessage = response[i];\n            if (lastMessage.startsWith(\"Client:\")) {\n                break;\n            }\n        }\n        for (int i = response.length; --i >= 0;) {\n            lastResponseLine = response[i];\n            if (lastResponseLine.length() > 0) {\n                break;\n            }\n        }\n        StringBuilder status = new StringBuilder();\n        // Expected, but is not 100% reliable:\n        // WriteThread exception: java.net.SocketException\n        // ReaderThread exception: null\n        // Last message: [Client: END]\n        // Last response line: [0] (empty chunk)\n        // Last comet event: [END]\n        // END event occurred: [true]\n        status.append(\"Status:\");\n        status.append(\"\\nWriterThread exception: \" + writeThread.getException());\n        status.append(\"\\nReaderThread exception: \" + readThread.getException());\n        status.append(\"\\nLast message: [\" + lastMessage + \"]\");\n        status.append(\"\\nLast response line: [\" + lastResponseLine + \"]\");\n        status.append(\"\\nLast comet event: [\" + servlet.getLastEvent() + \"]\");\n        status.append(\"\\nEND event occurred: [\" + servlet.getEndEventOccurred() + \"]\");\n        if (writeThread.getException() == null\n                || !lastMessage.contains(\"Client: END\")\n                || !EventType.END.equals(servlet.getLastEvent())) {\n            log.error(status);\n        } else {\n            log.info(status);\n        }\n        assertTrue(\"Comet END event not received\",\n                EventType.END.equals(servlet.getLastEvent()));\n    }",
        "    private boolean isCometSupported() {\n        String protocol =\n            getTomcatInstance().getConnector().getProtocolHandlerClassName();\n        if (protocol.indexOf(\"Nio\") == -1 && protocol.indexOf(\"Apr\") == -1) {\n            return false;\n        } else {\n            return true;\n        }\n    }",
        "    public void put(Selector s) throws IOException {\n        if ( SHARED ) return;\n        if ( enabled ) active.decrementAndGet();\n        if ( enabled && (maxSpareSelectors==-1 || spare.get() < Math.min(maxSpareSelectors,maxSelectors)) ) {\n            spare.incrementAndGet();\n            selectors.offer(s);\n        }\n        else s.close();\n    }\n\n    public void close() throws IOException {\n        enabled = false;\n        Selector s;\n        while ( (s = selectors.poll()) != null ) s.close();\n        spare.set(0);\n        active.set(0);\n        if (blockingSelector!=null) {\n            blockingSelector.close();\n        }\n        if ( SHARED && getSharedSelector()!=null ) {\n            getSharedSelector().close();\n            SHARED_SELECTOR = null;\n        }\n    }\n\n    public void open() throws IOException {\n        enabled = true;\n        getSharedSelector();\n        if (SHARED) {\n            blockingSelector = new NioBlockingSelector();\n            blockingSelector.open(getSharedSelector());\n        }\n\n    }",
        "    public int write(ByteBuffer buf, NioChannel socket, Selector selector, long writeTimeout) throws IOException {\n        return write(buf,socket,selector,writeTimeout,true);\n    }\n\n    public int read(ByteBuffer buf, NioChannel socket, Selector selector, long readTimeout) throws IOException {\n        return read(buf,socket,selector,readTimeout,true);\n    }",
        "    public int read(ByteBuffer buf, NioChannel socket, Selector selector, long readTimeout, boolean block) throws IOException {\n        if ( SHARED && block ) {\n            return blockingSelector.read(buf,socket,readTimeout);\n        }\n        SelectionKey key = null;\n        int read = 0;\n        boolean timedout = false;\n        int keycount = 1; //assume we can write\n        long time = System.currentTimeMillis(); //start the timeout timer\n        try {\n            while ( (!timedout) ) {\n                int cnt = 0;\n                if ( keycount > 0 ) { //only read if we were registered for a read\n                    cnt = socket.read(buf);\n                    if (cnt == -1) throw new EOFException();\n                    read += cnt;\n                    if (cnt > 0) continue; //read some more\n                    if (cnt==0 && (read>0 || (!block) ) ) break; //we are done reading\n                }\n                if ( selector != null ) {//perform a blocking read\n                    //register OP_WRITE to the selector\n                    if (key==null) key = socket.getIOChannel().register(selector, SelectionKey.OP_READ);\n                    else key.interestOps(SelectionKey.OP_READ);\n                    keycount = selector.select(readTimeout);\n                }\n                if (readTimeout > 0 && (selector == null || keycount == 0) ) timedout = (System.currentTimeMillis()-time)>=readTimeout;\n            }//while\n            if ( timedout ) throw new SocketTimeoutException();\n        } finally {\n            if (key != null) {\n                key.cancel();\n                if (selector != null) selector.selectNow();//removes the key from this selector\n            }\n        }\n        return read;\n    }",
        "    public void testWithTEVoid() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Use the normal Tomcat ROOT context\n        File root = new File(\"test/webapp-3.0\");\n        tomcat.addWebapp(\"\", root.getAbsolutePath());\n\n        tomcat.start();\n\n        String request =\n            \"POST /echo-params.jsp HTTP/1.1\" + SimpleHttpClient.CRLF +\n            \"Host: any\" + SimpleHttpClient.CRLF +\n            \"Transfer-encoding: void\" + SimpleHttpClient.CRLF +\n            \"Content-Length: 9\" + SimpleHttpClient.CRLF +\n            \"Content-Type: application/x-www-form-urlencoded\" +\n                    SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF +\n            \"test=data\";\n\n        Client client = new Client(tomcat.getConnector().getLocalPort());\n        client.setRequest(new String[] {request});\n\n        client.connect();\n        client.processRequest();\n        assertTrue(client.isResponse501());\n    }",
        "    public void testWithTEBuffered() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Use the normal Tomcat ROOT context\n        File root = new File(\"test/webapp-3.0\");\n        tomcat.addWebapp(\"\", root.getAbsolutePath());\n\n        tomcat.start();\n\n        String request =\n            \"POST /echo-params.jsp HTTP/1.1\" + SimpleHttpClient.CRLF +\n            \"Host: any\" + SimpleHttpClient.CRLF +\n            \"Transfer-encoding: buffered\" + SimpleHttpClient.CRLF +\n            \"Content-Length: 9\" + SimpleHttpClient.CRLF +\n            \"Content-Type: application/x-www-form-urlencoded\" +\n                    SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF +\n            \"test=data\";\n\n        Client client = new Client(tomcat.getConnector().getLocalPort());\n        client.setRequest(new String[] {request});\n\n        client.connect();\n        client.processRequest();\n        assertTrue(client.isResponse501());\n    }",
        "    public void testWithTEIdentity() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Use the normal Tomcat ROOT context\n        File root = new File(\"test/webapp-3.0\");\n        tomcat.addWebapp(\"\", root.getAbsolutePath());\n\n        tomcat.start();\n\n        String request =\n            \"POST /echo-params.jsp HTTP/1.1\" + SimpleHttpClient.CRLF +\n            \"Host: any\" + SimpleHttpClient.CRLF +\n            \"Transfer-encoding: identity\" + SimpleHttpClient.CRLF +\n            \"Content-Length: 9\" + SimpleHttpClient.CRLF +\n            \"Content-Type: application/x-www-form-urlencoded\" +\n                    SimpleHttpClient.CRLF +\n            \"Connection: close\" + SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF +\n            \"test=data\";\n\n        Client client = new Client(tomcat.getConnector().getLocalPort());\n        client.setRequest(new String[] {request});\n\n        client.connect();\n        client.processRequest();\n        assertTrue(client.isResponse200());\n        assertTrue(client.getResponseBody().contains(\"test - data\"));\n    }",
        "    public void testWithTESavedRequest() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Use the normal Tomcat ROOT context\n        File root = new File(\"test/webapp-3.0\");\n        tomcat.addWebapp(\"\", root.getAbsolutePath());\n\n        tomcat.start();\n\n        String request =\n            \"POST /echo-params.jsp HTTP/1.1\" + SimpleHttpClient.CRLF +\n            \"Host: any\" + SimpleHttpClient.CRLF +\n            \"Transfer-encoding: savedrequest\" + SimpleHttpClient.CRLF +\n            \"Content-Length: 9\" + SimpleHttpClient.CRLF +\n            \"Content-Type: application/x-www-form-urlencoded\" +\n                    SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF +\n            \"test=data\";\n\n        Client client = new Client(tomcat.getConnector().getLocalPort());\n        client.setRequest(new String[] {request});\n\n        client.connect();\n        client.processRequest();\n        assertTrue(client.isResponse501());\n    }",
        "    public void testWithTEUnsupported() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Use the normal Tomcat ROOT context\n        File root = new File(\"test/webapp-3.0\");\n        tomcat.addWebapp(\"\", root.getAbsolutePath());\n\n        tomcat.start();\n\n        String request =\n            \"POST /echo-params.jsp HTTP/1.1\" + SimpleHttpClient.CRLF +\n            \"Host: any\" + SimpleHttpClient.CRLF +\n            \"Transfer-encoding: unsupported\" + SimpleHttpClient.CRLF +\n            \"Content-Length: 9\" + SimpleHttpClient.CRLF +\n            \"Content-Type: application/x-www-form-urlencoded\" +\n                    SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF +\n            \"test=data\";\n\n        Client client = new Client(tomcat.getConnector().getLocalPort());\n        client.setRequest(new String[] {request});\n\n        client.connect();\n        client.processRequest();\n        assertTrue(client.isResponse501());\n    }",
        "    public void testPipelining() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctxt = tomcat.addContext(\"\",\n                System.getProperty(\"java.io.tmpdir\"));\n\n        // Add protected servlet\n        Tomcat.addServlet(ctxt, \"TesterServlet\", new TesterServlet());\n        ctxt.addServletMapping(\"/foo\", \"TesterServlet\");\n\n        tomcat.start();\n\n        String requestPart1 =\n            \"GET /foo HTTP/1.1\" + SimpleHttpClient.CRLF;\n        String requestPart2 =\n            \"Host: any\" + SimpleHttpClient.CRLF +\n            SimpleHttpClient.CRLF;\n\n        final Client client = new Client(tomcat.getConnector().getLocalPort());\n        client.setRequest(new String[] {requestPart1, requestPart2});\n        client.setRequestPause(1000);\n        client.setUseContentLength(true);\n        client.connect();\n\n        Runnable send = new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    client.sendRequest();\n                    client.sendRequest();\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        };\n        Thread t = new Thread(send);\n        t.start();\n\n        // Sleep for 1500 ms which should mean the all of request 1 has been\n        // sent and half of request 2\n        Thread.sleep(1500);\n\n        // Now read the first response\n        client.readResponse(true);\n        assertFalse(client.isResponse50x());\n        assertTrue(client.isResponse200());\n        assertEquals(\"OK\", client.getResponseBody());\n\n        // Read the second response. No need to sleep, read will block until\n        // there is data to process\n        client.readResponse(true);\n        assertFalse(client.isResponse50x());\n        assertTrue(client.isResponse200());\n        assertEquals(\"OK\", client.getResponseBody());\n    }",
        "    public void testChunking11NoContentLength() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctxt = tomcat.addContext(\"\",\n                System.getProperty(\"java.io.tmpdir\"));\n\n        Tomcat.addServlet(ctxt, \"NoContentLengthFlushingServlet\",\n                new NoContentLengthFlushingServlet());\n        ctxt.addServletMapping(\"/test\", \"NoContentLengthFlushingServlet\");\n\n        tomcat.start();\n\n        ByteChunk responseBody = new ByteChunk();\n        Map<String,List<String>> responseHeaders =\n                new HashMap<String,List<String>>();\n        int rc = getUrl(\"http://localhost:\" + getPort() + \"/test\", responseBody,\n                responseHeaders);\n\n        assertEquals(HttpServletResponse.SC_OK, rc);\n        assertTrue(responseHeaders.containsKey(\"Transfer-Encoding\"));\n        List<String> encodings = responseHeaders.get(\"Transfer-Encoding\");\n        assertEquals(1, encodings.size());\n        assertEquals(\"chunked\", encodings.get(0));\n    }",
        "    private void doTestBug53677(boolean flush) throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n\n        // Must have a real docBase - just use temp\n        Context ctxt = tomcat.addContext(\"\",\n                System.getProperty(\"java.io.tmpdir\"));\n\n        Tomcat.addServlet(ctxt, \"LargeHeaderServlet\",\n                new LargeHeaderServlet(flush));\n        ctxt.addServletMapping(\"/test\", \"LargeHeaderServlet\");\n\n        tomcat.start();\n\n        ByteChunk responseBody = new ByteChunk();\n        Map<String,List<String>> responseHeaders =\n                new HashMap<String,List<String>>();\n        int rc = getUrl(\"http://localhost:\" + getPort() + \"/test\", responseBody,\n                responseHeaders);\n\n        assertEquals(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, rc);\n        if (responseBody.getLength() > 0) {\n            // It will be >0 if the standard error page handlign has been\n            // triggered\n            assertFalse(responseBody.toString().contains(\"FAIL\"));\n        }\n    }",
        "    public void testBug55772() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n        tomcat.getConnector().setProperty(\"processorCache\", \"1\");\n        tomcat.getConnector().setProperty(\"maxThreads\", \"1\");\n\n        // Must have a real docBase - just use temp\n        Context ctxt = tomcat.addContext(\"\",\n                System.getProperty(\"java.io.tmpdir\"));\n\n        Tomcat.addServlet(ctxt, \"async\", new Bug55772Servlet());\n        ctxt.addServletMapping(\"/*\", \"async\");\n\n        tomcat.start();\n\n        String request1 = \"GET /async HTTP/1.1\\r\\n\" +\n                \"Host: localhost:\" + getPort() + \"\\r\\n\" +\n                \"Connection: keep-alive\\r\\n\" +\n                \"Cache-Control: max-age=0\\r\\n\" +\n                \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\\r\\n\" +\n                \"User-Agent: Request1\\r\\n\" +\n                \"Accept-Encoding: gzip,deflate,sdch\\r\\n\" +\n                \"Accept-Language: en-US,en;q=0.8,fr;q=0.6,es;q=0.4\\r\\n\" +\n                \"Cookie: something.that.should.not.leak=true\\r\\n\" +\n                \"\\r\\n\";\n\n        String request2 = \"GET /async HTTP/1.1\\r\\n\" +\n                \"Host: localhost:\" + getPort() + \"\\r\\n\" +\n                \"Connection: keep-alive\\r\\n\" +\n                \"Cache-Control: max-age=0\\r\\n\" +\n                \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\\r\\n\" +\n                \"User-Agent: Request2\\r\\n\" +\n                \"Accept-Encoding: gzip,deflate,sdch\\r\\n\" +\n                \"Accept-Language: en-US,en;q=0.8,fr;q=0.6,es;q=0.4\\r\\n\" +\n                \"\\r\\n\";\n\n        Socket connection = null;\n        try {\n            connection = new Socket(\"localhost\", getPort());\n            connection.setSoLinger(true, 0);\n            Writer writer = new OutputStreamWriter(connection.getOutputStream(),\n                    B2CConverter.getCharset(\"US-ASCII\"));\n            writer.write(request1);\n            writer.flush();\n\n            bug55772Latch1.await();\n            connection.close();\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (IOException ioe) {\n                    // Ignore\n                }\n            }\n        }\n\n        bug55772Latch2.await();\n        bug55772IsSecondRequest = true;\n\n        try {\n            connection = new Socket(\"localhost\", getPort());\n            connection.setSoLinger(true, 0);\n            Writer writer = new OutputStreamWriter(connection.getOutputStream(),\n                    B2CConverter.getCharset(\"US-ASCII\"));\n            writer.write(request2);\n            writer.flush();\n            connection.getInputStream().read();\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (IOException ioe) {\n                    // Ignore\n                }\n            }\n        }\n\n        bug55772Latch3.await();\n        if (bug55772RequestStateLeaked) {\n            Assert.fail(\"State leaked between requests!\");\n        }\n    }",
        "    protected void actionInternal(ActionCode actionCode, Object param) {\n\n        if (actionCode == ActionCode.ASYNC_COMPLETE) {\n            if (asyncStateMachine.asyncComplete()) {\n                ((NioEndpoint)endpoint).processSocket(this.socket,\n                        SocketStatus.OPEN_READ, false);\n            }\n\n        } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {\n            if (param == null) return;\n            long timeout = ((Long)param).longValue();\n            final KeyAttachment ka = (KeyAttachment)socket.getAttachment(false);\n            ka.setTimeout(timeout);\n\n        } else if (actionCode == ActionCode.ASYNC_DISPATCH) {\n            if (asyncStateMachine.asyncDispatch()) {\n                ((NioEndpoint)endpoint).processSocket(this.socket,\n                        SocketStatus.OPEN_READ, true);\n            }\n        }\n    }\n\n    protected void resetTimeouts() {\n        // The NIO connector uses the timeout configured on the wrapper in the\n        // poller. Therefore, it needs to be reset once asycn processing has\n        // finished.\n        final KeyAttachment attach = (KeyAttachment)socket.getAttachment(false);\n        if (!error && attach != null &&\n                asyncStateMachine.isAsyncDispatching()) {\n            long soTimeout = endpoint.getSoTimeout();\n\n            //reset the timeout\n            if (keepAliveTimeout > 0) {\n                attach.setTimeout(keepAliveTimeout);\n            } else {\n                attach.setTimeout(soTimeout);\n            }\n        }\n\n    }",
        "    public boolean receive() throws IOException {\n\n        first = false;\n        bodyMessage.reset();\n        \n        readMessage(bodyMessage, true);\n\n        // No data received.\n        if (bodyMessage.getLen() == 0) {\n            // just the header\n            // Don't mark 'end of stream' for the first chunk.\n            return false;\n        }\n        int blen = bodyMessage.peekInt();\n        if (blen == 0) {\n            return false;\n        }\n\n        bodyMessage.getBodyBytes(bodyBytes);\n        empty = false;\n        return true;\n    }",
        "    private long createAprPool() {\n\n        // Create the pool for the server socket\n        try {\n            return Pool.create(0);\n        } catch (UnsatisfiedLinkError e) {\n            log.error(\"Could not create socket pool\", e);\n            return 0;\n        }\n    }\n\n    private void destroyAprSocket(long serverSock, long pool) {\n        if (serverSock != 0) {\n            Socket.shutdown(serverSock, Socket.APR_SHUTDOWN_READWRITE);\n            Socket.close(serverSock);\n            Socket.destroy(serverSock);\n        }\n\n        if (pool != 0) {\n            Pool.destroy(pool);\n            pool = 0;\n        }\n    }",
        "    public void testStartStopBindOnInit() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n        File appDir = new File(getBuildDirectory(), \"webapps/examples\");\n        tomcat.addWebapp(null, \"/examples\", appDir.getAbsolutePath());\n\n        tomcat.start();\n\n        int port = getPort();\n\n        tomcat.getConnector().stop();\n        Exception e = null;\n        ServerSocket s = null;\n        long pool = 0;\n        long nativeSocket = 0;\n        boolean isApr = tomcat.getConnector().getProtocolHandlerClassName().contains(\"Apr\");\n        try {\n            // This should throw an Exception\n            if (isApr) {\n                pool = createAprPool();\n                assertTrue(pool != 0);\n                nativeSocket = createAprSocket(port, pool);\n                assertTrue(nativeSocket != 0);\n            } else {\n                s = new ServerSocket(port, 100,\n                        InetAddress.getByName(\"localhost\"));\n            }\n        } catch (Exception e1) {\n            e = e1;\n        } finally {\n            try {\n                if (isApr) {\n                    destroyAprSocket(nativeSocket, pool);\n                } else if (s != null) {\n                    s.close();\n                }\n            } catch (Exception e2) { /* Ignore */ }\n        }\n        if (e != null) {\n            log.info(\"Exception was\", e);\n        }\n        assertNotNull(e);\n        tomcat.getConnector().start();\n    }",
        "    public void testStartStopBindOnStart() throws Exception {\n        Tomcat tomcat = getTomcatInstance();\n        Connector c = tomcat.getConnector();\n        c.setProperty(\"bindOnInit\", \"false\");\n\n        File appDir = new File(getBuildDirectory(), \"webapps/examples\");\n        tomcat.addWebapp(null, \"/examples\", appDir.getAbsolutePath());\n\n\n        tomcat.start();\n        int port = getPort();\n\n        tomcat.getConnector().stop();\n        Exception e = null;\n        ServerSocket s = null;\n        long pool = 0;\n        long nativeSocket = 0;\n        boolean isApr = tomcat.getConnector().getProtocolHandlerClassName().contains(\"Apr\");\n        try {\n            // This should not throw an Exception\n            if (isApr) {\n                pool = createAprPool();\n                assertTrue(pool != 0);\n                nativeSocket = createAprSocket(port, pool);\n                assertTrue(nativeSocket != 0);\n            } else {\n                s = new ServerSocket(port, 100,\n                        InetAddress.getByName(\"localhost\"));\n            }\n        } catch (Exception e1) {\n            e = e1;\n        } finally {\n            try {\n                if (isApr) {\n                    destroyAprSocket(nativeSocket, pool);\n                } else if (s != null) {\n                    s.close();\n                }\n            } catch (Exception e2) { /* Ignore */ }\n        }\n        assertNull(e);\n        tomcat.getConnector().start();\n    }",
        "    protected void doFlush() throws IOException {\n        NioEndpoint.KeyAttachment att =\n                (NioEndpoint.KeyAttachment) channel.getAttachment(false);\n        if (att == null) {\n            throw new IOException(\"Key must be cancelled\");\n        }\n        long writeTimeout = att.getWriteTimeout();\n        Selector selector = null;\n        try {\n            selector = pool.get();\n        } catch ( IOException x ) {\n            //ignore\n        }\n        try {\n            do {\n                if (channel.flush(true, selector, writeTimeout)) {\n                    break;\n                }\n            } while (true);\n        } finally {\n            if (selector != null) {\n                pool.put(selector);\n            }\n        }\n    }\n\n    protected void doClose() throws IOException {\n        channel.close(true);\n    }"
    ]
}